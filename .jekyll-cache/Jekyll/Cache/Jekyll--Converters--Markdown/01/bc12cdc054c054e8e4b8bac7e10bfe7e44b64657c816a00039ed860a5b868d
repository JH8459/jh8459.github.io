I"8<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="algorithm" /></p>
<h2 id="toy-37-coinchange">TOY 37. coinChange</h2>
<h3 id="문제">문제</h3>
<hr />
<p>다양한 동전들을 가지고 특정 금액을 만들 수 있는 모든 경우의 수를 리턴해야 합니다.</p>

<ul>
  <li>예를 들어, 100원, 500원짜리 동전을 가지고 1,000원을 만들 수 있는 방법은 총 3가지 입니다.</li>
  <li>100원 10개, 100원 5개 + 500원 1개, 500원 2개</li>
</ul>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1--total">인자 1 : total</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">string</code> 타입의 알파벳 소문자와 숫자로 이루어진 문자열</li>
  <li><code class="language-plaintext highlighter-rouge">str1.length</code>는 50 이하</li>
</ul>

<h4 id="인자-2--str2">인자 2 : str2</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">string</code> 타입의 알파벳 소문자와 숫자로 이루어진 문자열</li>
  <li><code class="language-plaintext highlighter-rouge">str1.length</code>는 50 이하</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입을 리턴해야 합니다.</li>
</ul>

<h3 id="주의사항">주의사항</h3>
<hr />
<ul>
  <li>LCS의 <strong>길이</strong>를 리턴해야 합니다.</li>
  <li>LCS가 존재하지 않는 경우, 0을 리턴해야 합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">LCS</span><span class="p">(</span><span class="dl">'</span><span class="s1">abcd</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">aceb</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 2 ('ab' or 'ac')</span>

<span class="nx">output</span> <span class="o">=</span> <span class="nx">LCS</span><span class="p">(</span><span class="dl">'</span><span class="s1">acaykp</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">capcak</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 4 ('acak')</span>
</code></pre></div></div>

<h3 id="advanced">Advanced</h3>
<hr />
<ul>
  <li>LCS를 계산하는 효율적인 알고리즘(<code class="language-plaintext highlighter-rouge">O(M * N)</code>)이 존재합니다(두 문자열의 길이가 각각 M, N일 경우). 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.</li>
  <li>LCS의 길이 대신 LCS 자체를 리턴하는 함수를 구현해 보시기 바랍니다.</li>
  <li>LIS와 LCS를 변형하여 두 문자열 또는 배열을 입력받아 LCIS(Longest Common Increasing Subsequence)의 길이 또는 그 자체를 리턴하는 함수를 구현해 보시기 바랍니다.</li>
</ul>

<h2 id="toy-37-solution">TOY 37. Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />
<p><del>어제와 이하동문..</del></p>

<h3 id="문제풀이">문제풀이</h3>
<hr />

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
<hr />

<p><strong>Reference Code</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// naive solution: O(2^N)</span>
<span class="c1">// 두 문자열의 길이(m, n)가 같다고 가정할 경우에 한함</span>
<span class="c1">// 최악의 경우는 일치하는 문자가 전혀 없을 경우이고 이때는 한쪽 문자열의 끝까지 비교해야 하므로 2^n 만큼의 시간이 걸린다.</span>
<span class="c1">// const LCS = function (str1, str2) {</span>
<span class="c1">//   // str1.slice 또는 str1.substring은 O(N)만큼의 오버헤드가 추가된다.</span>
<span class="c1">//   // 비교는 인덱스만 알아도 충분하다.</span>
<span class="c1">//   // left: str1의 인덱스, right: str2의 인덱스, len: 현재까지 만든 LCS의 길이</span>
<span class="c1">//   const compareOneByOne = (left, right) =&gt; {</span>
<span class="c1">//     // base case</span>
<span class="c1">//     // 더 이상 비교가 불가능한 경우</span>
<span class="c1">//     if (left === str1.length || right === str2.length) return 0;</span>

<span class="c1">//     // 일치하는 문자가 있는 경우</span>
<span class="c1">//     // 인덱스를 공통으로 이동하고, 길이를 1개 추가한다.</span>
<span class="c1">//     if (str1[left] === str2[right]) {</span>
<span class="c1">//       return 1 + compareOneByOne(left + 1, right + 1);</span>
<span class="c1">//     }</span>

<span class="c1">//     // 일치하는 문자가 없는 경우</span>
<span class="c1">//     // 길이는 그대로고, str1과 str2 중에서 어느 쪽의 문자를 포기할지 정해야한다.</span>
<span class="c1">//     // 양쪽다 가능성이 있으므로 양쪽을 모두 탐색하고 그 중 큰 값을 선택한다.</span>
<span class="c1">//     return Math.max(</span>
<span class="c1">//       compareOneByOne(left + 1, right), //</span>
<span class="c1">//       compareOneByOne(left, right + 1)</span>
<span class="c1">//     );</span>
<span class="c1">//   };</span>

<span class="c1">//   return compareOneByOne(0, 0);</span>
<span class="c1">// };</span>

<span class="c1">// dynamic programming: O(M * N)</span>
<span class="c1">// memoization을 활용해 중복 계산되는 문제를 제거한다.</span>
<span class="c1">// LCS('ABCD', 'ACEB')의 경우 재귀 호출을 적어보면 아래와 같다.</span>
<span class="c1">// =&gt; 1) LCS('BCD', 'CEB')</span>
<span class="c1">//  =&gt; 1-1) LCS('CD', 'CEB'), 1-2) LCS('BCD', 'EB')</span>
<span class="c1">//    =&gt; 1-1-1) LCS('D', 'CEB'), 1-1-2) LCS('CD', 'EB')</span>
<span class="c1">//    =&gt; 1-2-1) LCS('CD', 'EB'), 1-2-2) LCS('BCD', 'B')</span>
<span class="c1">// 더 볼 필요 없이 1-1-2)와 1-2-1)은 같은 문제임을 알 수 있다.</span>
<span class="kd">const</span> <span class="nx">LCS</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">str1</span><span class="p">,</span> <span class="nx">str2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">M</span> <span class="o">=</span> <span class="nx">str1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="nx">str2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">memo</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 중복 계산을 방지하기 위해 left, right</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nb">Array</span><span class="p">(</span><span class="nx">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

  <span class="kd">const</span> <span class="nx">compareOneByOne</span> <span class="o">=</span> <span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">memo</span><span class="p">[</span><span class="nx">left</span><span class="p">][</span><span class="nx">right</span><span class="p">]</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">left</span><span class="p">][</span><span class="nx">right</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">===</span> <span class="nx">str1</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="nx">right</span> <span class="o">===</span> <span class="nx">str2</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">str1</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">===</span> <span class="nx">str2</span><span class="p">[</span><span class="nx">right</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">memo</span><span class="p">[</span><span class="nx">left</span><span class="p">][</span><span class="nx">right</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">compareOneByOne</span><span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">left</span><span class="p">][</span><span class="nx">right</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="nx">memo</span><span class="p">[</span><span class="nx">left</span><span class="p">][</span><span class="nx">right</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span>
      <span class="nx">compareOneByOne</span><span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">len</span><span class="p">),</span> <span class="c1">//</span>
      <span class="nx">compareOneByOne</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">left</span><span class="p">][</span><span class="nx">right</span><span class="p">];</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">compareOneByOne</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// dynamic programming: O(M * N)</span>
<span class="c1">// tabulation(테이블에 정리)을 활용해 bottom-up 방식으로 해결</span>
<span class="c1">// const LCS = function (str1, str2) {</span>
<span class="c1">//   const M = str1.length;</span>
<span class="c1">//   const N = str2.length;</span>
<span class="c1">//   // table[i][j]는 str1.slice(0, i)와 str2.slice(0, j)의 LCS를 저장</span>
<span class="c1">//   // str1.slice(0, i)는 0부터 i 바로 직전까지를 의미함 (i까지가 아님에 주의)</span>
<span class="c1">//   const table = [];</span>
<span class="c1">//   for (let i = 0; i &lt; M + 1; i++) table.push(Array(N + 1).fill(-1));</span>

<span class="c1">//   for (let i = 0; i &lt;= M; i++) {</span>
<span class="c1">//     for (let j = 0; j &lt;= N; j++) {</span>
<span class="c1">//       if (i === 0 || j === 0) {</span>
<span class="c1">//         // i 또는 j가 0인 경우, 한쪽 문자열이 길이가 0이라는 의미이다.</span>
<span class="c1">//         // LCS가 존재할 수 없으므로, 0을 저장한다.</span>
<span class="c1">//         table[i][j] = 0;</span>
<span class="c1">//       } else if (str1[i - 1] === str2[j - 1]) {</span>
<span class="c1">//         // 두 문자가 같은 경우</span>
<span class="c1">//         // 양쪽 문자열의 인덱스가 한 개씩 이전인 상태에서 만들 수 있는 LCS의 길이보다 1만큼 더 길다.</span>
<span class="c1">//         table[i][j] = 1 + table[i - 1][j - 1];</span>
<span class="c1">//       } else {</span>
<span class="c1">//         // 두 문자가 같지 않은 경우</span>
<span class="c1">//         // 둘 중 한쪽을 포기하는 경우에 만들 수 있는 LCS의 길이를 따른다.</span>
<span class="c1">//         table[i][j] = Math.max(table[i - 1][j], table[i][j - 1]);</span>
<span class="c1">//       }</span>
<span class="c1">//     }</span>
<span class="c1">//   }</span>
<span class="c1">//   return table[M][N];</span>
<span class="c1">// };</span>
</code></pre></div></div>

<h2 id="오늘-느낀-점">오늘 느낀 점</h2>
<p><del>어제와 이하동문</del></p>

<p>우선은 <strong>Reference Code</strong>를 보고 이해하는 수준에서 마무리하였다.  <del>다시 풀어 볼 예정</del></p>

<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>TOY 35. uglyNumbers
TOY 37. coinChange</li>
</ul>
:ET