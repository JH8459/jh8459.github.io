I"02<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="Algorithm" /></p>
<h2 id="집밥이-그리워">집밥이 그리워</h2>
<h3 id="문제">문제</h3>
<hr />
<p>김코딩은 몇 년의 해외 출장 끝에 본가에 내려왔습니다. 오랜만에 보는 김코딩의 얼굴에 반가웠던 부모님은 상다리가 부러질 정도로 음식을 만들었습니다. 감동의 재회도 잠시, 의자에 앉아 식사를 하려던 김코딩은 무엇부터 먹어야 될지 깊은 생각에 빠졌습니다. 정성스럽게 차려 주신 만큼, 최대한 많은 방법으로 다양하게 먹고 싶었기 때문입니다.</p>

<p>밥은 한 가지이며 반찬은 다수일 때, 밥과 함께 먹을 수 있는 반찬의 모든 경우의 수를 배열에 담아 리턴하세요.</p>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1-sidedishes">인자 1: sideDishes</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">String</code> 타입의 영문으로 된 반찬이 나열되어 있는 배열</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">Array</code> 타입을 리턴해야 합니다.</li>
  <li>밥과 함께 먹을 수 있는 반찬의 모든 경우의 수가 담긴 배열</li>
</ul>

<h3 id="출력-1">출력</h3>
<hr />
<ul>
  <li>반찬은 영문으로 작성이 되어 있습니다.</li>
  <li>반찬은 중복되지 않습니다.</li>
  <li>반찬을 먹지 않는 것도 포함됩니다. (출력되는 2차원 배열은 빈 배열을 포함합니다.)</li>
  <li>반찬은 3개 이상 99개 이하입니다.</li>
  <li>출력되는 배열은 전부 사전식 순서(lexical order)로 정렬되어야 합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">missHouseMeal</span><span class="p">([</span><span class="dl">"</span><span class="s2">eggroll</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">kimchi</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">fishSoup</span><span class="dl">"</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span>
<span class="cm">/*
[ [], 
  [ 'eggroll' ], 
  [ 'eggroll', 'fishSoup' ], 
  [ 'eggroll', 'fishSoup', 'kimchi' ], 
  [ 'eggroll', 'kimchi' ], 
  [ 'fishSoup' ], 
  [ 'fishSoup', 'kimchi' ], 
  [ 'kimchi' ]
] 
*/</span>
</code></pre></div></div>

<h2 id="solution">Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />

<p><a href="https://jh8459.github.io/algorithm/21.09.07.algorithm2/" target="_blank">TOY 11. powerSet </a> 문제의 로직과 똑같다.</p>

<p>DFS 방식으로 재귀를 구현하는 방식이다.. 사실 다시 떠올라서 풀진 못하였고, 이전에 정리한 내용을 보며 다시 풀어보았다.</p>

<h3 id="문제풀이">문제풀이</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">missHouseMeal</span><span class="p">(</span><span class="nx">sideDishes</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">sideDishes</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="kd">const</span> <span class="nx">recursive</span> <span class="o">=</span> <span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="nx">subset</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">idx</span> <span class="o">===</span> <span class="nx">sideDishes</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 마지막 문자까지 검토한 경우</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">subset</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// recursive case</span>
    <span class="c1">// idx번째 문자가 포함되지 않는 경우</span>
    <span class="nx">recursive</span><span class="p">(</span><span class="nx">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">subset</span><span class="p">);</span>

    <span class="c1">// idx번째 문자가 포함되는 경우</span>
    <span class="nx">recursive</span><span class="p">(</span><span class="nx">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">subset</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">sideDishes</span><span class="p">[</span><span class="nx">idx</span><span class="p">]));</span>
  <span class="p">};</span>

  <span class="nx">recursive</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[]);</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<hr />

<p><strong>Reference Code</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최대 공약수(유클리드 호제법: Euclidean algorithm)</span>
<span class="kd">function</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">divideChocolateStick</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 최대공약수를 구한다.</span>
  <span class="c1">// M, N의 순서는 상관없다.</span>
  <span class="kd">const</span> <span class="nx">GCD</span> <span class="o">=</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//</span>

  <span class="c1">// 약수는 대칭적이므로 제곱근까지만 반복해도 된다.</span>
  <span class="c1">// 예) 36의 약수는 1, 2, 3, 4, 6, 9, 12, 18, 36이다.</span>
  <span class="c1">// 제곱근을 기준으로 양쪽의 값 하나씩 곱했을 때 36이 되기 때문에</span>
  <span class="c1">// 제곱근 보다 큰 약수는 제곱근보다 작은 약수에서 구할 수 있다.</span>
  <span class="kd">const</span> <span class="nx">sqrt</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">GCD</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">sqrt</span><span class="p">;</span> <span class="nx">left</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">GCD</span> <span class="o">%</span> <span class="nx">left</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 최대공약수의 약수인 경우 중 제곱근 보다 작은 약수의 경우</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">left</span><span class="p">,</span> <span class="nx">M</span> <span class="o">/</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">N</span> <span class="o">/</span> <span class="nx">left</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">*</span> <span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">GCD</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 제곱근이 아닌 경우(제곱근 보다 작은)</span>
        <span class="nx">right</span> <span class="o">=</span> <span class="nx">GCD</span> <span class="o">/</span> <span class="nx">left</span><span class="p">;</span> <span class="c1">// 최대 공약수를 제곱근이 아닌 수로 나누면 제곱근 보다 큰 약수를 구할 수 있다.</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">right</span><span class="p">,</span> <span class="nx">M</span> <span class="o">/</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">N</span> <span class="o">/</span> <span class="nx">right</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// '빼빼로를 받게 되는 직원의 수'를 기준으로 오름차순으로 정렬</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">op1</span><span class="p">,</span> <span class="nx">op2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="느낀-점">느낀 점</h2>

<p>시간복잡도 문제인지 TEST CASE 1개를 통과하지 못하였다.</p>

<p><strong>Reference Code</strong>를 참조해보니 모든 약수를 체크하지 않고 제곱근까지 접근하는 로직으로 구현한걸 보았다. <del>귀찮아서 내 코드를 고치진 않았다…</del></p>

<p>최대 공약수를 구하는 알고리즘이 인상 깊었다. 자주 쓰이진 않겠지만 이렇게 구현이 된다는 것 자체가 신기하다…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최대공약수(유클리드 호제법: Euclidean algorithm)</span>
<span class="kd">function</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
:ET