I"t2<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="algorithm" /></p>
<h2 id="toy-40-longestpalindrome">TOY 40. longestPalindrome</h2>
<h3 id="문제">문제</h3>
<hr />
<p>문자열을 입력받아 부분 문자열 중 가장 긴 <em>(palindrome)</em> 의 길이를 리턴해야 합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">palindrome</code>: 데이터를 앞에서 뒤로 또는 뒤에서 앞으로 조회한 결과가 동일한 경우</li>
</ul>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1--jobs">인자 1 : jobs</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입을 요소로 갖는 배열</li>
  <li><code class="language-plaintext highlighter-rouge">jobs[i]</code>는 1,000 이하의 양의 정수</li>
  <li><code class="language-plaintext highlighter-rouge">jobs.length</code>는 1,000 이하</li>
</ul>

<h4 id="인자-2--workersnum">인자 2 : workersNum</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입의 1,000 이하의 자연수</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입을 리턴해야 합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">jobs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">workersNum</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">jobAllocation</span><span class="p">(</span><span class="nx">jobs</span><span class="p">,</span> <span class="nx">workersNum</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 11 (1, 2, 3, 4 / 5, 6 / 7)</span>

<span class="nx">jobs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>
<span class="nx">workersNum</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">output</span> <span class="o">=</span> <span class="nx">jobAllocation</span><span class="p">(</span><span class="nx">jobs</span><span class="p">,</span> <span class="nx">workersNum</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 19 (10, 2, 3, 4 / 16 / 10 / 10</span>
</code></pre></div></div>
<h2 id="toy-39-solution">TOY 39. Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />

<h3 id="문제풀이">문제풀이</h3>
<hr />

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
<hr />

<p><strong>Reference Code</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 총 5개의 작업을 3명이서 작업한다고 가정한다.</span>
<span class="c1">// 첫번째 작업자는 최대 3개의 작업을 할 수 있다.</span>
<span class="c1">// (jobs, workersNum)으로 표기하면, (jobs는 작업량이 아닌 작업의 인덱스만 표기한다고 한다)</span>
<span class="c1">// 처음은 ([0, 1, 2, 3, 4], 3)인 상태이다.</span>
<span class="c1">//  1) 첫번째 작업자가 1개의 작업을 하고 나머지 작업을 2명이 작업</span>
<span class="c1">//    =&gt; ([1, 2, 3, 4], 2)</span>
<span class="c1">//  2) 첫번째 작업자가 2개의 작업을 하고 나머지 작업을 2명이 작업</span>
<span class="c1">//    =&gt; ([2, 3, 4], 2)</span>
<span class="c1">//  3) 첫번째 작업자가 3개의 작업을 하고 나머지 작업을 2명이 작업</span>
<span class="c1">//    =&gt; ([3, 4], 2)</span>
<span class="c1">// 아래 두 가지 경우를 통해, 문제가 중복되어 계산된다는 것을 알 수 있다.</span>
<span class="c1">//  1-1) 첫번째 작업자가 1개의 작업을 하고, 그 다음 작업자가 2개의 작업을 한 경우</span>
<span class="c1">//    =&gt; ([3, 4], 1)</span>
<span class="c1">//  2-1) 첫번째 작업자가 2개의 작업을 하고, 그 다음 작업자가 1개의 작업을 한 경우</span>
<span class="c1">//    =&gt; ([3, 4], 1)</span>
<span class="c1">// 메모이제이션을 통해 중복 계산을 피한다.</span>

<span class="kd">const</span> <span class="nx">jobAllocation</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">jobs</span><span class="p">,</span> <span class="nx">wokersNum</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// memo[i][j]는 i번째 worker가 j번째 job부터 작업한다고 할 때,</span>
  <span class="c1">// 최대 작업량이 최소가 되는 분배에서의 최대 작업량을 저장한다.</span>
  <span class="c1">// i, j 모두 인덱스이므로 0부터 시작</span>
  <span class="kd">const</span> <span class="nx">memo</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">wokersNum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nb">Array</span><span class="p">(</span><span class="nx">jobs</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="c1">// 마지막 작업자는 남아있는 모든 작업을 다 해야하므로 쉽게 계산이 가능하다.</span>
  <span class="c1">// 마지막 작업자는 최대 나머지 작업자의 수만큼을 제외한 일만 할 수 있다.</span>
  <span class="kd">let</span> <span class="nx">workload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">jobs</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">wokersNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">workload</span> <span class="o">=</span> <span class="nx">workload</span> <span class="o">+</span> <span class="nx">jobs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">memo</span><span class="p">[</span><span class="nx">wokersNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">workload</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">aux</span> <span class="o">=</span> <span class="p">(</span><span class="nx">workerIdx</span><span class="p">,</span> <span class="nx">jobIdx</span><span class="p">,</span> <span class="nx">jobs</span><span class="p">,</span> <span class="nx">left</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 이미 계산한 적이 있는 경우, 다시 풀지 않는다</span>
    <span class="c1">// 마지막 작업자의 작업량을 전부 계산했으므로, 탈출 조건을 굳이 작성하지 않아도 된다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">memo</span><span class="p">[</span><span class="nx">workerIdx</span><span class="p">][</span><span class="nx">jobIdx</span><span class="p">]</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">workerIdx</span><span class="p">][</span><span class="nx">jobIdx</span><span class="p">];</span>

    <span class="kd">let</span> <span class="nx">workload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_SAFE_INTEGER</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">jobIdx</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">jobs</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">left</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">workload</span> <span class="o">=</span> <span class="nx">workload</span> <span class="o">+</span> <span class="nx">jobs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="c1">// 가장 많이 일하는 사람의 작업량을 구한다.</span>
      <span class="kd">const</span> <span class="nx">hardest</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span>
        <span class="nx">workload</span><span class="p">,</span>
        <span class="nx">aux</span><span class="p">(</span><span class="nx">workerIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">jobs</span><span class="p">,</span> <span class="nx">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">);</span>
      <span class="c1">// 그 작업량이 최소화되는 분배에서 최대 작업량을 구한다.</span>
      <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">hardest</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">memo</span><span class="p">[</span><span class="nx">workerIdx</span><span class="p">][</span><span class="nx">jobIdx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">min</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">min</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">aux</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">jobs</span><span class="p">,</span> <span class="nx">wokersNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="오늘-느낀-점">오늘 느낀 점</h2>

<p>우선은 <strong>Reference Code</strong>를 보고 이해하는 수준에서 마무리하였다.  <del>다시 풀어 볼 예정</del></p>

<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>TOY 40. longestPalindrome
TOY 40. longestPalindrome</li>
</ul>
:ET