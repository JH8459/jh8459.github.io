I"%<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="algorithm" /></p>
<h2 id="toy-33-lis">TOY 33. LIS</h2>
<h3 id="문제">문제</h3>
<hr />
<p>정수를 요소로 갖는 문자열을 입력받아 다음의 조건을 만족하는 <em>LIS</em> 의 길이를 리턴해야 합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LIS</code>: 배열의 연속되지 않는 부분 배열 중 모든 요소가 <strong>엄격하게 오름차순</strong>으로 정렬된 가장 긴 부분 배열(Longest Increasing Subsequence)</li>
  <li>배열 <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>의 subseqeunce는 <code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[2]</code>, <code class="language-plaintext highlighter-rouge">[3]</code>, <code class="language-plaintext highlighter-rouge">[1, 2]</code>, <code class="language-plaintext highlighter-rouge">[1, 3]</code>, <code class="language-plaintext highlighter-rouge">[2, 3]</code>, <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code> 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">엄격한 오름차순</code>: 배열이 동일한 값을 가진 요소없이 오름차순으로 정렬되어 있는 경우를 말합니다.</li>
</ul>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1--arr">인자 1 : arr</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입을 요소로 갖는 배열</li>
  <li><code class="language-plaintext highlighter-rouge">arr.length</code>는 60,000 이하</li>
  <li><code class="language-plaintext highlighter-rouge">arr[i]</code>는 100,000 이하의 양의 정수</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입을 리턴해야 합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">LIS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 1 (3 or 2)</span>

<span class="nx">output</span> <span class="o">=</span> <span class="nx">LIS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 3 (3, 10, 20)</span>
</code></pre></div></div>

<h3 id="advanced">Advanced</h3>
<hr />
<ul>
  <li>LIS를 계산하는 효율적인 알고리즘(<code class="language-plaintext highlighter-rouge">O(N^2)</code>)이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.</li>
  <li>subsequence는 문자열 또는 배열같이 순서가 있는 데이터에서 순서의 대소 관계가 유지되는 모든 부분 문자열 또는 부분 배열을 의미합니다. sequence가 순서 또는 서열을 의미하기 때문에 subsequence는 부분 서열이라고 부르기도 합니다. 반면 substring 또는 subarray는 연속된 형태의 부분 문자열 또는 부분 배열을 의미합니다. 문자열 <code class="language-plaintext highlighter-rouge">'abcd'</code>의 subsequence와 substring은 각각 아래와 같습니다.
    <ul>
      <li>substring: <code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'b'</code>, <code class="language-plaintext highlighter-rouge">'c'</code>, <code class="language-plaintext highlighter-rouge">'d'</code>, <code class="language-plaintext highlighter-rouge">'ab'</code>, <code class="language-plaintext highlighter-rouge">'bc'</code>, <code class="language-plaintext highlighter-rouge">'cd'</code>, <code class="language-plaintext highlighter-rouge">'abc'</code>, <code class="language-plaintext highlighter-rouge">'bcd'</code>, <code class="language-plaintext highlighter-rouge">'abcd'</code></li>
      <li>subsequence: <code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'b'</code>, <code class="language-plaintext highlighter-rouge">'c'</code>, <code class="language-plaintext highlighter-rouge">'d'</code>, <code class="language-plaintext highlighter-rouge">'ab'</code>, <code class="language-plaintext highlighter-rouge">'ac'</code>, <code class="language-plaintext highlighter-rouge">'ad'</code>, <code class="language-plaintext highlighter-rouge">'bc'</code>, <code class="language-plaintext highlighter-rouge">'bd'</code>, <code class="language-plaintext highlighter-rouge">'cd'</code>, <code class="language-plaintext highlighter-rouge">'abc'</code>, <code class="language-plaintext highlighter-rouge">'abd'</code>, <code class="language-plaintext highlighter-rouge">'acd'</code>, <code class="language-plaintext highlighter-rouge">'bcd'</code>, <code class="language-plaintext highlighter-rouge">'abcd'</code></li>
      <li>LIS의 길이 대신 LIS 자체를 리턴하는 함수를 구현해 보시기 바랍니다.</li>
    </ul>
  </li>
</ul>

<h2 id="toy-33-solution">TOY 33. Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />

<h3 id="문제풀이">문제풀이</h3>
<hr />

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">LIS</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="c1">// lis[i]는 i에서 끝나는 LIS의 길이를 저장</span>
  <span class="c1">// 최소한 각 요소 하나로 LIS를 만들 수 있으므로 1로 초기화한다.</span>
  <span class="kd">const</span> <span class="nx">lis</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">N</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// i에서 끝나는 LIS의 길이</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// i 이전의 인덱스만 검사하면 된다.</span>
    <span class="c1">// i는 1부터 시작하므로, 짧은 길이부터 검사한다. (bottom-up 방식)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">lis</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">lis</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">lis</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">lis</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">lis</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>
<hr />

<p><strong>Reference Code</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h2 id="오늘-느낀-점">오늘 느낀 점</h2>
<p>우선은 <strong>Reference Code</strong>를 보고 이해하는 수준에서 마무리하였다.  <del>다시 풀어 볼 예정</del></p>
<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>TOY 34. LCS</li>
</ul>
:ET