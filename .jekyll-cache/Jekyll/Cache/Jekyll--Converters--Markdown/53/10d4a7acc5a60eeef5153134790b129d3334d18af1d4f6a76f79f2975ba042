I"Z-<p><img src="https://user-images.githubusercontent.com/83164003/127775612-7464075f-89e7-478e-82ee-dc1c2710a125.jpeg" alt="TIL" /></p>
<h2 id="today-i-learnd">Today I Learnd</h2>
<h3 id="1-자료구조란">1. 자료구조란?</h3>
<ul>
  <li>자료구조란 여러 데이터들의 묶음을 저장하고, 사용하는 방법을 정의한 것.  데이터에 편리하게 접근하고 변경하기 위해 데이터를 저장하거나 조직을 효율적으로 해야한다. 그러한 행위로 분류된 데이터를 자료구조라 한다. <del>( + 알고리즘은 그 저장된 데이터를 처리하는 과정이다.)</del></li>
</ul>

<h3 id="2-자료구조의-종류">2. 자료구조의 종류</h3>
<h4 id="2-1-stack">2-1. Stack</h4>
<ul>
  <li>스택(Stack)은 쌓다, 쌓이다, 포개지다란 뜻을 내포한다. 직역 그대로 <strong>데이터(data)를 순차적으로 쌓는 구조</strong>이다.</li>
  <li>순차적으로 쌓다보니, 가장 먼저 들어간 자료는 가장 나중에 나올 수 있다. 입력과 출력이 하나의 방향으로 이루어지는 제한적 접근에 있다.</li>
  <li>
    <p>이러한 자료구조의 정책을 <strong>LIFO(Last In First Out) 혹은 FILO(First In Last Out)</strong> 이라 일컫는다</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/130885861-3ad5f731-7487-42c4-a027-ef7b4219e0e4.png" alt="stack" /></p>

    <p>위 사진 처럼 push(), pop()을 쓰는 배열이 대표적인 <code class="language-plaintext highlighter-rouge">Stack</code> 자료구조이다.</p>
  </li>
  <li>대표적으로 활용되는 예시는 브라우저의 뒤로 가기, 앞으로 가기 기능 &amp; 엑셀 등 문서작업에서 되돌리기 등의 기능을 구현 할 때 자료구조 <code class="language-plaintext highlighter-rouge">Stack</code>의 활용이 필요하다.</li>
</ul>

<h4 id="2-2-queue">2-2. Queue</h4>
<ul>
  <li>
    <p>큐(Queue)는 줄을 서서 기다리다, 대기 행렬 이라는 뜻을 내포한다. <code class="language-plaintext highlighter-rouge">Stack</code>과는 반대되는 개념으로, 먼저 들어간 데이터가 먼저 처리되는 <strong>FIFO(First In First Out) 혹은 LILO(Last In Last Out)</strong> 을 특징으로 가지고 있는다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/130886677-ceb7346b-9da1-4dae-854b-58bdf80624f4.png" alt="queue" /></p>

    <p>위 사진 처럼 자료구조 <code class="language-plaintext highlighter-rouge">Queue</code>는 데이터가 입력된 순서대로 처리할 때 주로 사용한다.</p>
  </li>
  <li>
    <p>대표적으로 활용되는 예시는 프린터가 출력되는 인쇄작업 Queue에 사용된다. 자료구조 <code class="language-plaintext highlighter-rouge">Queue</code>를 활용함으로써 프린터는 인쇄작업 Queue에 들어온 문서를 순서대로 인쇄할수있다.</p>

    <p>혹은 컴퓨터 장치들 사이에서 데이터를 주고 받을 때, 각 장치 사이에 존재하는 <strong>속도의 차이</strong>나 <strong>시간 차이</strong>를 극복하기 위해 임시 기억 장치의 자료구조로 <code class="language-plaintext highlighter-rouge">Queue</code>를 사용한다. 이를 <strong>버퍼(buffer)</strong> 라 일컫는다.</p>
  </li>
</ul>

<h4 id="2-3-graph">2-3. Graph</h4>
<ul>
  <li>그래프는 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조이다. 직접적인 관계가 있는 경우 두 점 사이를 이어주는 선이 있겠으며, 간접적인 관계라면 몇 개의 점과 선에 걸쳐 이어진다.</li>
  <li>
    <p>그래프에서 하나의 점을 정점(vertex)이라고 표현하고, 하나의 선은 간선(edge) 이라고 한다.</p>

    <p><img width="650" alt="graph" src="https://user-images.githubusercontent.com/83164003/130889135-35c41544-836e-412b-bdbf-83aca057d872.png" /></p>

    <p>정점과 정점사이에 간선이 존재하는데, 이 간선은 정점 사이의 관계를 나타낸다. 정점 사이에 직접적, 간적적으로 간선이 없는 경우를 그래프에선 “관계가 없다” 라고 표현한다.</p>
  </li>
  <li>
    <p>일상생활에선 매일같이 자료구조 그래프를 사용하고 있다. 포털 사이트의 검색 엔진, SNS,  네비게이션(길찾기) 등 에서 사용되는 자료구조이다.</p>

    <p>간단한 예를 들자면,</p>
    <blockquote>
      <p>서울에 사는 A는 부산에 사는 B와 오랜 친구 사이입니다. 이번 주말에 부산에서 열리는 B의 결혼식에 참석하기 위해 A는 차를 몰고 부산으로 가려고 합니다. 대전에 살고 있는 친구 C도 B의 결혼식에 참석을 한다고 하여, A는 서울에서 출발하여 대전에서 C를 태워 부산으로 이동을 하려고 합니다.</p>
    </blockquote>

    <p>위 예시에서는 3개의 정점이 존재한다(A,B,C). 각각 서울,부산,대전을 그래프의 정점으로 삼는다면, 이 3개의 정점은 서로 이어지는 간선(관계)를 가지고 있다.</p>

    <blockquote>
      <p>정점 : 서울(A), 대전(B), 부산(C)</p>

      <p>간선 : 서울-대전, 대전-부산, 부산-서울</p>
    </blockquote>

    <p>이를 간단한 JS 객체를 이용하여 비유한다면 아래와 같다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">isConnected</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">seoul</span> <span class="p">:</span> <span class="p">{</span>
    <span class="na">busan</span> <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">daejeon</span> <span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
  <span class="nl">daejeon</span> <span class="p">:</span> <span class="p">{</span>
    <span class="na">seoul</span> <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">busan</span> <span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
  <span class="nl">busan</span> <span class="p">:</span> <span class="p">{</span>
    <span class="na">seoul</span> <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">daejeon</span> <span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">isConnected</span><span class="p">.</span><span class="nx">seoul</span><span class="p">.</span><span class="nx">busan</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <p>현재는 특정 도시가 이어져 있다는 무향그래프라는 노드3개와 간선 3개라는 사실만 알려줄 뿐, 그 외의 정보를 포함하고 있진 않다. 이러한 그래프를 <strong>비가중치 그래프</strong>라 한다.</p>
  </li>
  <li>그래프를 학습하기에있어, 알아둬야 할 용어들이 있다. 간단하게 살펴보면,
    <ol>
      <li><strong>무(방)향그래프(underected graph)</strong> : 네비게이션(길찾기)에서 보이는 그래프들은 무향 그래프이다. 서울에서 부산을 갈 수 있듯, 반대로 부산에서 서울로 올 수도 있다. 반대 개념인 <strong>단방향 그래프(directed graph)</strong> 로 구현 된다면,  한쪽 방향으로만 가능할 것이다. 예를 들면 도로의 일방통행은 단방향 그래프로 길찾기를 구현 할 수 있다.</li>
      <li><strong>진입차수(in-degree) / 진출차수(out-degree)</strong>: 한 정점에 진입(들어오는 간선)하고 진출(나가는 간선)하는 간선이 몇 개인지 나타내는 용어이다.</li>
      <li><strong>인접(adjacency)</strong>: 두 정점간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점이다.</li>
      <li><strong>자기 루프(self loop)</strong>: 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 자기 루프를 가졌다 라고 표현하며, 다른 정점을 거치지 않는다는 것이 특징이다.</li>
      <li><strong>사이클(cycle)</strong>: 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 사이클이 있다고 표현한다.</li>
    </ol>
  </li>
  <li>
    <p><strong>인접</strong>은 위에서 말했듯이 직접 이어져 있는 정점의 관계를 나타낸다. 표현 방식을 수식화 할 땐 아래와 같은 방법으로 표현한다.</p>

    <ol>
      <li>인접 행렬 (adjacency matrix) : 그래프에서 정점(vertext)들이 어떻게 연결되었는지 나타내는 행렬이다.
        <ul>
          <li>2차원 배열로 작성하게 되며, 정점들 사이에 간선이 존재하는지 여부를 나타내거나, 가중치가 있는 그래프인 경우에는 정점관의 관계에서 의미 있는 값을 저장한다.</li>
        </ul>

        <p><img src="https://user-images.githubusercontent.com/83164003/130991111-43c899d0-f7df-498d-9156-188680d98df5.png" alt="인접행렬" />
     <a href="http://stoimen.com/2012/08/31/computer-algorithms-graphs-and-their-representation/" target="_blank">참조 : http://stoimen.com </a></p>
      </li>
      <li>인접 리스트 (adjacency list) : 각 정점이 어떤 정점과 인접한지를 리스트의 형태로 표현한다. 각 정점마다 하나의 리스트를 가지고 있으며, 이 리스트는 자신과 인접한 다른 정점을 담는다.
        <ul>
          <li>
            <p>인접 행렬은 연결 가능한 모든 경우의 수를 저장하기 때문에 상대적으로 메모리를 많이 차지하므로 메모리의 효율성을 위한 작업이 필요할땐 인접리스트가 효율적이다.</p>

            <p><img src="https://user-images.githubusercontent.com/83164003/130992153-24b024de-ab1a-4825-ac85-2edb4827ea9d.png" alt="인접리스트" /></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h4 id="2-4-tree">2-4. Tree</h4>
<ul>
  <li>
    <p>자료구조 <code class="language-plaintext highlighter-rouge">Tree</code>는 이름 그대로 나무의 형태를 가지고 있다. 엄밀히 말하면 그래프의 여러 구조중 무방향 그래프의 한 구조라 말할수있다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/130994663-d4c060c6-b6b0-4fbc-9568-a6ad0ae51ad7.png" alt="tree" /></p>

    <p>트리 구조는 데이터가 바로 아래에 있는 하나 이상의 데이터에 무방향으로 연결된 계층적 자료구조이다. 데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 뒤에 여러 개의 데이터가 존재할 수 있는 비선형 구조이다. 트리 구조는 <strong>계층</strong>적으로 표현이 되고, 아래로만 뻗어나가기 때문에 그래프와 달리 사이클은 존재하지 않는다.</p>
  </li>
  <li>
    <p>트리를 학습하기에있어, 알아둬야 할 용어들이 있다. 간단하게 살펴보면,</p>
    <ol>
      <li><strong>노드(Node)</strong> : 트리 구조를 이루는 모든 개별 데이터</li>
      <li><strong>루트(Root)</strong> : 트리 구조의 시작점이 되는 노드</li>
    </ol>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="오늘-느낀-점">오늘 느낀 점</h2>

<p><br />
<br /></p>

<h2 id="내일-할-일">내일 할 일</h2>
<p>-</p>
:ET