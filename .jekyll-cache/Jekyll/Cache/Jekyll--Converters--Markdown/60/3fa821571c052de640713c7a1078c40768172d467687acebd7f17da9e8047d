I"3<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="algorithm" /></p>
<h2 id="toy-12-treebfs">TOY 12. treeBFS</h2>
<h3 id="문제">문제</h3>
<hr />
<p>임의의 tree를 구성하는 노드 중 하나의 <code class="highlighter-rouge">Node</code> 객체를 입력받아, 해당 노드를 시작으로 너비 우선 탐색(BFS, Breadth First Search)을 합니다. 이 때, 탐색되는 순서대로 노드의 값이 저장된 배열을 리턴해야 합니다.</p>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1--node">인자 1 : node</h4>
<ul>
  <li><code class="highlighter-rouge">'value'</code>, <code class="highlighter-rouge">'children'</code> 속성을 갖는 객체 (Node)</li>
  <li><code class="highlighter-rouge">'node.value'</code>는 <code class="highlighter-rouge">number</code> 타입</li>
  <li><code class="highlighter-rouge">'node.children'</code>은 Node를 요소로 갖는 배열</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li>배열을 리턴해야 합니다.</li>
</ul>

<h3 id="주의사항">주의사항</h3>
<hr />
<ul>
  <li>생성자 함수(<code class="highlighter-rouge">Node</code>)와 메소드(<code class="highlighter-rouge">addChild</code>)는 변경하지 않아야 합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">rootChild1</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="kd">let</span> <span class="nx">rootChild2</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="kd">let</span> <span class="nx">leaf1</span> <span class="o">=</span> <span class="nx">rootChild1</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="kd">let</span> <span class="nx">leaf2</span> <span class="o">=</span> <span class="nx">rootChild1</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">bfs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; [1, 2, 3, 4, 5]</span>

<span class="nx">leaf1</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
<span class="nx">rootChild2</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
<span class="nx">output</span> <span class="o">=</span> <span class="nx">bfs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; [1, 2, 3, 4, 5, 7, 6]</span>
</code></pre></div></div>

<h2 id="toy-12-solution">TOY 12. Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />
<p><img src="https://user-images.githubusercontent.com/83164003/132495634-dedf3161-f8d5-4263-a180-894f4f384dc5.png" alt="BFS" /></p>

<ul>
  <li>
    <p>Queue를 사용, 선입 선출이다.</p>

    <ol>
      <li>인큐 : 루트 노드 (초기값 할당)</li>
      <li>디큐 값을 결과값 배열에 <code class="highlighter-rouge">push</code></li>
      <li>인큐 : 루트 노드의 자식 배열들을 반복문을 수행하며 인큐</li>
      <li>디큐 값을 결과값 배열에 <code class="highlighter-rouge">push</code></li>
      <li>큐가 비워질때 까지 ….반복</li>
    </ol>
  </li>
</ul>

<h3 id="문제풀이">문제풀이</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">bfs</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO: 여기에 코드를 작성합니다.</span>
  <span class="kd">let</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">node</span><span class="p">];</span> <span class="c1">// 초기 root 노드 할당</span>
  <span class="kd">let</span> <span class="nx">values</span> <span class="o">=</span> <span class="p">[];</span>  <span class="c1">// 결과값 배열</span>
  
  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 큐가 비워질때까지 반복</span>
    <span class="kd">let</span> <span class="nx">head</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// head는 values로 비워지기전 queue의 정보를 담고있는 변수이다.</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="c1">// = slice(1) 선입선출, shift로 queue[0] 삭제</span>
    <span class="nx">values</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 결과값 배열에 head의 값 push</span>
    
    <span class="nx">head</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">child</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">));</span> <span class="c1">// queue에 head의 children 배열을 넣어준다</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="nx">values</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 이 아래 코드는 변경하지 않아도 됩니다. 자유롭게 참고하세요.</span>
<span class="kd">let</span> <span class="nx">Node</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">};</span>

<span class="c1">// 위 Node 객체로 구성되는 트리는 매우 단순한 형태의 트리입니다.</span>
<span class="c1">// membership check(중복 확인)를 따로 하지 않습니다.</span>
<span class="nx">Node</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addChild</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">child</span><span class="p">;</span>
<span class="p">};</span>

</code></pre></div></div>
<h3 id="reference-code">Reference Code</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">bfs</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO: 여기에 코드를 작성합니다.</span>
  <span class="kd">let</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">node</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">values</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="nx">queue</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="nx">values</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>

    <span class="nx">head</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">child</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">values</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 이 아래 코드는 변경하지 않아도 됩니다. 자유롭게 참고하세요.</span>
<span class="kd">let</span> <span class="nx">Node</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">};</span>

<span class="c1">// 위 Node 객체로 구성되는 트리는 매우 단순한 형태의 트리입니다.</span>
<span class="c1">// membership check(중복 확인)를 따로 하지 않습니다.</span>
<span class="nx">Node</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addChild</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">child</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<h2 id="오늘-느낀-점">오늘 느낀 점</h2>
<ul>
  <li>큐의 자료구조를 이용하리라는 생각은 안해보아서, 레퍼런스 코드를 참조하였다.</li>
  <li>BFS 가 어떻게 순회되는지 개념은 확실히 알 수 있었던 알고리즘이다.</li>
</ul>

<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>TOY 13. insertionSort</li>
</ul>
:ET