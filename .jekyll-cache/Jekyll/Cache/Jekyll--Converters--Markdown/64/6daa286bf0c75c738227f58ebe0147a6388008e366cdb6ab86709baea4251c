I".!<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="Algorithm" /></p>
<h2 id="가위바위보-중복순열">가위바위보 (중복순열)</h2>
<h3 id="문제">문제</h3>
<hr />
<p>가위바위보 게임은 2인 이상의 사람이 동시에 ‘가위, 바위, 보’를 외치고 동시에 가위, 바위 또는 보 중에서 한 가지를 의미하는 손 모양을 내밀어 승부를 결정짓는 게임입니다. 세 판의 가위바위보 게임을 할 경우, 한 사람은 세 번의 선택(예. 가위, 가위, 보)을 할 수 있습니다. 세 번의 선택으로 가능한 모든 경우의 수를 구하는 함수를 작성합니다.</p>

<h3 id="입력">입력</h3>
<hr />
<ul>
  <li>없음</li>
</ul>

<h3 id="주의사항">주의사항</h3>
<hr />
<ul>
  <li>모든 화폐는 무한하게 있다고 가정합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">ocean</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// 4</span>

<span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">ocean</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// 10</span>

<span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">ocean</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// 4</span>
</code></pre></div></div>

<h3 id="hint">Hint!</h3>
<hr />
<p>해당 문제는 <code class="language-plaintext highlighter-rouge">냅색 알고리즘(Knapsack Problem)</code>을 활용하여 풀 수 있습니다.
검색해 보시고, 연구해 보세요!</p>

<h2 id="solution">Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />

<p>정말 문제를 받자마자 도저히 감이 잡히질 않았다.. <del>기수이동 전에는 Advanced라고 풀어보지도 않았다…</del></p>

<p><strong>Reference Code</strong>를 참조하였다.</p>

<h3 id="문제풀이">문제풀이</h3>
<hr />

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
<hr />

<p><strong>Reference Code</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">ocean</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// bag 이라는 배열에 금액을 만들 수 있는 경우의 수를 기록</span>
  <span class="c1">// 각 인덱스 no# = 만드려는 금액 을 의미</span>
  <span class="c1">// ex) target = 5, type = [1, 2, 5] 면</span>
  <span class="c1">// bag[3] = 2  =&gt; 3을 만드는 경우의 수 = 1만 사용 &amp; 1,2 함께 사용</span>
  <span class="c1">// bag[4] = 2  =&gt; 4를 만드는 경우의 수 = 1만 사용 &amp; 1,2 함께 사용</span>
  <span class="c1">// bag[5] = 4  =&gt; 5를 만드는 경우의 수 = 1*5 , 1*3 + 2, 1 + 2*2, 5*1</span>
  <span class="c1">// 0 을 만들 수 있는 경우는 아무것도 선택하지 않으면 되기 때문에 bag[0] = 1 로 초기값 설정</span>
  <span class="kd">let</span> <span class="nx">bag</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="c1">// 인덱스 no# = 만드려는 금액 이기 때문에</span>
  <span class="c1">// bag 을 target 금액만큼의 길이를 가진 배열을 만들어 주고,</span>
  <span class="c1">// 경우의 수를 저장하기 위해 초기값은 모두 0으로 만들어 준다</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
    <span class="nx">bag</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 돈의 종류가 담겨있는 배열을 순차적으로 탐색   </span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">type</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// target 금액까지 순차적으로 1씩 증가하면서    </span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">target</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
  <span class="c1">// bag의 인덱스가 type[i] 보다 큰 구간만</span>
  <span class="c1">// (작은 구간은 type[i]로 만들 수 없는 금액이기 때문에 탐색할 필요가 없다)    </span>
      <span class="k">if</span><span class="p">(</span><span class="nx">type</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">j</span><span class="p">)</span>
  <span class="c1">// 기존 경우의 수에 type[i]를 뺀 금액을 만들 수 있는 경우의 수를 더해준다       </span>
        <span class="nx">bag</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">bag</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">type</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
  <span class="p">}</span>
  <span class="c1">// bag 의 target 인덱스에 target 금액을 훔칠 수 있는 경우의 수가 쌓이므로</span>
  <span class="c1">// 해당 값을 리턴해 준다</span>

  <span class="k">return</span> <span class="nx">bag</span><span class="p">[</span><span class="nx">target</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="느낀-점">느낀 점</h2>

<p><strong>Reference Code</strong>를 보아도 이해 할 수 없어서, 계속 디버깅을 돌려보며 이해하려 노력해보았다.</p>

<p>디버깅을 돌려가니 눈으로 로직이 보이긴한다.. 결론만 말하자면 <code class="language-plaintext highlighter-rouge">bag</code> 배열의 인덱스에는 <code class="language-plaintext highlighter-rouge">target</code> 금액을 훔칠 수 있는 경우의 수가 쌓이는 구조이다. (Dynamic Programmin)</p>

<p>다시 풀으라해도 솔직히 풀어낼 자신이 없는 문제다.</p>
:ET