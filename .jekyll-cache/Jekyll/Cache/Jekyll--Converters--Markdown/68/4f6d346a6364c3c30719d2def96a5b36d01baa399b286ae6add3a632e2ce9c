I"1<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="Algorithm" /></p>
<h2 id="집밥이-그리워">집밥이 그리워</h2>
<h3 id="문제">문제</h3>
<hr />
<p>김코딩은 몇 년의 해외 출장 끝에 본가에 내려왔습니다. 오랜만에 보는 김코딩의 얼굴에 반가웠던 부모님은 상다리가 부러질 정도로 음식을 만들었습니다. 감동의 재회도 잠시, 의자에 앉아 식사를 하려던 김코딩은 무엇부터 먹어야 될지 깊은 생각에 빠졌습니다. 정성스럽게 차려 주신 만큼, 최대한 많은 방법으로 다양하게 먹고 싶었기 때문입니다.</p>

<p>밥은 한 가지이며 반찬은 다수일 때, 밥과 함께 먹을 수 있는 반찬의 모든 경우의 수를 배열에 담아 리턴하세요.</p>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1-sidedishes">인자 1: sideDishes</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">String</code> 타입의 영문으로 된 반찬이 나열되어 있는 배열</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">Array</code> 타입을 리턴해야 합니다.</li>
  <li>밥과 함께 먹을 수 있는 반찬의 모든 경우의 수가 담긴 배열</li>
</ul>

<h3 id="출력-1">출력</h3>
<hr />

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">M</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">N</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">divideChocolateStick</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span>
<span class="c1">// [[1, 4, 8], [2, 2, 4], [4, 1, 2]]</span>
</code></pre></div></div>

<h2 id="solution">Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />

<ol>
  <li>공약수들을 구해서 배열에 담는다.</li>
  <li>공약수 배열을 순회 하며 <code class="language-plaintext highlighter-rouge">[인원수, 아몬드 빼뺴로/인원수, 누드 빼뺴로/인원수]</code> 배열을 결과값 배열에 담아 리턴한다.</li>
</ol>

<p>공약수는 M과 N을 각각 나누어서 나머지가 0인 수들이므로, 둘중 작은 숫자를 1부터 나눠보며 찾을 수 있다.</p>

<h3 id="문제풀이">문제풀이</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">divideChocolateStick</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">divisor</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span><span class="nx">N</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 공약수는 둘중 작은 숫자를 찾아</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">M</span><span class="o">%</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">N</span><span class="o">%</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">// 둘다 나머지가 0으로 나눠떨어지는 숫자들이다</span>
      <span class="nx">divisor</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>  <span class="c1">// 공약수 배열에 담는다.</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">div</span> <span class="k">of</span> <span class="nx">divisor</span><span class="p">){</span>  <span class="c1">// 공약수 배열을 순회하며</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">div</span><span class="p">,</span> <span class="nx">M</span><span class="o">/</span><span class="nx">div</span><span class="p">,</span> <span class="nx">N</span><span class="o">/</span><span class="nx">div</span><span class="p">]);</span>  <span class="c1">// 양식에 맞게 결과값 배열에 넣어준다</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<hr />

<p><strong>Reference Code</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최대 공약수(유클리드 호제법: Euclidean algorithm)</span>
<span class="kd">function</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">divideChocolateStick</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 최대공약수를 구한다.</span>
  <span class="c1">// M, N의 순서는 상관없다.</span>
  <span class="kd">const</span> <span class="nx">GCD</span> <span class="o">=</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//</span>

  <span class="c1">// 약수는 대칭적이므로 제곱근까지만 반복해도 된다.</span>
  <span class="c1">// 예) 36의 약수는 1, 2, 3, 4, 6, 9, 12, 18, 36이다.</span>
  <span class="c1">// 제곱근을 기준으로 양쪽의 값 하나씩 곱했을 때 36이 되기 때문에</span>
  <span class="c1">// 제곱근 보다 큰 약수는 제곱근보다 작은 약수에서 구할 수 있다.</span>
  <span class="kd">const</span> <span class="nx">sqrt</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">GCD</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">sqrt</span><span class="p">;</span> <span class="nx">left</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">GCD</span> <span class="o">%</span> <span class="nx">left</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 최대공약수의 약수인 경우 중 제곱근 보다 작은 약수의 경우</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">left</span><span class="p">,</span> <span class="nx">M</span> <span class="o">/</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">N</span> <span class="o">/</span> <span class="nx">left</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">*</span> <span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">GCD</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 제곱근이 아닌 경우(제곱근 보다 작은)</span>
        <span class="nx">right</span> <span class="o">=</span> <span class="nx">GCD</span> <span class="o">/</span> <span class="nx">left</span><span class="p">;</span> <span class="c1">// 최대 공약수를 제곱근이 아닌 수로 나누면 제곱근 보다 큰 약수를 구할 수 있다.</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">right</span><span class="p">,</span> <span class="nx">M</span> <span class="o">/</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">N</span> <span class="o">/</span> <span class="nx">right</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// '빼빼로를 받게 되는 직원의 수'를 기준으로 오름차순으로 정렬</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">op1</span><span class="p">,</span> <span class="nx">op2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="느낀-점">느낀 점</h2>

<p>시간복잡도 문제인지 TEST CASE 1개를 통과하지 못하였다.</p>

<p><strong>Reference Code</strong>를 참조해보니 모든 약수를 체크하지 않고 제곱근까지 접근하는 로직으로 구현한걸 보았다. <del>귀찮아서 내 코드를 고치진 않았다…</del></p>

<p>최대 공약수를 구하는 알고리즘이 인상 깊었다. 자주 쓰이진 않겠지만 이렇게 구현이 된다는 것 자체가 신기하다…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최대공약수(유클리드 호제법: Euclidean algorithm)</span>
<span class="kd">function</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
:ET