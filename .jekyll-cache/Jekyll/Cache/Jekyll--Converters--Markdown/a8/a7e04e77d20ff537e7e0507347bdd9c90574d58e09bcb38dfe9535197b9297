I"L5<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="algorithm" /></p>
<h2 id="toy-34-lis">TOY 34. LIS</h2>
<h3 id="문제">문제</h3>
<hr />
<p>두 문자열을 입력받아 다음의 조건을 만족하는 <em>LCS</em> 의 길이를 리턴해야 합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LCS</code>: 두 문자열에 공통으로 존재하는 연속되지 않는 부분 문자열(Longest Common Subsequence)</li>
  <li>문자열 <code class="language-plaintext highlighter-rouge">'abc'</code>의 subseqeunce는 <code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'b'</code>, <code class="language-plaintext highlighter-rouge">'c'</code>, <code class="language-plaintext highlighter-rouge">'ab'</code>, <code class="language-plaintext highlighter-rouge">'ac'</code>, <code class="language-plaintext highlighter-rouge">'bc'</code>, <code class="language-plaintext highlighter-rouge">'abc'</code> 입니다.</li>
</ul>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1--str1">인자 1 : str1</h4>
<ul>
  <li>string 타입의 알파벳 소문자와 숫자로 이루어진 문자열</li>
  <li><code class="language-plaintext highlighter-rouge">arr.length</code>는 60,000 이하</li>
  <li><code class="language-plaintext highlighter-rouge">arr[i]</code>는 100,000 이하의 양의 정수</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입을 리턴해야 합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">LIS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 1 (3 or 2)</span>

<span class="nx">output</span> <span class="o">=</span> <span class="nx">LIS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 3 (3, 10, 20)</span>
</code></pre></div></div>

<h3 id="advanced">Advanced</h3>
<hr />
<ul>
  <li>LIS를 계산하는 효율적인 알고리즘(<code class="language-plaintext highlighter-rouge">O(N^2)</code>)이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.</li>
  <li>subsequence는 문자열 또는 배열같이 순서가 있는 데이터에서 순서의 대소 관계가 유지되는 모든 부분 문자열 또는 부분 배열을 의미합니다. sequence가 순서 또는 서열을 의미하기 때문에 subsequence는 부분 서열이라고 부르기도 합니다. 반면 substring 또는 subarray는 연속된 형태의 부분 문자열 또는 부분 배열을 의미합니다. 문자열 <code class="language-plaintext highlighter-rouge">'abcd'</code>의 subsequence와 substring은 각각 아래와 같습니다.
    <ul>
      <li>substring: <code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'b'</code>, <code class="language-plaintext highlighter-rouge">'c'</code>, <code class="language-plaintext highlighter-rouge">'d'</code>, <code class="language-plaintext highlighter-rouge">'ab'</code>, <code class="language-plaintext highlighter-rouge">'bc'</code>, <code class="language-plaintext highlighter-rouge">'cd'</code>, <code class="language-plaintext highlighter-rouge">'abc'</code>, <code class="language-plaintext highlighter-rouge">'bcd'</code>, <code class="language-plaintext highlighter-rouge">'abcd'</code></li>
      <li>subsequence: <code class="language-plaintext highlighter-rouge">'a'</code>, <code class="language-plaintext highlighter-rouge">'b'</code>, <code class="language-plaintext highlighter-rouge">'c'</code>, <code class="language-plaintext highlighter-rouge">'d'</code>, <code class="language-plaintext highlighter-rouge">'ab'</code>, <code class="language-plaintext highlighter-rouge">'ac'</code>, <code class="language-plaintext highlighter-rouge">'ad'</code>, <code class="language-plaintext highlighter-rouge">'bc'</code>, <code class="language-plaintext highlighter-rouge">'bd'</code>, <code class="language-plaintext highlighter-rouge">'cd'</code>, <code class="language-plaintext highlighter-rouge">'abc'</code>, <code class="language-plaintext highlighter-rouge">'abd'</code>, <code class="language-plaintext highlighter-rouge">'acd'</code>, <code class="language-plaintext highlighter-rouge">'bcd'</code>, <code class="language-plaintext highlighter-rouge">'abcd'</code></li>
      <li>LIS의 길이 대신 LIS 자체를 리턴하는 함수를 구현해 보시기 바랍니다.</li>
    </ul>
  </li>
</ul>

<h2 id="toy-33-solution">TOY 33. Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />
<p><del>문제도 잘 이해 못하겠다..</del></p>

<h3 id="문제풀이">문제풀이</h3>
<hr />

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
<hr />

<p><strong>Reference Code</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// naive solution: O(2^N)</span>
<span class="c1">// 배열의 각 요소에 대해서 선택, 무시의 2가지 선택이 가능</span>
<span class="c1">// const LIS = function (arr) {</span>
<span class="c1">//   // 현재 검토할 차례인 배열의 '인덱스'와</span>
<span class="c1">//   // 이전에 선택된 요소의 '값'을 인자로 전달한다.</span>
<span class="c1">//   const pickOrNot = (idx, before) =&gt; {</span>
<span class="c1">//     // base case</span>
<span class="c1">//     // 가장 짧은 LIS의 길이는 1이다. 모든 요소는 그 자체로 길이 1인 부분 서열이다.</span>
<span class="c1">//     if (idx === arr.length) return 1;</span>

<span class="c1">//     // recursive case</span>
<span class="c1">//     // (초기값인 Number.MAX_SAFE_INTEGER를 포함해) 이전에 선택된 요소와 비교를 한다.</span>
<span class="c1">//     const adder = arr[idx] &gt; before ? 1 : 0;</span>
<span class="c1">//     return Math.max(</span>
<span class="c1">//       // 1) 현재 요소를 선택한다.</span>
<span class="c1">//       //  1-1) adder === 1: 현재 요소를 이전에 선택된 요소 뒤에 이어지는 요소로 생각해 LIS의 길이에 1을 더한다.</span>
<span class="c1">//       //  1-2) adder === 0: 현재 요소를 이어지는 요소로 생각할 수 없는 경우. 이전 요소를 건너뛰고 LIS의 처음 또는 중간 요소로 현재 요소를 선택한다.</span>
<span class="c1">//       adder + pickOrNot(idx + 1, arr[idx]), // concat or restart</span>
<span class="c1">//       // 2) 현재 요소를 무시한다.</span>
<span class="c1">//       pickOrNot(idx + 1, before) // ignore</span>
<span class="c1">//     );</span>
<span class="c1">//   };</span>
<span class="c1">//   // 첫 번째 요소의 이전 요소는 없기 때문에 매우 큰 값을 이전 값으로 설정한다.</span>
<span class="c1">//   // 첫 번째 요소부터 시작하는 LIS를 검사하는 효과를 갖는다.</span>
<span class="c1">//   return pickOrNot(0, Number.MAX_SAFE_INTEGER);</span>
<span class="c1">// };</span>

<span class="c1">// dynamic programming with memoization: O(N^2)</span>
<span class="c1">// const LIS = function (arr) {</span>
<span class="c1">//   // memo[i]는 i부터 시작하는 LIS의 길이를 저장</span>
<span class="c1">//   const memo = Array(arr.length).fill(-1);</span>
<span class="c1">//   // 마지막 요소부터 시작하는 LIS는 1이 유일하다.</span>
<span class="c1">//   memo[memo.length - 1] = 1;</span>
<span class="c1">//   const calculateLIS = (idx) =&gt; {</span>
<span class="c1">//     if (memo[idx] !== -1) return memo[idx];</span>

<span class="c1">//     let max = 1;</span>
<span class="c1">//     for (let i = idx + 1; i &lt; arr.length; i++) {</span>
<span class="c1">//       const len = calculateLIS(i);</span>
<span class="c1">//       // idx와 i가 연결되지 않을 수도 있다.</span>
<span class="c1">//       if (arr[idx] &lt; arr[i]) {</span>
<span class="c1">//         // i부터 시작하는 LIS를 연결할 수 있는 경우</span>
<span class="c1">//         max = Math.max(max, len + 1);</span>
<span class="c1">//       }</span>
<span class="c1">//       // i부터 시작하는 LIS가 더 길 수도 있다.</span>
<span class="c1">//       // idx부터 시작하는 LIS를 구해야 하므로, 무시한다.</span>
<span class="c1">//     }</span>
<span class="c1">//     memo[idx] = max;</span>
<span class="c1">//     return memo[idx];</span>
<span class="c1">//   };</span>
<span class="c1">//   calculateLIS(0);</span>
<span class="c1">//   // 가장 긴 길이를 구한다.</span>
<span class="c1">//   return Math.max(...memo);</span>
<span class="c1">// };</span>

<span class="c1">// dynamic programming with tabulation: O(N^2)</span>
<span class="kd">const</span> <span class="nx">LIS</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="c1">// lis[i]는 i에서 끝나는 LIS의 길이를 저장</span>
  <span class="c1">// 최소한 각 요소 하나로 LIS를 만들 수 있으므로 1로 초기화한다.</span>
  <span class="kd">const</span> <span class="nx">lis</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">N</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// i에서 끝나는 LIS의 길이</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// i 이전의 인덱스만 검사하면 된다.</span>
      <span class="c1">// i는 1부터 시작하므로, 짧은 길이부터 검사한다. (bottom-up 방식)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">lis</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">lis</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">lis</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">lis</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">lis</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="오늘-느낀-점">오늘 느낀 점</h2>
<p><del>문제에서 레퍼런스코드를 보라한다…</del> 갈수록 알고리즘 난이도가 너무 높다.</p>

<p>2주 세미 프로젝트 진행과 맞물려서 HA3 준비, 그리고 매일 진행되는 알고리즘까지 너무 시간이 모자르다. <del>커리큘럼이 너무 알고리즘에 매달리는 느낌을 지울수가 없다</del></p>

<p>우선은 <strong>Reference Code</strong>를 보고 이해하는 수준에서 마무리하였다.  <del>다시 풀어 볼 예정</del></p>

<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>TOY 34. LCS</li>
</ul>
:ET