I""<p><img src="https://user-images.githubusercontent.com/83164003/157039191-32141e02-51fe-4d34-abeb-02bb8f897dde.jpeg" alt="TIL" /></p>
<h2 id="today-i-learnd">Today I Learnd</h2>
<p>인프런의 <a href="https://www.inflearn.com/course/%EB%94%B0%EB%9D%BC%ED%95%98%EB%8A%94-%EB%84%A4%EC%8A%A4%ED%8A%B8-%EC%A0%9C%EC%9D%B4%EC%97%90%EC%8A%A4" target="_blank">따라하며 배우는 NestJS</a>를 들으며 배운점을 남기고 있다.</p>

<p>일전의 <a href="https://jh8459.github.io/til/22.04.13.til/" target="_blank">#1</a> <a href="https://jh8459.github.io/til/22.04.14.til/" target="_blank">#2</a> <a href="https://jh8459.github.io/til/22.04.15.til/" target="_blank">#3</a>에서 기초 개념을 학습을 진행했으며 그를 토대로 기본적인 CRUD를 위한 실습또한 함께 진행중이다.</p>

<p>오늘은 기존 실습한 내용을 주석을 달아가며 복습하였다.<br /> 
해당 코드 내용은 아래에 첨부한다.</p>

<blockquote>
  <p><a href="https://github.com/JH8459/NestJS-BoardApp/commit/c6390d62e699cdecc62ad125ab580db33fdfd31e" target="_blank">Board Model 정의하기</a></p>

  <p><a href="https://github.com/JH8459/NestJS-BoardApp/commit/3761bb7f6794f7a896142cbf656b8d95f07665b9" target="_blank">게시물 생성하기</a></p>
</blockquote>

<p>DTO에 대한 내용을 학습한 내용을 간단히 정리하였다.
<br />
<br /></p>

<h3 id="1">1.</h3>
<hr />

<p>모듈은 @Module () 데코레이터(@)로 주석이 달린 클래스이다.<br />
@Module () 데코레이터는 Nest가 애플리케이션 구조를 구성하는데 사용하는 메타 데이터를 제공한다.</p>

<p>각 응용 프로그램에는 하나 이상의 모듈(최소 루트 모듈)이 있으며, 그 중 루트 모듈은 Nest가 사용하는 시작점이다.</p>

<center><img src="https://user-images.githubusercontent.com/83164003/163526133-269d66b5-2893-4ce3-b791-bb0248f1d930.png" /></center>
<p><br /></p>

<p>모듈은 밀접하게 관련된 기능 집합으로써 한 요소를 구성하기 위한 효과적인 방법이다. (기능별로 만든다.  ⇒ ex. 유저 모듈, 주문 모듈, 채팅 모듈 등등)</p>

<p>같은 기능에 해당하는 것들은 하나의 모듈 폴더안에 넣어서 사용한다. (ex. userController, userService, userEntity ⇒ 모두 같은 기능이기 때문에 userModule 안에 넣어 관리한다.)</p>

<p>모듈은 기본적으로 <strong>싱글 톤</strong> 패턴 이므로 여러 모듈간에 쉽게 공급자의 동일한 인스턴스를 공유 할 수 있다.</p>

<center><img src="https://user-images.githubusercontent.com/83164003/163527022-95b7fd3f-4b56-46f8-8363-ba5926a47677.png" /></center>

<blockquote>
  <p><strong>싱글 톤</strong> 패턴?</p>

  <p>객체의 인스턴스가 오직 1개만 생성되는 패턴을 의미한다.<br />
인스턴스가 오직 한 개로만 가져가므로 메모리 측면에서 유리하며 다른 클래스 간에 데이터 공유가 쉽다는 장점이 있다.</p>
</blockquote>

<p><br />
<br /></p>

<h3 id="2-nestjs-컨트롤러">2. NestJS 컨트롤러</h3>
<hr />

<p>컨트롤러는 클라이언트에서 서버로 들어오는 요청을 처리하고 클라이언트로 응답을 반환한다.</p>

<center><img src="https://user-images.githubusercontent.com/83164003/163531253-9608853a-8be1-41c8-a515-e9139974e523.png" /></center>
<p><br /></p>

<p>컨트롤러는 @Controller 데코레이터로 클래스를 데코레이션하여 정의된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Controller</span><span class="p">(</span><span class="dl">'</span><span class="s1">/boards</span><span class="dl">'</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">BoardsController</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<p>데코레이터는 인자를 Controller에 의해서 처리되는 “경로”로 받는다.</p>

<p><br />
<br /></p>

<h4 id="2-1-핸들러란">2-1. 핸들러란?</h4>
<hr />

<p>핸들러는 <code class="language-plaintext highlighter-rouge">@Get</code>, <code class="language-plaintext highlighter-rouge">@Post</code>, <code class="language-plaintext highlighter-rouge">@Delete</code> 등 데코레이터로 장식 된 컨트롤러 클래스 내의 단순한 메서드이다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Controller</span><span class="p">(</span><span class="dl">'</span><span class="s1">/boards</span><span class="dl">'</span><span class="p">)</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">BoardsController</span> <span class="p">{</span>
	<span class="p">@</span><span class="nd">Get</span><span class="p">()</span>
	<span class="nx">getBoards</span><span class="p">():</span> <span class="kr">string</span> <span class="p">{</span>
		<span class="k">return</span> <span class="dl">'</span><span class="s1">This action returns all boards</span><span class="dl">'</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>즉, 브라우저에서 들어온 요청은 컨트롤러에서 알맞은 요청 경로(엔드포인트)로 분기해주며 해당 분기로 들어온 요청에 알맞은 할 일(요청 메소드)은 핸들러에서 처리가 되는 구조이다.</p>

<p><br />
<br /></p>

<h3 id="3-nestjs-프로바이더란">3. NestJS 프로바이더란?</h3>
<hr />

<p>프로바이더는 NestJS의 기본 개념이다.<br />
대부분의 기본 NestJS 클래스는 서비스, 리포지토리, 팩토리, 헬퍼등 프로바이더로 취급될 수 있다.</p>

<p>프로바이더의 주요 아이디어는 종속성으로 주입할 수 있다는 것이다. 즉, 객체는 서로 다양한 관계를 만들수 있으며 객체의 인스턴스를 “연결”하는 기능은 대부분 Nest 런타임 시스템에 위임될 수 있다.</p>

<p>예를 들면 컨트롤러는 웹 브라우저에서 요청이 들어오면 무수히 많은 기능을 수행하며 그를 수행하기 위해 많은 것들을 필요로 한다.<br />
하지만 필요한 모든 것들을 컨트롤러에서 처리하기엔 너무 방대하다.</p>

<p>따라서 기능별로 서비스, 리포지토리 등을 통해서 컨트롤러에 해당하는 기능을 넣어(종속성을 주입한다)주는 개념을 통틀어 프로바이더라 일컫는다.</p>

<p><br />
<br /></p>

<h4 id="4-nestjs-서비스란">4. NestJS 서비스란?</h4>
<hr />

<p>서비스는 소프트웨어 개발내의 공통 개념이며, NestJS나 JavaScript에서만 쓰이는 개념은 아니다.</p>

<p>서비스는 @Injectable 데코레이터로 감싸져서 모듈에 제공되며, 이 서비스 인스턴스는 애플리케이션 전체에서 사용될 수 있다.<br />
서비스는 컨트롤러에서 데이터의 유효성 체크를 하거나 데이터베이스 CRUD가 이뤄지는 부분들을 처리한다.</p>

<p>NestJS CLI로 생성한 기본 프로젝트를 예로 들면 <code class="language-plaintext highlighter-rouge">'Hello World!'</code> 문자열을 리턴해주는 아래의 부분이 대표적인 서비스라 볼 수 있다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Injectable</span><span class="p">()</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">AppService</span> <span class="p">{</span>
	<span class="nx">getHello</span><span class="p">():</span> <span class="kr">string</span> <span class="p">{</span>
		<span class="k">return</span> <span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="오늘-느낀-점">오늘 느낀 점</h2>
<p><a href="https://jh8459.github.io/til/22.04.14.til/" target="_blank">따라하며 배우는 Nest JS #2</a>에서는 NestJS 로직 흐름에 대해서 학습했다면 오늘은 전반적인 부분마다 어떠한 기능을 수행하며 각 부분들이 어떻게 상호 연결되어 동작되는지에 대한 디테일한 부분을 우선 알아보았다.</p>

<p>각종 예제를 통해서 실제로 코드를 짜봐야 사실 조금 더 와닿을 듯 하다.</p>

<p>주말을 통해서 CRUD 관련해서 실제로 코드로 구현해보는 시간을 가져야 할 듯하다.</p>

<p><br />
<br /></p>
:ET