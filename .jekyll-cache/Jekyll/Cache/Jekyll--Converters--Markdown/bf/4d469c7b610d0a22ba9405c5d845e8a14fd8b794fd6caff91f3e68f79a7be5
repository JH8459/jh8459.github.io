I"<p><img src="https://user-images.githubusercontent.com/83164003/157039191-32141e02-51fe-4d34-abeb-02bb8f897dde.jpeg" alt="TIL" /></p>
<h2 id="today-i-learnd">Today I Learnd</h2>

<p>프로젝트들을 진행하며 대용량 서비스를 염두하고 서버를 개발해본 경험이 아직없다.</p>

<p>Node.js 기반의 웹 서버 사용시 트래픽이 많아지는 경우 서버에 걸리는 과부하에 대응 하는 방법들을 학습해 보고 글로 남겨보려 한다.</p>

<p><br />
<br />
우선 Node.js 환경 뿐 아니라 대개의 서버는 중앙 집중형태로 다수의 클라이언트를 위해 존재한다.</p>

<p><img src="https://user-images.githubusercontent.com/83164003/157154569-5c971607-3357-424a-a2d4-e4511c353ecf.png" alt="server" />
<br />
<br /></p>

<p>때문에 클라이언트로부터 수많은 요청을 동시에 받으므로 병목현상이 발생하기 쉬우며 이를 대비해 처리 성능에 항상 주목해야 한다.</p>

<p><br />
<br /></p>

<h3 id="1-nodejs의-비동기-처리">1. Node.js의 비동기 처리</h3>
<hr />
<p>Node.js는 비동기 IO를 지원하며 싱글 쓰레드 기반으로 동작하는 서버이다. <del>(여기서 비동기 처리란? 어떤 코드의 출력이 끝날 때까지 기다려주지 않고 다른 코드를 먼저 실행하는 방식이다.)</del></p>

<p><br />
<img src="https://user-images.githubusercontent.com/83164003/157156519-26f217ba-ac29-4128-b318-552f94239f73.png" alt="eventloop" /></p>
<center><span style="font-size: 0.75em;">출처 : <a href="https://www.nextree.co.kr/p7292/" target="_blank">넥스트리</a></span></center>
<p><br /></p>

<p>비동기 처리방식은 이벤트 방식으로 풀어낸다.<br />
클라이언트에서 발생된 요청을 처리하기 위해 이벤트가 발생하며, 서버 내부에 메시지 형태로 전달된다. 이 메시지는 Event Loop에서 처리가 되며 서버는 다음 클라이언트 요청을 다시 받아들인다.</p>

<p>Event Loop에서 요청 처리가 완료되면 CallBack을 호출하여 처리완료를 서버에 알려준다. 이러한 이벤트 처리는 싱글 쓰레드 기반으로 Event Loop에서 처리되므로 Node.js는 싱글 쓰레드 기반으로 동작한다 일컫는다. 즉, 클라이언트 요청은 하나의 쓰레드 안에서 처리된다.</p>

<p>그래서 이벤트 호출 측면으로 본다면 비동기로 처리되지만 요청의 작업 단위가 프로세스를 크게 요구하는 요청일 경우에는 쓰레드 하나에서 해당 처리작업이 오래걸리므로 전체 서버 처리에 영향을 미치게된다. (이는 Node.js의 치명적인 약점이다.)</p>

<p><br />
<br /></p>

<p>따라서 Node.js의 Event Loop 처리 과정은 싱글 쓰레드 기반으로 작업이 처리가 되며, 클라이언트의 요청은 비동기 메시지로 처리된다.</p>

<p>따라서 사용자는 반드시 처리 로직을 비동기로 구현해야 Node.js를 올바르게 활용하는 방법이며, 클라이언트가 요청하는 처리 작업 단위가 CPU를 많이 소모하지 않는 작업이라면 고효율 고성능을 보장해주지만 CPU를 많이 소모하는 작업이라면 Node.js는 알맞지 않은 서버일 수 있다.</p>

<p>서비스에 알맞는 서버 환경을 구축하는게 바람직한 방향이다.</p>

<blockquote>
  <p>PayPal, Netflix, LinkedIn, Groupon 등 전 세계적인 서비스에서 이미 Node.js를 사용하고 있다.</p>
</blockquote>

<p><br />
<br /></p>

<h3 id="2-트래픽이-많아지는-경우-분산처리">2. 트래픽이 많아지는 경우 분산처리</h3>
<hr />

<p>위에서 언급했듯이 Node.js는 결국 싱글 쓰레드 기반으로 작업이 처리된다.<br />
아무리 클라이언트에서 많은 요청이 와도, Node.js는 싱글스레드를 통해서 이를 하나씩 처리한다. 때문에, 분산처리가 중요 할 수 밖에 없다.</p>

<p><br />
<br /></p>

<h4 id="2-1-클라우드-서비스-환경에서-로드-밸런서-사용">2-1. 클라우드 서비스 환경에서 로드 밸런서 사용</h4>
<hr />

<p>AWS를 예로 들면, <em>로드밸런서</em> 는 분산 환경을 제공하여 단일 대역으로의 대용량 트래픽이 집중 라우팅되는 것을 방지할 수 있다.</p>

<blockquote>
  <p><strong>로드 밸런서가 하는 일?</strong></p>

  <ol>
    <li>클라이언트의 요청을 여러 대의 서버로 분산시킨다.</li>
    <li>온라인 상태인 서버에만 요청을 전송하여 신뢰성과 고가용성을 준다.</li>
    <li>수요에 따라(요청의 양에 따라) 서버를 추가하거나 제거할 수 있는 유연성을 제공해준다.</li>
  </ol>

  <p>대게 로드 밸런서는 Round Robin 알고리즘을 이용하기 때문에 특별한 우선순위 없이 유저/클라이언트의 요청을 들어오는 순서대로 처리한다.</p>
</blockquote>

<p>클라우드 서비스를 이용할 경우 서버에 부하되는 환경을 고려하여 가상이미지로 서버환경을 만든다.<br />이때 Auto Scaling을 통해 각각의 적절한 용량의 서버를 생성해주므로 트래픽이 많아져도 대응이 가능하다.</p>

<ul>
  <li><strong>캐싱</strong></li>
</ul>

<p><br />
<br /></p>
<h2 id="오늘-느낀-점">오늘 느낀 점</h2>

<p><br />
<br /></p>
:ET