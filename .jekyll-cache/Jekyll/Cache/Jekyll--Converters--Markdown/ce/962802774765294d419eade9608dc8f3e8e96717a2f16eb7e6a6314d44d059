I"T#<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="algorithm" /></p>
<h2 id="toy-19-lps">TOY 19. LPS</h2>
<h3 id="문제">문제</h3>
<hr />
<p>문자열을 입력받아 다음의 조건을 만족하는 LPS<code class="language-plaintext highlighter-rouge">*</code>를 찾아 그 길이를 리턴해야 합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LPS</code>: 주어진 문자열의 가장 긴 접두어이자 접미어(Longest Prefix which is also Suffix)</li>
  <li>non-overlapping: 접두어와 접미어는 서로 겹치는 부분이 없어야 합니다. 다시 말해, prefix와 suffix는 문자열의 동일한 인덱스에 위치한 문자를 요소로 가지면 안 됩니다.</li>
</ul>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1--str">인자 1 : str</h4>
<ul>
  <li>string 타입의 임의의 알파벳 소문자 문자열</li>
  <li><code class="language-plaintext highlighter-rouge">str.length</code>는 60,000 이하</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입을 리턴해야 합니다.</li>
</ul>

<h3 id="주의사항">주의사항</h3>
<hr />
<ul>
  <li>prefix(접두어)는 문자열의 첫 인덱스부터 시작하는 모든 부분 문자열을 의미합니다.</li>
  <li>suffix(접미어)는 문자열의 마지막 인덱스부터 시작하는 모든 부분 문자열을 의미합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">LPS</span><span class="p">(</span><span class="dl">'</span><span class="s1">abbbcc</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 0</span>

<span class="nx">output</span> <span class="o">=</span> <span class="nx">LPS</span><span class="p">(</span><span class="dl">'</span><span class="s1">aaaa</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 2</span>
<span class="c1">// prefix: str.slice(0, 2)</span>
<span class="c1">// suffix: str.slice(2)</span>
<span class="c1">// non-overlapping 조건이 없는 경우 정답은 4 입니다.</span>

<span class="nx">output</span> <span class="o">=</span> <span class="nx">LPS</span><span class="p">(</span><span class="dl">'</span><span class="s1">aaaaa</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 2</span>
<span class="c1">// prefix: str.slice(0, 2)</span>
<span class="c1">// suffix: str.slice(3)</span>
<span class="c1">// non-overlapping 조건이 없는 경우 정답은 5 입니다.</span>
</code></pre></div></div>

<h3 id="advanced">Advanced</h3>
<hr />
<ul>
  <li>LPS를 계산하는 효율적인 알고리즘(<code class="language-plaintext highlighter-rouge">O(N)</code>)이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.</li>
  <li>정규식(regular expression)을 활용하면 아래처럼 간단하게 구현할 수 있습니다. 정규식에 대해서 학습하시기 바랍니다. <a href="https://regexr.com/" target="_blank">(참고사이트)</a></li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">LPS</span> <span class="o">=</span> <span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^</span><span class="se">(\w</span><span class="sr">*</span><span class="se">)</span><span class="sr">.*</span><span class="se">\1</span><span class="sr">$/</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="toy-19-solution">TOY 19. Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />
<p>사실 문제가 이해가 잘 안가서 몇번 다시 쳐다보았다. 
손으로 써가며 이해한 바로는</p>

<p><img src="https://user-images.githubusercontent.com/83164003/133775557-73296f0c-37e8-43b6-ae64-0aba0d96ac2e.jpg" alt="손코딩" /></p>

<ol>
  <li>문자열을 절반(짝수 경우 5:5로 쪼갤수있고, 홀수인 경우엔 알아서… 비는 문자열 없이 나눠준다.)으로 나눠준다.</li>
  <li>쪼개진 <code class="language-plaintext highlighter-rouge">prefix</code>와 <code class="language-plaintext highlighter-rouge">sufix</code> 안의 내부 문자를 반복문을 통해 순회한다.</li>
  <li><code class="language-plaintext highlighter-rouge">prefix</code>는 0번 인덱스는 고정,<code class="language-plaintext highlighter-rouge">prefix[prefix.length]</code> 인덱스를 줄여가며 만들어진 새로운 문자열은 LPS 후보가 된다</li>
  <li><code class="language-plaintext highlighter-rouge">sufix</code>는 0번 인덱스부터 늘려가며 <code class="language-plaintext highlighter-rouge">sufix[sufix.length]</code>인덱스는 고정한 상태에서 만들어진 새로운 문자열은 LPS 후보가 된다.</li>
  <li>반복문을 순회하며 새로 만들어진 두 문자열이 같아지면 반복문을 종료하고 현재 중복된 문자열의 길이를 반환한다.
    <h3 id="문제풀이">문제풀이</h3>
    <hr />
    <p>```javascript 
const LPS = function (str) {
  // TODO: 여기에 코드를 작성합니다.
  let result = ‘’;</p>
  </li>
</ol>

<p>for (let i = 0; i &lt;= str.length / 2; i += 1) {
    let prefix = str.slice(0, i);
    let suffix = str.slice(str.length - i);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (prefix === suffix) {
  result = prefix;
}   };
</code></pre></div></div>

<p>return result.length;
};</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>### Reference Code
---
```javascript
// naive solution
// const getItemFromTwoSortedArrays = function (arr1, arr2, k) {
//   let cnt = 0,
//     left = 0,
//     right = 0;
//   let target;
//   while (cnt &lt; k) {
//     if (arr1[left] &lt; arr2[right]) {
//       target = arr1[left];
//       left++;
//     } else {
//       target = arr2[right];
//       right++;
//     }
//     cnt++;
//   }
//   return target;
// };

// O(logK) solution
const getItemFromTwoSortedArrays = function (arr1, arr2, k) {
  let leftIdx = 0,
    rightIdx = 0;

  while (k &gt; 0) {
    // 이진 탐색을 위해 각 배열에서 k를 절반으로 쪼개서 카운트 한다.
    let cnt = Math.ceil(k / 2);
    let leftStep = cnt,
      rightStep = cnt;

    // 엣지 케이스
    // 카운트가 남았음에도 배열의 끝에 도달하면 k를 나머지 배열쪽으로 넘긴다.
    if (leftIdx === arr1.length) {
      rightIdx = rightIdx + k;
      break;
    }

    if (rightIdx === arr2.length) {
      leftIdx = leftIdx + k;
      break;
    }

    // 엣지 케이스
    // 현재 카운트가 남아있는 후보 요소들보다 많을 경우, leftStep(현재 할당량)을 남아있는 요소들의 개수로 바꾼다.
    if (cnt &gt; arr1.length - leftIdx) leftStep = arr1.length - leftIdx;
    if (cnt &gt; arr2.length - rightIdx) rightStep = arr2.length - rightIdx;

    // 두 배열의 현재 검사 요소 위치를 비교해서, 그 값이 작은 배열은 비교한 위치 앞에 있는 요소들을 모두 후보군에서 제외시킨다.
    if (arr1[leftIdx + leftStep - 1] &lt; arr2[rightIdx + rightStep - 1]) {
      leftIdx = leftIdx + leftStep;
      // 처리가 끝나면 k값을 절반으로 떨어뜨린다.
      k = k - leftStep;
    } else {
      rightIdx = rightIdx + rightStep;
      k = k - rightStep;
    }
  }

  leftMax = arr1[leftIdx - 1] || -1;
  rightMax = arr2[rightIdx - 1] || -1;

  return Math.max(leftMax, rightMax);
};
</code></pre></div></div>
<h2 id="오늘-느낀-점">오늘 느낀 점</h2>

<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>TOY 19. LPS</li>
</ul>
:ET