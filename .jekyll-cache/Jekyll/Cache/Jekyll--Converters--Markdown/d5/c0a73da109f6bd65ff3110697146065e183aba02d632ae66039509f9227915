I"zT<ul>
  <li>여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 발생한다.- 통계 정보- **User-Agent: 유저 에이전트 애플리케이션 정보<img src="https://user-images.githubusercontent.com/83164003/127775612-7464075f-89e7-478e-82ee-dc1c2710a125.jpeg" alt="TIL" />
    <h2 id="today-i-learnd">Today I Learnd</h2>
    <h3 id="1-인터넷-프로토콜">1. 인터넷 프로토콜</h3>
    <hr />
  </li>
</ul>

<h4 id="1-1-ip와-ip-packet">1-1. IP와 IP Packet</h4>
<hr />
<ul>
  <li>
    <p>IP 패킷에서 패킷은 pack과 bucket이 합쳐진 단어로 소포로 비유할 수 있다. IP 패킷은 우체국 송장처럼 전송 데이터를 무사히 전송하기 위해 출발지 IP, 목적지 IP와 같은 정보가 포함되어 있으며 데이터를 전달하는 통신의 단위이다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138825068-009e4ba1-8fda-4b99-a212-807c3e789a45.png" alt="스크린샷, 2021-10-26 16-00-27" /></p>
  </li>
  <li><strong>클라이언트 패킷 전달</strong> 과정을 살펴보면 다음과 같다.
    <ul>
      <li>클라이언트가 IP 패킷을 인터넷 상의 노드에 던진다.</li>
      <li>인터넷 상의 노드(컴퓨터)들은 모두 IP 프로토콜을 따르기 때문에 해당 패킷의 정보(출발지, 목적지)를 이해할 수 있다.</li>
      <li>중간 노드들은 목적지 노드가 어디있는지 서로 물어가면서 해당 패킷을 전달한다. (라우팅 과정)</li>
    </ul>

    <p>위 과정을 통해 복잡한 인터넷 망 사이에서도 정확한 목적지로 패킷을 전송할 수 있다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843412-075e4290-60f1-4dab-9c6c-ebcbdceb3c46.png" alt="스크린샷, 2021-10-26 17-44-49" /></p>
  </li>
  <li>
    <p><strong>서버 패킷 전달</strong> 과정또한 클라이언트와 마찬가지로 이뤄지며, 패킷 단위 데이터로 통신이 이뤄진다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843489-1b89909f-3b7f-45a4-8102-7b26d702c491.png" alt="스크린샷, 2021-10-26 17-45-57" /></p>
  </li>
</ul>

<hr />
<h5 id="ip-프로토콜-한계">IP 프로토콜 한계</h5>
<ul>
  <li>정확한 출발지와 목적지를 파악할 수 있다는 점에서 IP 프로토콜은 적절한 통신 방법으로 보이지만 단점도 명확하다.
    <ul>
      <li><strong>비연결성</strong> : 만약 패킷을 받을 대상이 없거나 서비스 불능 상태여도 클라이언트는 서버의 상태를 파악할 방법이 없기 때문에 패킷을 그대로 전송하게 된다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843593-38235e14-8e51-4d3e-b6cf-1176fb6b2a88.png" alt="스크린샷, 2021-10-26 17-46-25" /></p>
    <ul>
      <li><strong>비신뢰성</strong> : 중간에 있는 서버가 데이터를 전달하던 중 장애가 생겨 패킷이 중간에 소실되더라도 클라이언트는 이를 파악할 방법이 없다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843686-c69809c1-7bfd-4e2f-8692-51e82a11904f.png" alt="스크린샷, 2021-10-26 17-46-59" /></p>
    <ul>
      <li>
        <p><strong>비신뢰성(패킷 전달 순서 문제)</strong> : 전송하려는 패킷의 용량이 매우 큰 경우 (대략 1500Byte 정도가 넘으면 해당 내용을 끊어서 보낸다), 이러한 경우 전송하려는 패킷들의 순서가 중요하다.</p>

        <p>그러나 IP프로토콜에서는 하나의 데이터에 연관된 패킷들이 각각 다른 경로로 전송될 수 있다. 따라서 도착하는 순서도 보장되지 않는다.</p>

        <p><img src="https://user-images.githubusercontent.com/83164003/138843811-620d17a3-5d7c-48e2-9b5e-8514afb46c66.png" alt="스크린샷, 2021-10-26 17-47-33" /></p>
      </li>
    </ul>
  </li>
</ul>

<hr />
<h4 id="1-2-tcp--udp">1-2. TCP / UDP</h4>
<ul>
  <li>
    <p>네트워크 프로토콜 계층은 다음과 같이 OSI 7계층과 TCP/IP 4 계층으로 나눌 수 있다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138831221-93740d56-e01a-4a86-ad31-4e0ecf309f6c.PNG" alt="osi7" /></p>

    <p>IP 프로토콜 보다 더 높은 계층에 TCP 프로토콜이 존재하기 때문에 앞서 다룬 IP 프로토콜에서 발생했던 수많은 문제들(패킷의 순서가 꼬이고, 유실되는 등의 문제)을 TCP 프로토콜이 해결해준다.</p>
  </li>
  <li>
    <p>우선 FLOW CHART를 보면 다음과 같다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843963-4d1975f0-d6af-423b-91ae-40063ecb1884.png" alt="스크린샷, 2021-10-26 17-48-27" /></p>

    <ul>
      <li>응용프로그램이 HTTP 프로토콜을 통하여 ‘Hello World’ 메시지 생성함.</li>
      <li>SOCKET 라이브러리를 통해 OS계층에 HTTP 메시지 전달됨.</li>
      <li>TCP Layer 에서는 Hello, world 메시지에 TCP 세그먼트를 씌운다.</li>
      <li>TCP 세그먼트가 씌워진 HTTP 메세지를 IP 계층으로 전달(받은 메시지 위에 또 IP와 관련된 데이터들을 씌운다). ➡ TCP/IP 패킷이 생성됨.</li>
      <li>이렇게 생성된 TCP/IP 패킷은 LAN 카드와 같은 물리적 계층을 지나기 위해 이더넷 프레임 워크에 포함되어 서버로 전송함.</li>
    </ul>

    <blockquote>
      <p>TCP 세그먼트란?</p>

      <p><img src="https://user-images.githubusercontent.com/83164003/138846259-8a7c7f61-98be-42f3-bc5b-b5bedb174451.png" alt="스크린샷, 2021-10-26 18-01-14" /></p>

      <p>TCP 세그먼트에는 IP 패킷의 출발지 IP와 목적지 IP 정보를 보완할 수 있는 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등을 포함한다. ➡ IP에서 해결이 안되었던 순서 제어문제 등이 해결된다.</p>
    </blockquote>
  </li>
</ul>

<hr />
<h5 id="tcp-특징">TCP 특징</h5>
<ul>
  <li>전송 제어 프로토콜(Transmission Control Protocol) 이다. 다음과 같은 특징을 갖기 때문에 TCP는 같은 계층에 속한 UDP에 비해 상대적으로 신뢰할 수 있는 프로토콜이며, 현재 대부분 TCP를 사용한다.
    <ul>
      <li><strong>연결 지향 - TCP 3 way handshake (가상 연결)</strong> : <a href="https://www.sciencedirect.com/topics/computer-science/three-way-handshake" target="_blank">링크</a> 참조.</li>
      <li><strong>데이터 전달 보증 (패킷 소실 문제 해결)</strong> : TCP는 데이터 전송이 성공적으로 이루어진다면 이에 대한 응답을 돌려주기 때문에 IP 패킷의 한계인 비연결성을 보완이 가능하다.</li>
      <li><strong>순서 보장 (패킷 순서 문제 해결)</strong> : TCP는 패킷이 순서대로 도착하지 않는다면 TCP 세그먼트에 있는 정보를 토대로 다시 패킷 전송을 요청할 수 있다. 이를 통해 IP 패킷의 한계인 비신뢰성(순서를 보장하지 않음)을 보완할 수 있게된다.</li>
    </ul>
  </li>
</ul>

<hr />
<h5 id="udp-특징">UDP 특징</h5>
<ul>
  <li>사용자 데이터그램 프로토콜(User Datagram Protocol) 이다. UDP는 IP 프로토콜에 PORT, 체크섬 필드 정보만 추가된 단순한 프로토콜이다.
    <ul>
      <li><strong>비 연결 지향</strong> : 3 way handshake 방식을 사용하지 않기 때문에 TCP와 비교해 빠른 속도를 보장한다.</li>
    </ul>

    <blockquote>
      <p>체크섬(checksum)은 중복 검사의 한 형태로, 오류 정정을 통해, 공간(전자 통신)이나 시간(기억 장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법이다.</p>
    </blockquote>
  </li>
  <li>HTTP3는 UDP를 사용하며, 이미 여러 기능이 구현된 TCP 보다는 하얀 도화지처럼 커스터마이징이 가능하다는 장점이 있다.</li>
</ul>

<hr />
<h4 id="1-3-http">1-3. HTTP</h4>
<ul>
  <li>HTTP(HyperText Transfer Protocol)는 W3 상에서 정보를 주고받을 수 있는 프로토콜이다. 주로 TCP를 사용하고 HTTP/3 부터는 UDP를 사용하고 있다.</li>
  <li>HTTP는 다음과 같은 특징을 갖는다.
    <ul>
      <li>
        <p><strong>클라이언트 서버 구조</strong> : 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조이다.</p>

        <p><img src="https://user-images.githubusercontent.com/83164003/138867669-7a214209-dd9a-4900-ae20-789a74310f60.png" alt="스크린샷, 2021-10-26 20-18-58" /></p>
      </li>
      <li><strong>무상태 프로토콜(Stateless)</strong> : HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜이다. (무상태성을 보완하기 위하여 나온게 브라우저 상태를 유지할 수 있게 하는 쿠키, 세션, 토큰.. 등 이다.)</li>
      <li><strong>비연결성(Connectionless)</strong> : 비 연결성을 가지는 HTTP에서는 실제로 요청을 주고 받을 때만 연결을 유지하고, 응답을 주고나면 TCP/IP 연결을 끊는다. 이를 통해 최소한의 자원으로 서버 유지를 가능하게 한다.</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="2-http-헤더">2. HTTP 헤더</h3>
<hr />

<p>HTTP 헤더는 HTTP 전송에 필요한 모든 부가정보를 (메시지 바디의 내용, 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보 등) 넣는 영역이다.</p>

<hr />
<h4 id="2-1-표현-헤더representation-headers">2-1. 표현 헤더(Representation Headers)</h4>
<p><img src="https://user-images.githubusercontent.com/83164003/138870358-1a07dcc6-27c6-4135-9a9c-363b012ea17d.png" alt="스크린샷, 2021-10-26 20-38-42" /></p>

<p>과거의 헤더는 위와 같이 분류하였다. 하지만 이런 엔티티 헤더 스펙은 1999년 RFC2616 스펙에서 나온 스펙인데, 이 스펙은 2014년 RFC7230~7235가 등장하면서 폐기된다. 그 이후 엔티티라는 표현은 표현이라는 용어가 사용된다.</p>

<blockquote>
  <p>Entity 헤더:  엔티티 바디 정보로 컨텐츠 타입이나 길이같은 메세지 바디에 들어가는 내용에 관련된 헤더가 들어가는 헤더</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/83164003/138870447-1665c3d1-779a-46ac-aac2-0946d78200c7.png" alt="스크린샷, 2021-10-26 20-39-30" /></p>

<p>현재의 헤더는 왜 엔티티를 표현이라고 바꿔서 말하는 것일까? 예를들어 회원 조회 내역을 응답할 때 이를 HTML로 표현할 수도 있고, JSON으로 표현해 전달할 수도 있다. 그래서 이렇게 실제 전달하는 것을 표현이라고 용어를 정의했다.</p>

<hr />
<h5 id="표현">표현</h5>
<hr />

<ul>
  <li>회원이라는 리소스가 있을 때 이를 HTML 혹은 JSON으로 전달할 것인지는 클라이언트와 서버간에 송/수신할 때 이 리소스를 무엇으로 표현할지 알려주고, 표현한다.</li>
  <li>
    <p>다음은 표현 데이터의 형식, 압축 방식, 자연 언어, 길이등을 설명하는 헤더이다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138871569-6945463f-309a-4e69-bc1a-a011bf99a84b.png" alt="스크린샷, 2021-10-26 20-46-57" /></p>

    <ul>
      <li>
        <p><strong>Cotent-Type</strong> : 표현 데이터의 형식</p>

        <p><img src="https://user-images.githubusercontent.com/83164003/138872131-8f749694-5cd3-4eeb-ab92-71675be97d56.png" alt="스크린샷, 2021-10-26 20-51-31" /></p>
      </li>
      <li>
        <p><strong>Cotent-Encoding</strong> : 표현 데이터의 압축 방식</p>

        <p><img src="https://user-images.githubusercontent.com/83164003/138872204-ed2e6c79-6a6c-46e3-8060-414cfedd1330.png" alt="스크린샷, 2021-10-26 20-52-01" /></p>
      </li>
      <li>
        <p><strong>Cotent-Language</strong> : 표현 데이터의 자연 언어</p>

        <p><img src="https://user-images.githubusercontent.com/83164003/138872327-df90b55d-19d8-4806-8917-d6e10efcd19d.png" alt="스크린샷, 2021-10-26 20-52-51" /></p>
      </li>
      <li>
        <p><strong>Cotent-Length</strong> : 표현 데이터의 길이</p>

        <p><img src="https://user-images.githubusercontent.com/83164003/138872369-34b500e2-5ccb-4f81-9188-0518f2a21c77.png" alt="스크린샷, 2021-10-26 20-53-20" /></p>
      </li>
      <li>
        <p>표현 헤더는 요청, 응답 둘 다 사용한다.</p>
      </li>
    </ul>
  </li>
</ul>

<hr />
<h4 id="2-2-http-주요-헤더">2-2. HTTP 주요 헤더</h4>
<hr />

<p><img src="https://user-images.githubusercontent.com/83164003/138873301-e2f39ab6-300b-4570-a959-9b22aff92e6a.png" alt="jkpVF5HFF-1622794687505" /></p>

<hr />
<h5 id="요청request에서-사용되는-헤더">요청(Request)에서 사용되는 헤더</h5>
<hr />
<ul>
  <li><strong>From</strong> : 유저 에이전트의 이메일 정보.
    <ul>
      <li>일반적으로 잘 사용하지 않는다.</li>
      <li>검색 엔진에서 주로 사용한다.</li>
    </ul>
  </li>
  <li><strong>Referer</strong> (referrer의 오탈자이지만 스펙으로 굳어짐): 현재 요청된 페이지의 이전 웹 페이지 주소.
    <ul>
      <li>A → B로 이동하는 경우 B를 요청할 때 Referer: A 를 포함해서 요청한다.</li>
      <li>Referer 를 사용하면 유입경로 수집 가능하다.</li>
    </ul>
  </li>
  <li><strong>User-Agent</strong> : 유저 에이전트 애플리케이션 정보(웹 브라우저 정보, 등등).
    <ul>
      <li>통계 정보를 나타낼 수 있다.</li>
      <li>어떤 종류의 브라우저에서 장애가 발생하는지 파악이 가능하다.</li>
    </ul>
  </li>
  <li><strong>Host</strong> : 요청한 호스트 정보(도메인).
    <ul>
      <li>하나의 서버가 여러 도메인을 처리해야 할 때 호스트 정보를 명시하기 위해 사용한다.</li>
      <li>하나의 IP 주소에 여러 도메인이 적용되어 있을 때 호스트 정보를 명시하기 위해 사용한다.</li>
    </ul>
  </li>
  <li><strong>Origin</strong> : 서버로 POST 요청을 보낼 때, 요청을 시작한 주소를 나타냄
    <ul>
      <li>여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 발생한다.</li>
      <li>응답 헤더의 Access-Control-Allow-Origin와 관련있다.</li>
    </ul>
  </li>
  <li><strong>Authorization</strong> : 인증 토큰(<code class="language-plaintext highlighter-rouge">ex) JWT</code>)을 서버로 보낼 때 사용하는 헤더.</li>
</ul>

<hr />
<h5 id="응답response에서-사용되는-헤더">응답(Response)에서 사용되는 헤더</h5>
<ul>
  <li><strong>Server</strong> : 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보.</li>
  <li><strong>Date</strong> : 메시지가 발생한 날짜와 시간.</li>
  <li><strong>Location</strong> : 페이지 리디렉션.
    <ul>
      <li>웹 브라우저는 3xx 응답의 결과에 <code class="language-plaintext highlighter-rouge">Location</code> 헤더가 있으면, <code class="language-plaintext highlighter-rouge">Location</code> 위치로 리다이렉트(자동 이동)</li>
      <li>201(Created): <code class="language-plaintext highlighter-rouge">Location</code> 값은 요청에 의해 생성된 리소스 URI.</li>
      <li>3xx(Redirection): <code class="language-plaintext highlighter-rouge">Location</code> 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킨다.</li>
    </ul>
  </li>
  <li><strong>Allow</strong> : 허용 가능한 HTTP 메서드. <code class="language-plaintext highlighter-rouge">ex) Allow: GET, HEAD, PUT</code></li>
  <li><strong>Retry-After</strong> : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간.</li>
</ul>

<hr />
<h4 id="2-3-콘텐츠-협상-헤더">2-3. 콘텐츠 협상 헤더</h4>
<ul>
  <li>클라이언트가 선호하는 표현 요청</li>
  <li>클라이언트와 서버간에 클라이언트가 원하는 우선순위대로 맞춰서 서버에서 되는대로 표현 데이터를 만들어 주는 것,  클라이언트에서 요청시에만 작성하는 것이기에 요청에만 사용한다.
    <ul>
      <li><strong>Accept</strong> : 클라이언트가 선호하는 미디어 타입 전달.</li>
      <li><strong>Accept_Charset</strong> : 클라이언트가 선호하는 문자 인코딩.</li>
      <li><strong>Accept-Encoding</strong> : 클라이언트가 선호하는 압축 인코딩.</li>
      <li><strong>Accept-Language</strong> : 클라이언트가 선호하는 자연 언어.</li>
    </ul>
  </li>
</ul>

<hr />
<h5 id="콘텐츠-협상-예시">콘텐츠 협상 예시</h5>
<hr />

<p><strong>Accept-Language 적용 전</strong></p>

<p><img src="https://user-images.githubusercontent.com/83164003/138877538-fb4edfd0-6732-4949-a520-b8c8e7acbb6f.png" alt="스크린샷, 2021-10-26 21-18-48" /></p>

<ul>
  <li>한국어 브라우저에서 특정 웹사이트에 접속했을 때 콘텐츠 협상(Accept-Language)이 안되있을 경우, 서버에서는 딱히 우선순위같은게 없기에 기본언어로 설정된 영어로 응답한다.</li>
</ul>

<p><strong>Accept-Language 적용 전</strong></p>

<p><img src="https://user-images.githubusercontent.com/83164003/138877543-baae5d62-db0c-4c2c-9229-b01481cf0306.png" alt="스크린샷, 2021-10-26 21-18-57" /></p>

<ul>
  <li>클라이언트에서 Accept-Language로 KO를 작성해 요청하면 서버에서는 해당 우선순위 언어를 지원할 수 있기 때문에 해당 언어인 한국어로 된 응답을 작성해 반환해준다.</li>
</ul>

<hr />

<p><strong>Accept-Language 복잡한 예시</strong></p>

<p>위처럼 지원하는 언어를 요청하는 단순한 경우라면 문제가 없다. 하지만, 서버에서 지원하는 언어가 여러개인데 내가 최우선으로 선호하는 언어는 적용되지 않는다면 어떻게 해야하는가?</p>

<p><img src="https://user-images.githubusercontent.com/83164003/138878111-0ae50979-b0e4-46ff-ae13-a6d2d4e668bd.png" alt="스크린샷, 2021-10-26 21-23-15" /></p>

<ul>
  <li>클라이언트에서는 한국어를 선호하기에 Accept-Language에 한국어를 요청했다.</li>
  <li>하지만 서버에서는 한국어를 지원하지 않는상황이고 기본 언어는 독일어로 되어있다.</li>
  <li>클라이언트에서는 독일어는 너무 어렵기 때문에 한국어가 안되면 영어라도 나오길 바란다면? ➡ 우선순위를 사용해야 한다.</li>
</ul>

<hr />

<h5 id="협상과-우선순위">협상과 우선순위</h5>
<hr />
<p><strong>Quality Values(q)</strong></p>

<p><img src="https://user-images.githubusercontent.com/83164003/138878896-e7980921-32b7-4e93-a045-687560ce1e0e.png" alt="스크린샷, 2021-10-26 21-28-25" /></p>

<ul>
  <li>Quality Values(q) 값 사용</li>
  <li>0~1, 1에 가까울수록(클수록) 높은 우선순위를 가진다.</li>
  <li>생략하면 1</li>
  <li>Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
    <ol>
      <li>ko-KR;q=1 (q생략)</li>
      <li>ko;q=0.9</li>
      <li>en-US;q=0.8</li>
      <li>en:q=0.7</li>
    </ol>
  </li>
</ul>

<hr />

<p><strong>Accept-Language 복잡한 예시 ➡ 우선 순위 적용 후</strong></p>

<p><img src="https://user-images.githubusercontent.com/83164003/138879224-fcae9330-814e-4729-a32a-679e603d7a13.png" alt="스크린샷, 2021-10-26 21-30-09" /></p>

<ul>
  <li>1순위인 한국어를 서버에서는 지원하지 않는다.</li>
  <li>2순위인 영어를 서버에서는 지원한다.</li>
  <li>서버에서는 우선순위에있는 영어를 독일어보다 선호하기에 영어로 응답한다.</li>
</ul>

<hr />

<h3 id="3-웹-캐시">3. 웹 캐시</h3>
<hr />
<h4 id="3-1-캐시의-기본-원리-및-적용">3-1. 캐시의 기본 원리 및 적용</h4>
<hr />
<h5 id="캐시가-없을-때">캐시가 없을 때</h5>
<p><strong>첫번째 요청</strong></p>

<p><img src="https://user-images.githubusercontent.com/83164003/138879750-b4fa393c-289e-4794-8b51-2105eec6410e.png" alt="스크린샷, 2021-10-26 21-33-56" /></p>

<ul>
  <li>클라이언트에서 star.jpg 이미지를 요청한다.</li>
  <li>서버에서는 해당 이미지가 있으면 응답을 줘야하는데, 이미지의 HTTP 헤더+바디를 합쳐 대략 1.1M정도 용량의 데이터를 응답한다.</li>
  <li>클라이언트에서는 해당 이미지를 응답 받아 사용한다.</li>
</ul>

<hr />
<p><strong>두번째 요청</strong></p>

<p><img src="https://user-images.githubusercontent.com/83164003/138879976-76d661e6-55aa-4cc8-9822-0fcd11698828.png" alt="스크린샷, 2021-10-26 21-35-40" /></p>

<ul>
  <li>클라이언트에서는 star.jpg 이미지를 다시 한 번 요청한다.</li>
  <li>서버에서는 동일한 이미지를 다시 1.1M정도 용량의 데이터를 응답해준다.</li>
  <li>
    <p>클라이언트에서는 해당 이미지를 응답 받아 사용한다.</p>

    <blockquote>
      <p><strong>동일한 이미지를 요청하는데 네트워크를 통해 같은 데이터를 또 다운받아야 한다. 용량이 클 수록 비용이 커지고 브라우저의 로딩속도가 느려진다.</strong></p>
    </blockquote>
  </li>
</ul>

<h5 id="캐시가-적용되었을-때">캐시가 적용되었을 때</h5>

<p><br />
<br /></p>

<h2 id="오늘-느낀-점">오늘 느낀 점</h2>

<p><br />
<br /></p>

<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>[GIT] 브랜치 관리와 고급기능</li>
</ul>
:ET