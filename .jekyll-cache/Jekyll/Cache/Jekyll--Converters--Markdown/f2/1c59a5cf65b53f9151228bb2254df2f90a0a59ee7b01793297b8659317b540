I"i9<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="algorithm" /></p>
<h2 id="toy-19-lps">TOY 19. LPS</h2>
<h3 id="문제">문제</h3>
<hr />
<p>문자열을 입력받아 다음의 조건을 만족하는 LPS<code class="language-plaintext highlighter-rouge">*</code>를 찾아 그 길이를 리턴해야 합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LPS</code>: 주어진 문자열의 가장 긴 접두어이자 접미어(Longest Prefix which is also Suffix)</li>
  <li>non-overlapping: 접두어와 접미어는 서로 겹치는 부분이 없어야 합니다. 다시 말해, prefix와 suffix는 문자열의 동일한 인덱스에 위치한 문자를 요소로 가지면 안 됩니다.</li>
</ul>

<h3 id="입력">입력</h3>
<hr />
<h4 id="인자-1--str">인자 1 : str</h4>
<ul>
  <li>string 타입의 임의의 알파벳 소문자 문자열</li>
  <li><code class="language-plaintext highlighter-rouge">str.length</code>는 60,000 이하</li>
</ul>

<h3 id="출력">출력</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code> 타입을 리턴해야 합니다.</li>
</ul>

<h3 id="주의사항">주의사항</h3>
<hr />
<ul>
  <li>prefix(접두어)는 문자열의 첫 인덱스부터 시작하는 모든 부분 문자열을 의미합니다.</li>
  <li>suffix(접미어)는 문자열의 마지막 인덱스부터 시작하는 모든 부분 문자열을 의미합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">LPS</span><span class="p">(</span><span class="dl">'</span><span class="s1">abbbcc</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 0</span>

<span class="nx">output</span> <span class="o">=</span> <span class="nx">LPS</span><span class="p">(</span><span class="dl">'</span><span class="s1">aaaa</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 2</span>
<span class="c1">// prefix: str.slice(0, 2)</span>
<span class="c1">// suffix: str.slice(2)</span>
<span class="c1">// non-overlapping 조건이 없는 경우 정답은 4 입니다.</span>

<span class="nx">output</span> <span class="o">=</span> <span class="nx">LPS</span><span class="p">(</span><span class="dl">'</span><span class="s1">aaaaa</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 2</span>
<span class="c1">// prefix: str.slice(0, 2)</span>
<span class="c1">// suffix: str.slice(3)</span>
<span class="c1">// non-overlapping 조건이 없는 경우 정답은 5 입니다.</span>
</code></pre></div></div>

<h3 id="advanced">Advanced</h3>
<hr />
<ul>
  <li>LPS를 계산하는 효율적인 알고리즘(O(N))이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.</li>
  <li>정규식(regular expression)을 활용하면 아래처럼 간단하게 구현할 수 있습니다. 정규식에 대해서 학습하시기 바랍니다. <a href="https://regexr.com/" target="_blank">(참고사이트)</a></li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">LPS</span> <span class="o">=</span> <span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^</span><span class="se">(\w</span><span class="sr">*</span><span class="se">)</span><span class="sr">.*</span><span class="se">\1</span><span class="sr">$/</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="toy-18-solution">TOY 18. Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr />
<p>만약 시간복잡도를 고려하지 않는 문제라면 난이도 0.1 … <del>이런 걸 의도하진 않겠지…</del></p>

<p>우선 Advanced 조건인 시간복잡도가 (<code class="language-plaintext highlighter-rouge">O(logK)</code>) 되기 위해서는 1번의 검색 수행마다 경우의 수가 절반으로 줄어야 한다.</p>

<h3 id="문제풀이">문제풀이</h3>
<hr />

<h4 id="1-bare-minimum">1. bare minimum</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getItemFromTwoSortedArrays</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO: 여기에 코드를 작성합니다.</span>
  
  <span class="kd">let</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">arr2</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">newArr</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">;</span>
  <span class="p">})</span>
  
  <span class="k">return</span> <span class="nx">result</span><span class="p">[</span><span class="nx">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div>
<p>시간복잡도를 전혀 고려하지 않았다…</p>
<h4 id="2-advanced">2. advanced</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
<h3 id="reference-code">Reference Code</h3>
<hr />
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// naive solution</span>
<span class="c1">// const getItemFromTwoSortedArrays = function (arr1, arr2, k) {</span>
<span class="c1">//   let cnt = 0,</span>
<span class="c1">//     left = 0,</span>
<span class="c1">//     right = 0;</span>
<span class="c1">//   let target;</span>
<span class="c1">//   while (cnt &lt; k) {</span>
<span class="c1">//     if (arr1[left] &lt; arr2[right]) {</span>
<span class="c1">//       target = arr1[left];</span>
<span class="c1">//       left++;</span>
<span class="c1">//     } else {</span>
<span class="c1">//       target = arr2[right];</span>
<span class="c1">//       right++;</span>
<span class="c1">//     }</span>
<span class="c1">//     cnt++;</span>
<span class="c1">//   }</span>
<span class="c1">//   return target;</span>
<span class="c1">// };</span>

<span class="c1">// O(logK) solution</span>
<span class="kd">const</span> <span class="nx">getItemFromTwoSortedArrays</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">leftIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nx">rightIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 이진 탐색을 위해 각 배열에서 k를 절반으로 쪼개서 카운트 한다.</span>
    <span class="kd">let</span> <span class="nx">cnt</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">k</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">leftStep</span> <span class="o">=</span> <span class="nx">cnt</span><span class="p">,</span>
      <span class="nx">rightStep</span> <span class="o">=</span> <span class="nx">cnt</span><span class="p">;</span>

    <span class="c1">// 엣지 케이스</span>
    <span class="c1">// 카운트가 남았음에도 배열의 끝에 도달하면 k를 나머지 배열쪽으로 넘긴다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">leftIdx</span> <span class="o">===</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">rightIdx</span> <span class="o">=</span> <span class="nx">rightIdx</span> <span class="o">+</span> <span class="nx">k</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">rightIdx</span> <span class="o">===</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">leftIdx</span> <span class="o">=</span> <span class="nx">leftIdx</span> <span class="o">+</span> <span class="nx">k</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 엣지 케이스</span>
    <span class="c1">// 현재 카운트가 남아있는 후보 요소들보다 많을 경우, leftStep(현재 할당량)을 남아있는 요소들의 개수로 바꾼다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cnt</span> <span class="o">&gt;</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">leftIdx</span><span class="p">)</span> <span class="nx">leftStep</span> <span class="o">=</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">leftIdx</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cnt</span> <span class="o">&gt;</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">rightIdx</span><span class="p">)</span> <span class="nx">rightStep</span> <span class="o">=</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">rightIdx</span><span class="p">;</span>

    <span class="c1">// 두 배열의 현재 검사 요소 위치를 비교해서, 그 값이 작은 배열은 비교한 위치 앞에 있는 요소들을 모두 후보군에서 제외시킨다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">leftIdx</span> <span class="o">+</span> <span class="nx">leftStep</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">rightIdx</span> <span class="o">+</span> <span class="nx">rightStep</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">leftIdx</span> <span class="o">=</span> <span class="nx">leftIdx</span> <span class="o">+</span> <span class="nx">leftStep</span><span class="p">;</span>
      <span class="c1">// 처리가 끝나면 k값을 절반으로 떨어뜨린다.</span>
      <span class="nx">k</span> <span class="o">=</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">leftStep</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">rightIdx</span> <span class="o">=</span> <span class="nx">rightIdx</span> <span class="o">+</span> <span class="nx">rightStep</span><span class="p">;</span>
      <span class="nx">k</span> <span class="o">=</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">rightStep</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">leftMax</span> <span class="o">=</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">leftIdx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="nx">rightMax</span> <span class="o">=</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">rightIdx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">leftMax</span><span class="p">,</span> <span class="nx">rightMax</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>
<h2 id="오늘-느낀-점">오늘 느낀 점</h2>

<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>TOY 19. LPS</li>
</ul>
:ET