I";$<p><img src="https://user-images.githubusercontent.com/83164003/127775612-7464075f-89e7-478e-82ee-dc1c2710a125.jpeg" alt="TIL" /></p>
<h2 id="today-i-learnd">Today I Learnd</h2>
<h3 id="1-인터넷-프로토콜">1. 인터넷 프로토콜</h3>
<hr />

<h4 id="1-1-ip와-ip-packet">1-1. IP와 IP Packet</h4>
<hr />
<ul>
  <li>
    <p>IP 패킷에서 패킷은 pack과 bucket이 합쳐진 단어로 소포로 비유할 수 있다. IP 패킷은 우체국 송장처럼 전송 데이터를 무사히 전송하기 위해 출발지 IP, 목적지 IP와 같은 정보가 포함되어 있으며 데이터를 전달하는 통신의 단위이다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138825068-009e4ba1-8fda-4b99-a212-807c3e789a45.png" alt="스크린샷, 2021-10-26 16-00-27" /></p>
  </li>
  <li><strong>클라이언트 패킷 전달</strong> 과정을 살펴보면 다음과 같다.
    <ul>
      <li>클라이언트가 IP 패킷을 인터넷 상의 노드에 던진다.</li>
      <li>인터넷 상의 노드(컴퓨터)들은 모두 IP 프로토콜을 따르기 때문에 해당 패킷의 정보(출발지, 목적지)를 이해할 수 있다.</li>
      <li>중간 노드들은 목적지 노드가 어디있는지 서로 물어가면서 해당 패킷을 전달한다. (라우팅 과정)</li>
    </ul>

    <p>위 과정을 통해 복잡한 인터넷 망 사이에서도 정확한 목적지로 패킷을 전송할 수 있다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843412-075e4290-60f1-4dab-9c6c-ebcbdceb3c46.png" alt="스크린샷, 2021-10-26 17-44-49" /></p>
  </li>
  <li>
    <p><strong>서버 패킷 전달</strong> 과정또한 클라이언트와 마찬가지로 이뤄지며, 패킷 단위 데이터로 통신이 이뤄진다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843489-1b89909f-3b7f-45a4-8102-7b26d702c491.png" alt="스크린샷, 2021-10-26 17-45-57" /></p>
  </li>
</ul>

<hr />
<h5 id="ip-프로토콜-한계">IP 프로토콜 한계</h5>
<ul>
  <li>정확한 출발지와 목적지를 파악할 수 있다는 점에서 IP 프로토콜은 적절한 통신 방법으로 보이지만 단점도 명확하다.
    <ul>
      <li><strong>비연결성</strong> : 만약 패킷을 받을 대상이 없거나 서비스 불능 상태여도 클라이언트는 서버의 상태를 파악할 방법이 없기 때문에 패킷을 그대로 전송하게 된다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843593-38235e14-8e51-4d3e-b6cf-1176fb6b2a88.png" alt="스크린샷, 2021-10-26 17-46-25" /></p>
    <ul>
      <li><strong>비신뢰성</strong> : 중간에 있는 서버가 데이터를 전달하던 중 장애가 생겨 패킷이 중간에 소실되더라도 클라이언트는 이를 파악할 방법이 없다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843686-c69809c1-7bfd-4e2f-8692-51e82a11904f.png" alt="스크린샷, 2021-10-26 17-46-59" /></p>
    <ul>
      <li>
        <p><strong>비신뢰성(패킷 전달 순서 문제)</strong> : 전송하려는 패킷의 용량이 매우 큰 경우 (대략 1500Byte 정도가 넘으면 해당 내용을 끊어서 보낸다), 이러한 경우 전송하려는 패킷들의 순서가 중요하다.</p>

        <p>그러나 IP프로토콜에서는 하나의 데이터에 연관된 패킷들이 각각 다른 경로로 전송될 수 있다. 따라서 도착하는 순서도 보장되지 않는다.</p>

        <p><img src="https://user-images.githubusercontent.com/83164003/138843811-620d17a3-5d7c-48e2-9b5e-8514afb46c66.png" alt="스크린샷, 2021-10-26 17-47-33" /></p>
      </li>
    </ul>
  </li>
</ul>

<hr />
<h4 id="1-2-tcp--udp">1-2. TCP / UDP</h4>
<ul>
  <li>
    <p>네트워크 프로토콜 계층은 다음과 같이 OSI 7계층과 TCP/IP 4 계층으로 나눌 수 있다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138831221-93740d56-e01a-4a86-ad31-4e0ecf309f6c.PNG" alt="osi7" /></p>

    <p>IP 프로토콜 보다 더 높은 계층에 TCP 프로토콜이 존재하기 때문에 앞서 다룬 IP 프로토콜에서 발생했던 수많은 문제들(패킷의 순서가 꼬이고, 유실되는 등의 문제)을 TCP 프로토콜이 해결해준다.</p>
  </li>
  <li>
    <p>우선 FLOW CHART를 보면 다음과 같다.</p>

    <p><img src="https://user-images.githubusercontent.com/83164003/138843963-4d1975f0-d6af-423b-91ae-40063ecb1884.png" alt="스크린샷, 2021-10-26 17-48-27" /></p>

    <ul>
      <li>응용프로그램이 HTTP 프로토콜을 통하여 ‘Hello World’ 메시지 생성함.</li>
      <li>SOCKET 라이브러리를 통해 OS계층에 HTTP 메시지 전달됨.</li>
      <li>TCP Layer 에서는 Hello, world 메시지에 TCP 세그먼트를 씌운다.</li>
      <li>TCP 세그먼트가 씌워진 HTTP 메세지를 IP 계층으로 전달(받은 메시지 위에 또 IP와 관련된 데이터들을 씌운다). ➡ TCP/IP 패킷이 생성됨.</li>
      <li>이렇게 생성된 TCP/IP 패킷은 LAN 카드와 같은 물리적 계층을 지나기 위해 이더넷 프레임 워크에 포함되어 서버로 전송함.</li>
    </ul>

    <blockquote>
      <p>TCP 세그먼트란?</p>

      <p><img src="https://user-images.githubusercontent.com/83164003/138846259-8a7c7f61-98be-42f3-bc5b-b5bedb174451.png" alt="스크린샷, 2021-10-26 18-01-14" /></p>

      <p>TCP 세그먼트에는 IP 패킷의 출발지 IP와 목적지 IP 정보를 보완할 수 있는 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등을 포함한다. ➡ IP에서 해결이 안되었던 순서 제어문제 등이 해결된다.</p>
    </blockquote>
  </li>
</ul>

<hr />
<h5 id="tcp-특징">TCP 특징</h5>
<ul>
  <li>전송 제어 프로토콜(Transmission Control Protocol) 이다. 다음과 같은 특징을 갖기 때문에 TCP는 같은 계층에 속한 UDP에 비해 상대적으로 신뢰할 수 있는 프로토콜이며, 현재 대부분 TCP를 사용한다.
    <ul>
      <li><strong>연결 지향 - TCP 3 way handshake (가상 연결)</strong> : <a href="https://www.sciencedirect.com/topics/computer-science/three-way-handshake" target="_blank">링크</a> 참조.</li>
      <li><strong>데이터 전달 보증 (패킷 소실 문제 해결)</strong> : TCP는 데이터 전송이 성공적으로 이루어진다면 이에 대한 응답을 돌려주기 때문에 IP 패킷의 한계인 비연결성을 보완이 가능하다.</li>
      <li><strong>순서 보장 (패킷 순서 문제 해결)</strong> : TCP는 패킷이 순서대로 도착하지 않는다면 TCP 세그먼트에 있는 정보를 토대로 다시 패킷 전송을 요청할 수 있다. 이를 통해 IP 패킷의 한계인 비신뢰성(순서를 보장하지 않음)을 보완할 수 있게된다.</li>
    </ul>
  </li>
</ul>

<hr />
<h5 id="udp-특징">UDP 특징</h5>
<ul>
  <li>사용자 데이터그램 프로토콜(User Datagram Protocol) 이다. UDP는 IP 프로토콜에 PORT, 체크섬 필드 정보만 추가된 단순한 프로토콜이다.
    <ul>
      <li><strong>비 연결 지향</strong> : 3 way handshake 방식을 사용하지 않기 때문에 TCP와 비교해 빠른 속도를 보장한다.</li>
    </ul>

    <blockquote>
      <p>체크섬(checksum)은 중복 검사의 한 형태로, 오류 정정을 통해, 공간(전자 통신)이나 시간(기억 장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법이다.</p>
    </blockquote>
  </li>
  <li>HTTP3는 UDP를 사용하며, 이미 여러 기능이 구현된 TCP 보다는 하얀 도화지처럼 커스터마이징이 가능하다는 장점이 있다.</li>
</ul>

<hr />
<h4 id="1-3-http">1-3. HTTP</h4>
<ul>
  <li>HTTP(HyperText Transfer Protocol)는 W3 상에서 정보를 주고받을 수 있는 프로토콜이다. 주로 TCP를 사용하고 HTTP/3 부터는 UDP를 사용하고 있다.</li>
  <li>HTTP는 다음과 같은 특징을 갖는다.
    <ul>
      <li>
        <p><strong>클라이언트 서버 구조</strong> : 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조이다.</p>

        <p><img src="https://user-images.githubusercontent.com/83164003/138867669-7a214209-dd9a-4900-ae20-789a74310f60.png" alt="스크린샷, 2021-10-26 20-18-58" /></p>
      </li>
      <li><strong>무상태 프로토콜(Stateless)</strong> : HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜이다. (무상태성을 보완하기 위하여 나온게 브라우저 상태를 유지할 수 있게 하는 쿠키, 세션, 토큰.. 등 이다.)</li>
      <li><strong>비연결성(Connectionless)</strong> : 비 연결성을 가지는 HTTP에서는 실제로 요청을 주고 받을 때만 연결을 유지하고, 응답을 주고나면 TCP/IP 연결을 끊는다. 이를 통해 최소한의 자원으로 서버 유지를 가능하게 한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="오늘-느낀-점">오늘 느낀 점</h2>

<p><br />
<br /></p>

<h2 id="내일-할-일">내일 할 일</h2>
<ul>
  <li>[GIT] 브랜치 관리와 고급기능</li>
</ul>
:ET