---
title: "[Algorithm] TOY 8. largestProductOfThree"
category: Algorithm
excerpt: "[Algorithm] TOY 8. largestProductOfThree"
---

![algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 8. largestProductOfThree
### 문제
---
정수를 요소로 갖는 배열을 입력받아 3개의 요소를 곱해 나올 수 있는 최대값을 리턴해야 합니다.



### 입력
---
#### 인자 1 : arr
- `number` 타입을 요소로 갖는 임의의 배열

### 출력
---
- `number` 타입을 리턴해야 합니다.

### 주의사항
---
- 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.
- 배열의 요소는 음수와 0을 포함하는 정수입니다.
- 배열의 길이는 3 이상입니다.

### 입출력 예시
---
```javascript
let output = largestProductOfThree([2, 1, 3, 7]);
console.log(output); // --> 42 (= 2 * 3 * 7)

output = largestProductOfThree([-1, 2, -5, 7]);
console.log(output); // --> 35 (= -1 * -5 * 7)
```


## TOY 8. Solution
### 수도코드
---
1. 길이가 3 이상인 배열을 내림차순으로 정렬하여 arr[0] 인덱스엔 가장 큰값 ~ arr[2]인덱스엔 3번째로 큰 값을 배치한다.
2. 내림차순으로 정렬된 가장 큰 값과 가장 작은 두 수 곱의 합 (arr[0]이 가장 큰 양수값이고, arr[last-1] arr[last]값이 가장 작은 음수값 2개라면 가장 큰 경우의 수가 될 수 있다.)
3. 내림차순으로 정렬된 0~2번 인덱스 요소의 순차적인 곱의 합
4. 2-1번과 2-2번의 결과 값을 비교하여 더 큰 경우의 값을 리턴한다

### 문제풀이
---
```javascript
const largestProductOfThree = function (arr) {
  arr.sort((a,b)=>(b-a));  // 내림차순 sort()

  const case1 = arr[0]*arr[arr.length-2]*arr[arr.length-1];  // 수도코드 2번 경우
  const case2 = arr[0]*arr[1]*arr[2]; // 수도코드 3번 경우

  return case1>case2 ? case1 : case2;  // 3항 연산자로 결과값 출력
}
```
### Reference Code
---
```javascript
const largestProductOfThree = function (arr) {
  const sorted = arr.slice().sort((a, b) => a - b);
  const len = arr.length;
  const candi1 = sorted[len - 1] * sorted[len - 2] * sorted[len - 3];
  const candi2 = sorted[len - 1] * sorted[0] * sorted[1];
  return Math.max(candi1, candi2);
};
```
## 오늘 느낀 점
- Reference Code가 확실히 간결하고 코드가 말하고자 하는 바를 명시적으로 표현한듯하다. 
- slice()로 배열을 복사한건 왜일까..?  물론 하면 좋지만 딱히 중요한 포인트는 아닌듯 하다. 
- `Math.max`를 이용하여 최대값을 리턴하는 방법은 신선했다. 조건문이나...삼항조건연산자로만 풀 생각하였었고, 나름 간결한 문장이라 생각했는데 만약 경우의 수가 2개 이상이었다면 내 코드는 더 복잡해졌을꺼다.

## 내일 할 일
- TOY 9. power
