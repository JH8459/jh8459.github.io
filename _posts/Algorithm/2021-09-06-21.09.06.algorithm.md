---
title: "[Algorithm] TOY 10. binarySearch"
category: Algorithm
excerpt: "[Algorithm] TOY 10. binarySearch"
---

![algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 10. binarySearch
### 문제
---
오름차순 정렬된 정수의 배열(`arr`)과 정수(`target`)를 입력받아 `target`의 인덱스를 리턴해야 합니다.



### 입력
---
#### 인자 1 : arr
- `number` 타입을 요소로 갖는 임의의 배열
-  `arr[i]` 는 정수

#### 인자 2 : target
- `number` 타입의 정수

### 출력
---
- `number` 타입을 리턴해야 합니다.

### 주의사항
---
- **이진탐색 알고리즘**(`O(logN)`)을 사용해야 합니다.
- 단순한 배열 순회(`O(N)`)로는 통과할 수 없는 테스트 케이스가 존재합니다.
- `target`이 없는 경우, `-1`을 리턴해야 합니다.

### 입출력 예시
---
```javascript
let output = binarySearch([0, 1, 2, 3, 4, 5, 6], 2);
console.log(output); // --> 2

output = binarySearch([4, 5, 6, 9], 100);
console.log(output); // --> -1
```


## TOY 10. Solution
### 수도코드
---
- 이진탐색트리 특성상 정렬된 값들을 중위순회로 탐색한다. 

  `target`과 `node`의 값이 작거나,같거나,클 경우의 경우를 조건분기로 나누어 이진탐색트리와 같은 탐색방법을 알고리즘으로 구현한다.

1. `target`이 없는 경우 (includes.., indexOf 등으로 target 값이 배열에 존재하는지 탐색). `-1`을 리턴해주는 조건분기 설정
2.  최초 탐색할 `중간` idx 설정. 해당 idx 기준으로 탐색 시작.
3.  `arr[중간]` 값과 `target`비교 하여 같은 경우 탐색종료 해당 idx 값 반환
4.   `arr[중간]` 값과 `target`비교 하여 클 경우 `중간` idx 우측 남은값(`arr[중간+1] ~ arr[length-1]`)을 바탕으로 재귀 실행, 
5.   작을 경우 `중간` idx 좌측 남은값 바탕으로 재귀 실행
6.  이진탐색트리의 시간복잡도에 알맞는 계산방식으로 구현

### 문제풀이
---
```javascript 
const binarySearch = function (arr, target) {
  // 이진탐색 (binary search)은 탐색범위의 절반을 기준으로 
  // target과 확인한 후 그 절반값보다 큰 곳 또는 작은 곳을 다음 탐색범위로 잡아가는 탐색방법
  if(!arr.includes(target)) { return -1; } // target이 arr배열에 없다면 -1 리턴
  
  const idxCenter = Math.floor(arr.length/2); // 중간 인덱스 설정

  if(arr[idxCenter]===target) { return idxCenter; } // arr[중간인덱스] === target과 같다면, rootNode 가 타겟인 경우이다.

  const recArr = arr[idxCenter] > target ? // arr[중간인덱스] > target이 크다면 root의 좌측으로 탐색이 진행되야함
    arr.slice(0,idxCenter) : // recArr = 중간인덱스 기준, 좌측 slice
    arr.slice(idxCenter+1); // recArr = 중간인덱스 기준, 우측 slice
  
  return binarySearch(recArr,target);  // 재귀 호출
};
```
### Reference Code
---
```javascript
const binarySearch = function (arr, target) {
  let left = 0,
    right = arr.length - 1;
  while (left <= right) {
    let middle = parseInt((right + left) / 2);
    if (arr[middle] === target) {
      return middle;
    }
    if (target < arr[middle]) {
      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }
  return -1;
};
```
## 오늘 느낀 점
- 일단 틀렸다. 시간복잡도에 대한 내용에서 에러가 잡힌다. 
- 우선 `빅-오 표기법` 중 `O(logN)` 의 시간복잡도는 연산과정이 절반씩 줄어들 경우인건 확실히 인지하였다. 

  자세한 내용은 해당 블로그 내용참조 : <a href="https://jwoop.tistory.com/9" target="_blank">https://jwoop.tistory.com/9</a>
	
  재귀를 통하여 전달하는 `arr`의 길이를 절반씩 줄였기 때문에 `O(logN)`을 만족한다 생각하였는데 시간복잡도를 만족못한다는 에러가 발생한다. 우선 해당내용의 질의를 아고라스테이츠에 문의를 넣어둔 상황이니 지켜본 뒤 내일 다시 포스팅을 이어나갈 예정이다.
- ~~(작성중)~~

## 내일 할 일
- TOY 6. sudoku
- TOY 11. powerSet
