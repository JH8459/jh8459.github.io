---
title: TOY 13. insertionSort
excerpt: "[Algorithm] TOY 13. insertionSort"
category: Algorithm
sidebar:
  nav: docs
---

![Algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 13. insertionSort
### 문제
---
정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.



### 입력
---
#### 인자 1 : arr
- `number` 타입을 요소로 갖는 배열
- `arr[i]`는 정수
- `arr.length`는 1,000 이하

### 출력
---
- `number` 타입을 요소로 갖는 배열을 리턴해야 합니다.
- 배열의 요소는 오름차순으로 정렬되어야 합니다.
- `arr[i] <= arr[j]` (`i < j`)

### 주의사항
---
- **삽입 정렬**을 구현해야 합니다.
- `arr.sort` 사용은 금지됩니다.
- 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.

### 입출력 예시
---
```javascript
let output = insertionSort([3, 1, 21]);
console.log(output); // --> [1, 3, 21]
```

### Advanced
---

- insertionSort 함수의 두 번째 인자로 callback 함수를 받아서, 그 함수의 리턴값을 기준으로 요소들을 정렬해 보세요.

## TOY 13. Solution
### 수도코드
---
![Insertion_sort_001](https://user-images.githubusercontent.com/83164003/132718182-d4134d7b-c117-4e4a-af8b-0b4cf3fdb908.png)

1. 반복문을 수행하며 `arr[1]` 부터 정렬 시작
2. 정렬 할 값 기준으로 좌측은 이중 반복문을 순회 하며 자기 자신의 위치를 찾는다
3. Advance... 문제 이해가 안간다. 콜백?  

### 문제풀이
---
```javascript 
const insertionSort = function (arr) {
  // TODO: 여기에 코드를 작성합니다.
  for(let i = 1 ; i < arr.length ; i++){ 
      let temp = arr[i]; // 비교할 대상
      let prev = i - 1;  // 비교할 대상 좌측 마지막 index

      while( (prev >= 0) && (arr[prev] > temp) ) {   
        // 좌측 index 값이 0보다 클때, 그리고 비교 대상보다 이전 인덱스 배열 값이 클때 반복문 수행
         arr[prev+1] = arr[prev]; // 현재 temp 자리에 arr[prev]를 넣는다.
         prev--; // 증감식
      }

      arr[prev + 1] = temp; // prev자리에 temp를 넣는다.
   }
   
   return arr;
};
```
### Reference Code
---
```javascript
const insertionSort = function (arr, transform = (item) => item) {
  let sorted = [arr[0]];
  for (let i = 1; i < arr.length; i++) {
    if (transform(arr[i]) >= transform(sorted[i - 1])) {
      sorted.push(arr[i]);
    } else {
      for (let j = 0; j < i; j++) {
        if (transform(arr[i]) <= transform(sorted[j])) {
          const left = sorted.slice(0, j);
          const right = sorted.slice(j);
          sorted = left.concat(arr[i], right);
          break;
        }
      }
    }
  }

  return sorted;
};
```
## 오늘 느낀 점
- Reference Code 를 보니 배열의 기존 값을 해치지 않았다. `sorted` 변수를 선언하여, `slice`로 배열 값을 복사하여 썼다.  나는 원 배열을 수정하는 mutable 한 방식을 썼기에 나중에 코드 이식성등을 고려하면 알맞는 코드는 아니다. 다시 풀어봐야 할 듯 하다.

- ~~콜백 함수는 아직도 왜 쓴건진 모르겠다...~~ 아직 콜백 함수의 개념을 내가 잘 모르는건가? 주말중 을 이용하여 다시 풀어봐야할 문제중 하나이다.
- 그다지 .. 많이 쓰일 정렬 알고리즘은 아닌거 같다. 최악의 경우 시간복잡도는 `O(n^2)` 이며, 배열의 길이가 길수록 최악의 시간복잡도에 가까워 질 수 밖에 없는 구조이다. 배열의 길이가 짧은 경우, 코드의 길이가 길진 않고 쉽게 구현되는 만큼 짧은 길이의 배열에 적합해 보인다.
	
	
## 내일 할 일
- TOY 14. rotatedArraySearch
