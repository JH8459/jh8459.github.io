---
title: "[Algorithm] TOY 16. quickSort"
category: Algorithm
excerpt: "[Algorithm] TOY 16. quickSort"
---

![algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 16. primePassword
### 문제
---
정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.

### 입력
---
#### 인자 1 : arr
- `number` 타입을 요소로 갖는 배열
- `arr[i]`는 정수
- `arr.length`는 100,000 이하
### 출력
---
- `number` 타입을 요소로 갖는 배열을 리턴해야 합니다.
- 배열의 요소는 오름차순으로 정렬되어야 합니다.
- `arr[i]` <= `arr[j]` (`i < j`)


### 주의사항
---
- **퀵 정렬**을 구현해야 합니다.
- `arr.sort` 사용은 금지됩니다.
- 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.

### 입출력 예시
---
```javascript
let output = quickSort([3, 1, 21]);
console.log(output); // --> [1, 3, 21]
```

### Advanced
---
- quickSort 함수의 두 번째 인자로 callback 함수를 받아서, 그 함수의 리턴값을 기준으로 요소들을 정렬해 보세요.

## TOY 16. Solution
### 수도코드
---
![퀵정렬](https://user-images.githubusercontent.com/83164003/133280873-516a69e5-dafd-48f4-83ac-e1c3d39e4a3d.png)

퀵정렬의 개념은 구글링을 통해 잡았다. ~~뭔놈의 정렬 알고리즘이 이리 다양한지...~~

1. `arr[0]` 을 최초 기준점으로 `left`, `right` 두 배열에 대소 비교하여 arr 요소 push
2.  arr을 순회하며 완성된 `left` 와 `right` 배열 기준으로 다시 재귀 호출
3.  arr 이 더이상 정렬할게 없을때 (길이가 2 미만으로 내려갔다면) 재귀 호출 종료
4.  정렬이 완료된 배열을 `...` 스프레드 연산자 혹은 `concat`으로 풀어서 한 배열로 붙여서 리턴하여 함수 종료

메모리 관리가 효율적인 Advanced 알고리즘은 Reference Code 를 참조하였다.
### 문제풀이
---
```javascript 
const quickSort = function (arr) {
  // TODO: 여기에 코드를 작성합니다.
  if(arr.length < 2) return arr; // 재귀함수의 탈출 조건, 길이가 2보다 작다면 더이상 정렬할게 없다.
  
  let pivot = arr[0]; // pivot
  let left = []; // pivot 보다 작은 수가 담길 배열
  let right = []; // pivot 보다 큰 수가 담길 배열

  for(let i = 1; i < arr.length; i++){ //pivot 제외한 arr 요소 조회
    if(arr[i] < pivot){ // pivot과 비교하여 left, right로 분류
      left.push(arr[i])
    } else if(arr[i] > pivot){
      right.push(arr[i])
    }
  }

  // 재귀를 통해서 정렬 -> 한 배열로 붙여서 return
  return [...quickSort(left), pivot, ...quickSort(right)]
};
```
### Reference Code
---
```javascript
// naive solution
// const quickSort = function (arr) {
//   if (arr.length <= 1) return arr;

//   const pivot = arr[0];
//   const left = [];
//   const right = [];

//   for (let i = 1; i < arr.length; i++) {
//     if (arr[i] <= pivot) left.push(arr[i]);
//     else right.push(arr[i]);
//   }

//   const lSorted = quickSort(left);
//   const rSorted = quickSort(right);
//   return [...lSorted, pivot, ...rSorted];
// };

function quickSort(arr, transform = (item) => item) {
  if (arr.length <= 1) return arr;

  const pivot = arr[0];
  const left = [];
  const right = [];

  for (let i = 1; i < arr.length; i++) {
    if (transform(arr[i]) < transform(pivot)) left.push(arr[i]);
    else right.push(arr[i]);
  }

  const lSorted = quickSort(left, transform);
  const rSorted = quickSort(right, transform);
  return [...lSorted, pivot, ...rSorted];
}
```
## 오늘 느낀 점
효율적인 메모리를 위한 알고리즘에서는 더이상 진전이 없었다... 레퍼런스 코드가 왜 저렇게 구현되는지 잘 와닿지 않는다. 

TOY13번에서 개념을 잡지않고 우선 넘어갔는데 같은 유형의 문제가 다시 나왔다... 우선 무조건 공부하고 짚고넘어가야 할 듯해서 찾아본 결과, **꼬리재귀**를 공부해야 해당 부분을 깊게 이해 할 수 있다는 점 정도만 감을 잡았다. 재귀 스택이 쌓이는 과정에서의 오버헤드... 를 해결하는 알고리즘인듯하다.

> 함수를 재귀적으로 호출하여 문제를 해결하는 방식은 코드를 간결하고 의도를 파악하기 쉽게 작성할 수 있는 장점이 있다. 하지만 재귀함수의 콜스택이 깊어 질수록 메모리 오버헤드가 발생하는 단점도 있다. 이 문제를 해결하기 위한 재귀 호출 방식을 **꼬리 재귀**라고 부른다. 간단하게 정의하자면 재귀함수의 실행 결과가 연산에 사용되지 않고 바로 반환되게 함으로써 이전 함수의 상태를 유지할 필요가 없도록 재귀 함수를 작성하는 것이다.
	
시간이 늦어 오늘은 `sort()` 내장 메서드를 사용하지 않는 기본 알고리즘만 해결하고, 주말 추석 연휴중으로 **꼬리재귀** 에 대해서 학습해 볼 예정이다.
	
## 내일 할 일
- TOY 17. balancedBracket
