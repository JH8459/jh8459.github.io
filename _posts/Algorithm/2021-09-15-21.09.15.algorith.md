---
title: "[Algorithm] TOY 17. balancedBrackets"
category: Algorithm
excerpt: "[Algorithm] TOY 17. balancedBrackets"
sidebar:
  nav: docs
---

![algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 17. balancedBrackets
### 문제
---
문자열을 입력받아 문자열 내의 모든 괄호의 짝이 맞는지 여부를 리턴해야 합니다.

- 다음 단계에 맞춰 함수를 작성해 보세요
  1. 괄호의 종류를 단 한가지로 한정합니다.
  2. 괄호의 종류를 늘려 모든 종류의 괄호에도 작동하도록 합니다.
  3. 괄호를 제외한 문자열이 포함된 경우에도 작동하도록 합니다.

### 입력
---
#### 인자 1 : str
- `string` 타입의 괄호가 포함된 문자열

### 출력
---
- `boolean` 타입을 리턴해야 합니다.

### 주의사항
---
- 괄호의 종류는 `(, )`만 고려합니다.
- 괄호는 먼저 열리고(`(`), 열린만큼만 닫혀야(`)`) 합니다.
- 빈 문자열을 입력받은 경우, `true`를 리턴해야 합니다.

### 입출력 예시
---
```javascript
let output = balancedBrackets('(');
console.log(output); // // -> false

output = balancedBrackets('()');
console.log(output); // --> true
```

### Advanced
---
- 모든 종류의 괄호(`(, ), {, }, [, ]`)가 포함된 문자열을 입력빋아 모든 괄호의 짝이 맞는지 여부를 리턴해 보세요.

```javascript
let output = balancedBrackets('[](){}');
console.log(output); // --> true

output = balancedBrackets('[({})]');
console.log(output); // --> true

let output3 = balancedBrackets('[(]{)}');
console.log(output); // --> false
```


## TOY 17. Solution
### 수도코드
---
![괄호검사](https://user-images.githubusercontent.com/83164003/133451554-bb0d995a-0513-4d13-ab11-10cac4d2a416.png)

스택 자료구조를 이용하여 괄호를 쌓아가며, 쌍이 맞는 괄호가 나오면 위에서 부터 꺼내는 알고리즘을 구현해보았다.

1. 괄호로 구성된 문자열을 배열로 변환하여 반복문으로 해당 배열을 순회한다.
2. 시작부터 닫는 괄호가 나온다면 무조건 괄호 쌍이 일치하지 않으므로 `false`를 리턴한다.
3. `(`, `{`, `[` 여는 괄호가 나올 경우에는 `stack` 배열에 값을 넣어준다.
4. 닫는 괄호가 나오는 경우 `stack` 배열의 최상단의 값과 일치하는 괄호가 있는지 검사 -> 일치한다면 기존 `stack`배열에 쌓인 **쌍이 되는 여는 괄호**를 빼준다. 
5. 반복문이 종료된 후 `stack`배열이 비어있다면 괄호 쌍이 일치하므로 `true`를 리턴한다.
### 문제풀이
---

#### 1. bare minimum

```javascript 
const balancedBrackets = function (str) {
  // TODO: 여기에 코드를 작성합니다.
  const strArr = str.split('');
  let stack = [];  

  for(let el of strArr){
    if(el === '('){  // 여는 괄호가 나온다면 stack 배열에 값을 넣는다
      stack.push(el);
    } else {  // 닫는 괄호가 나온다면,
      if(stack.length === 0) return false;  // 닫는 괄호 + stack 의 길이가 0. 즉, 첫 시작부터 닫는 괄호가 나온다면 false 리턴
      
			if(stack[stack.length-1] === '('){  // 닫는 괄호 + stack의 마지막 인덱스가 여는 괄호라면 stack의 값을 뺀다.
        stack.pop();
      }
    }
  }

  return stack.length > 0 ? false : true;  // stack 배열이 비어있다면, 괄호 쌍이 일치하므로 true 리턴.
};
```

#### 2. advanced

```javascript
const balancedBrackets = function (str) {
  // TODO: 여기에 코드를 작성합니다.
  const array = str.split('');
  let stack = [];

  for (let el of array) {
    if (el === '{' || el === '[' || el === '(') {  // 여는 괄호가 나온다면 stack 배열에 값을 넣는다
      stack.push(el);
    } else {  // 닫는 괄호가 나온다면,
      if (stack.length === 0) return false;  // 닫는 괄호 + stack 의 길이가 0. 즉, 첫 시작부터 닫는 괄호가 나온다면 false 리턴

      // 닫는 괄호 + stack의 마지막 인덱스가 쌍이 맞는 여는 괄호라면 stack의 값을 뺀다.  
      if (el === '}' && stack[stack.length - 1] === '{') {  
        stack.pop();
      } else if (el === ']' && stack[stack.length - 1] === '[') {
        stack.pop();
      } else if (el === ')' && stack[stack.length - 1] === '(') {
        stack.pop();
      }
    }
  }

  return stack.length > 0 ? false : true; // stack 배열이 비어있다면, 괄호 쌍이 일치하므로 true 리턴.
};
```
### Reference Code
---
```javascript
// naive solution
// const balancedBrackets = function (str) {
//   const stack = [];
//   const opener = '(';
//   const closer = ')';

//   for (let i = 0; i < str.length; i++) {
//     if (str[i] === opener) {
//       stack.push(str[i]);
//     } else if (str[i] === closer) {
//       const top = stack.pop();
//       if (top !== opener) {
//         return false;
//       }
//     }
//   }

//   return stack.length === 0;
// };

const balancedBrackets = function (str) {
  const stack = [];
  const opener = {
    '{': '}',
    '[': ']',
    '(': ')',
  };
  const closer = '}])';

  for (let i = 0; i < str.length; i++) {
    if (str[i] in opener) {
      stack.push(str[i]);
    } else if (closer.includes(str[i])) {
      const top = stack.pop();
      const pair = opener[top];
      if (pair !== str[i]) {
        return false;
      }
    }
  }

  return stack.length === 0;
};
```
## 오늘 느낀 점
오늘 TOY 문제는 어렵지않았다. ~~다만 Reference Code 처럼 간결하진 않지만...~~


여는 괄호를 `opener` 객체로 분류하여 키와 값 쌍으로 결과를 도출해내는 과정이 코드가 멋스러웠다...  참조할만한 코드라 생각되어 다시 풀어볼 예정이다. 

오늘 스터디중 동기분이 보여주신 코드가 신기해서 가져와보았다. `reduce()`를 활용해 누산기를 스택으로 활용하는 알고리즘인데 아직 이해가 안간다.. ~~reduce() 아직 생소해...~~  해당 내용도 알아두면 좋을듯해서 우선 가져와보았다. TOY 문제 다시 풀때 참고해봐야겠다.

```javascript
const balancedBrackets = function (str) {
  // TODO: 여기에 코드를 작성합니다.
  let bList = { "(" : ")", "{" : "}", "[" : "]" } // 짝에 맞추어 키와 값으로 객체

  let stack = str.split('').reduce(function(ac, cv) { // str을 스플릿해 한글자씩 reduce함수를 돌린다
    if (cv === bList[ac[ac.length - 1]]) { // ac를 스택으로 사용
      ac.pop();
    } else {
      ac.push(cv);
    }
    return ac;
  }, []);

  return stack.length === 0 // 스택에 남아 있는 요소가 없다면 짝이 맞는!
};
```
	
## 내일 할 일
- TOY 18. getItemFromTwoSortedArrays
