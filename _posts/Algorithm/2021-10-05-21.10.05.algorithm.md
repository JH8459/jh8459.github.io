---
title: TOY 23. spiralTraversal
category: Algorithm
excerpt: "[Algorithm] TOY 23. spiralTraversal"
sidebar:
  nav: docs
---

![Algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 23. spiralTraversal
### 문제
---
2차원 M x N 배열을 나선형(spiral)으로 순회해야 합니다.
### 입력
---
#### 인자 1 : matrix
- 세로 길이(`matrix.length`)가 M, 가로 길이(`matrix[i].length`)가 N인 2차원 배열
- `matrix[i]`는 `string` 타입을 요소로 갖는 배열
- `matrix[i][j].length`는 1

### 출력
---
- `string` 타입을 리턴해야 합니다.

### 입출력 예시
---
```javascript
let matrix = [
  ['A', 'B', 'C'],
  ['D', 'E', 'F'],
  ['G', 'H', 'I'],
];
let output = spiralTraversal(matrix);
console.log(output); // --> 'ABCFIHGDE'

matrix = [
  ['T', 'y', 'r', 'i'],
  ['i', 's', 't', 'o'],
  ['n', 'r', 'e', 'n'],
  ['n', 'a', 'L', ' '],
];
output = spiralTraversal(matrix);
console.log(output); // --> 'Tyrion Lannister'
```
## TOY 23. Solution
### 수도코드
---
상단, 우측, 하단, 좌측 돌려가며 `matrix`를 깎으(?)면서 배열에 담긴 값을 `result`에 넣어주면 언젠가는 `matix`가 빈 배열로 남게된다.  해당 네가지 과정을 담은 함수들을 작성해준다.

spiralTraversal 메인 함수에서는 `matrix`가 모두 깎인(?) 빈 배열의 상태가 될때까지 반복으로 해당 과정들을 수행해준다.

### 문제풀이
---
```javascript
// 매트릭스 상단 순서대로 result 담는 함수
const insertTop = (matrix, result) => {  
  for(let el of matrix[0]){
    result += el;
  }
  matrix.shift();  // 상단(윗변) 삭제
  return result;
}

// 매트릭스 우측 순서대로 result 담는 함수
const insertRight = (matrix, result) => {
  for(let i=0; i<matrix.length; i++){
    let char = matrix[i].pop();  // 우측 한글자씩 삭제 후 변수에 담아 리턴한다
    result += char;
  }
  return result;
}

// 매트릭스 하단 순서대로 result 담는 함수
const insertBottom = (matrix, result) => {
  matrix[matrix.length-1].reverse(); // 하단(아랫변)은 상단과 다르게 역순으로 담긴다.
  for(let el of matrix[matrix.length-1]){
    result += el;
  }
  matrix.pop();  // 하단(아랫변) 삭제
  return result;
}

// 매트릭스 좌측 순서대로 result 담는 함수
const insertLeft = (matrix, result) => {
  for(let i=matrix.length-1; i>=0; i--){
    let char = matrix[i].shift();  // 좌측 한글자씩 삭제 후 변수에 담아 리턴한다
    result += char;
  }
  return result
}

const spiralTraversal = function (matrix) {
  let result = '';

  while(true){
    result = insertTop(matrix,result);
    if(matrix.length === 0) break;  // 반복문이 끝나는 조건은 상단 혹은 하단 삭제 후 matrix가 모두 비어버리는 경우이다.
    result = insertRight(matrix,result);
    result = insertBottom(matrix,result);
    if(matrix.length === 0) break;
    result = insertLeft(matrix,result);
  }

  return result;
};
```
--- 

**Reference Code**
```javascript
const spiralTraversal = function (matrix) {
  // 각 방향마다 row와 col의 변화를 저장
  const RIGHT = [0, 1];
  const DOWN = [1, 0];
  const LEFT = [0, -1];
  const UP = [-1, 0];
  // 각 방향을 위한 lookup table
  const MOVES = [RIGHT, DOWN, LEFT, UP];
  const M = matrix.length;
  const N = matrix[0].length;
  const isValid = (row, col) => row >= 0 && row < M && col >= 0 && col < N;

  let cnt = 0;
  let row = 0,
    col = -1;
  let direction = 0;
  let result = '';
  while (cnt < M * N) {
    const move = MOVES[direction];
    const [rd, cd] = move;

    row = row + rd;
    col = col + cd;
    while (isValid(row, col) && matrix[row][col] !== false) {
      result = result + matrix[row][col];
      // 한 요소를 두 번 접근하지 않게 하기 위해서, 접근된 요소를 false로 변경한다.
      matrix[row][col] = false;
      row = row + rd;
      col = col + cd;
      cnt++;
    }
    // row, col 이 행렬의 범위를 벗어났기 때문에,
    // 진행된 방향의 반대로 한 칸 이동한다.
    row = row - rd;
    col = col - cd;

    // 각 방향이 순환되기 때문에 모듈러 연산을 사용한다.
    direction = (direction + 1) % 4;
  }
  return result;
};
```

## 오늘 느낀 점
레퍼런스 코드는 길찾기 알고리즘과 비슷한 메커니즘으로 문제를 해결하였다. 여러가지 함수를 만들지 않고 방향성을 갖고 `[0,0]` 인덱스부터 나선형으로 돌며 모든 배열의 인덱스를 순회하는 알고리즘으로 깔끔히 구현하였다. 

해당 길찾기(?) 알고리즘은 눈에 익혀두어야 겠다.

## 내일 할 일
- TOY 24. radixSort
