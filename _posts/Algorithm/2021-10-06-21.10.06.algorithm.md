---
title: "[Algorithm] TOY 24. radixSort"
category: Algorithm
excerpt: "[Algorithm] TOY 24. radixSort"
sidebar:
  nav: docs
---

![algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 24. radixSort
### 문제
---
정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.
### 입력
---
#### 인자 1 : arr
- `number` 타입을 요소로 갖는 배열
- `arr[i]`는 0 이상의 정수
- `arr.length` 100,000 이하

### 출력
---
- `number` 타입을 요소로 갖는 배열을 리턴해야 합니다.
- 배열의 요소는 오름차순으로 정렬되어야 합니다.
- `arr[i] <= arr[j]` (`i < j`)

### 주의사항
---
- **기수 정렬**을 구현해야 합니다.
- `arr.sort` 사용은 금지됩니다.
- 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.

### 입출력 예시
---
```javascript
let output = radixSort([3, 1, 21]);
console.log(output); // --> [1, 3, 21]
```

### 힌트
---
- 기수 정렬(radix sort)은 내부적으로 계수 정렬(counting sort)을 사용합니다.
- 계수 정렬을 먼저 학습하고, 어떤 경우에 기수 정렬을 사용하는지 학습하도록 합니다.


### Advanced
---
- `arr[i]`의 범위가 정수 전체로 확대될 경우, 기수 정렬 알고리즘을 완성해 보세요.


## TOY 24. Solution
### 수도코드
---

**기수정렬** 이란?
- 정렬할 원소의 키값에 해당하는 버킷에 원소를 분배하였다가 버킷의 순서대로 원소를 꺼내는 방법이다.
- 원소의 키를 표현하는 값의 기수만큼 버킷이 필요하다.
- 키 값의 길이만큼 기수 정렬을 반복한다.
- 반복 횟수는 매개변수의 배열의 요소 중 최댓값의 길이이다.

![스크린샷, 2021-11-03 00-31-01](https://user-images.githubusercontent.com/83164003/139878433-78137a08-0de8-4af6-90a7-d57ea1ff9366.png)
![스크린샷, 2021-11-03 00-31-15](https://user-images.githubusercontent.com/83164003/139878437-337ed9e0-0c3c-41e9-b985-c1f0f69e8c81.png)
![스크린샷, 2021-11-03 00-31-24](https://user-images.githubusercontent.com/83164003/139878441-8efaba1f-ba08-4ca6-a266-b24c4c66a9c7.png)
![스크린샷, 2021-11-03 00-31-35](https://user-images.githubusercontent.com/83164003/139878443-9801550b-d9cf-493e-a373-721a0eabd33d.png)

### 문제풀이
---
```javascript

```
--- 

**Reference Code**
```javascript
/* const arr = [3, 1, 21] */

function getMax(arr) {
  return arr.reduce((max, item) => {
    if (item > max) return item;
    return max;
  }, 0);
} // 배열에서 최대값 색출

function countingSort(arr, radix) { // arr = [3,1,21], radix = 1 (자릿수)
  const N = arr.length; // arr의 길이 3
  const output = Array(N).fill(0); // [0,0,0]
  const count = Array(10).fill(0); // [0,0,0,0,0,0,0,0,0,0]

  // 현재 자리수를 기준으로 0~9의 개수를 센다.
  arr.forEach((item) => {
    const idx = Math.floor(item / radix) % 10;
    count[idx]++; // [0,2,0,1,0,0,0,0,0,0]
  });

  // count[i]가 i까지의 누적 개수가 되도록 만든다.
  count.reduce((totalNum, num, idx) => {
    count[idx] = totalNum + num;
    return totalNum + num;
  });// [0,2,2,3,3,3,3,3,3,3]

  // 아래 속성이 유지되도록 하기 위해 배열을 거꾸로 순회한다.
  //  1. 가장 큰 값을 먼저 본다.
  //  2. 가장 큰 값을 가장 마지막에 놓는다.
  let i = N - 1;
  while (i >= 0) {
    const idx = Math.floor(arr[i] / radix) % 10;
    // count[idx]: 현재 radix의 idx까지 누적 개수
    // count[idx]개만큼 있으므로, 인덱스는 count[idx] - 1
    output[count[idx] - 1] = arr[i];
    count[idx] -= 1;
    i--;
  }

  return output; // [1,21,3]
}

// naive solution
// 양의 정수만 정렬 가능
// function radixSort(arr) {
//   const max = getMax(arr);
//   let radix = 1;
//   while (parseInt(max / radix) > 0) {
//     arr = countingSort(arr, radix);
//     radix *= 10;
//   }
//   return arr;
// }

// 음의 정수를 포함한 기수 정렬
// 1. 주어진 배열을 음수 부분과 양수 부분으로 나눈다.
// 2. 음수는 절대값을 기준으로, 즉 양수로 변환하여 기수 정렬한다.
// 3. 양수를 정렬한다.
// 4. 정렬된 음수 부분을 다시 음수로 바꾸고 순서를 뒤짚는다.
// 5. 음수 부분과 양수 부분을 붙인다.
function radixSort(arr) {
  let left = [];
  let right = [];
  arr.forEach((item) => {
    if (item >= 0) right.push(item);
    else left.push(item * -1);
  }); // 양수면 오른쪽에 음수면 양수로 바꿔서 왼쪽에 넣어준다.

  let max = getMax(left); // 왼쪽의 최대값 구하기
  let radix = 1;
  while (parseInt(max / radix) > 0) {
    left = countingSort(left, radix);
    radix *= 10;
  } // 왼쪽 정렬

  max = getMax(right); // 오른쪽의 최대값 구하기
  radix = 1;
  while (parseInt(max / radix) > 0) {
    right = countingSort(right, radix);
    radix *= 10;
  } // 오른쪽 정렬

  return left
    .reverse()
    .map((item) => item * -1)
    .concat(right);
} // 정렬된 왼쪽값을 뒤집어서 다시 음수로 만들어준뒤 오른쪽 값들을 합쳐준다.
```

## 오늘 느낀 점
기수정렬의 개념에 대해서만 이해하고 **Reference Code**를 보며 이해하는 정도에 그쳤다.. ~~나중에 다시 풀어볼 예정~~

정렬.. 잊을만 하면 한번씩 나온다 ㅠㅠ

## 내일 할 일
- TOY 25. robotPath
