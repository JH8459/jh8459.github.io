---
title: "[Algorithm] TOY 25. robotPath"
category: Algorithm
excerpt: "[Algorithm] TOY 25. robotPath"
sidebar:
  nav: docs
---

![Algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 25. robotPath 
### 문제
---
세로와 가로의 길이가 각각 M, N인 방의 지도가 2차원 배열로 주어졌을 때, `1`은 장애물을 의미하고 `0` 이동이 가능한 통로를 의미합니다. 로봇은 지도 위를 일분에 한 칸씩 상하좌우로 이동할 수 있습니다. 로봇의 위치와 목표 지점이 함께 주어질 경우, 로봇이 목표 지점까지 도달하는 데 걸리는 최소 시간을 리턴해야 합니다.


### 입력
---
#### 인자 1 : room
- 배열을 요소로 갖는 배열
- `room.length`는 `M`
- `room[i]`는 `number` 타입을 요소로 갖는 배열
- `room[i].length`는 N
- `room[i][j]`는 세로로 i, 가로로 j인 지점의 정보를 의미
- `room[i][j]`는 0 또는 1

#### 인자 2 : src
- `number` 타입을 요소로 갖는 배열
- `src.length`는 2
- `src[i]`는 0 이상의 정수
- `src`의 요소는 차례대로 좌표평면 위의 y좌표, x좌표

#### 인자 3 : dst
- `number` 타입을 요소로 갖는 배열
- `dst.length`는 2
- `dst[i]`는 0 이상의 정수
- `dst`의 요소는 차례대로 좌표평면 위의 y좌표, x좌표

### 출력
---
- `number` 타입을 리턴해야 합니다.

### 주의사항
---
- M, N은 20 이하의 자연수입니다.
- `src`, `dst`는 항상 로봇이 지나갈 수 있는 통로입니다.
- `src`에서 `dst`로 가는 경로가 항상 존재합니다.

### 입출력 예시
---
```javascript
let room = [
  [0, 0, 0, 0, 0, 0],
  [0, 1, 1, 0, 1, 0],
  [0, 1, 0, 0, 0, 0],
  [0, 0, 1, 1, 1, 0],
  [1, 0, 0, 0, 0, 0],
];
let src = [4, 2];
let dst = [2, 2];
let output = robotPath(room, src, dst);
console.log(output); // --> 8
```

## TOY 25. Solution
### 수도코드
---
Toy 알고리즘 너무 어렵다... 우선 레퍼런스를 보기전 열심히 구글링을 해보니 내가 이해할 수 있는 수준의 코드로 풀이를 해놓은 <a href="https://foamless.tistory.com/797" target="_blank">블로그</a>를 발견하여서 이해하는 수준에서 마무리지었다.

우선 키포인트는 **완전탐색**이다.  현재의 좌표를 기준으로 4방향으로 움직인다. 다만, 최단거리를 구하는 효율성 문제이므로 BFS 방식(시작 지점부터 가까운 정점들 우선 탐색하는 방법)으로 풀었다고한다. 

코드가 복잡해보이지만 전형적인 BFS 탐색 방식이다. 코드의 세부적인 내용은 주석으로 대체하였다.

### 문제풀이
---
```javascript
const robotPath = function (room, src, dst) {
  const visit = Array(room.length).fill().map(()=>Array(room[0].length).fill(0)); // 0으로 채워진 방문여부 지도 (room.length X room[0].length 사이즈) 2차원 배열 생성
  const queue = [[...src, 1]];  // [y,x,cnt] 값, 큐가 비워지며 반복문을 시작하므로 1부터 시작한다.
  const direction = [  // 4방향 좌표이동치
    [0,1],
    [0,-1],
    [1,0],
    [-1,0]
  ];
  const ny = room.length - 1;  // y값의 최대값(인덱스)은 room배열의 length-1, 유효값 검사에 쓰인다.
  const nx = room[0].length - 1;  // x값의 최대값(인덱스)은 room[0]배열의 length-1

  visit[src[0]][src[1]] = 1;  // 시작점부터 방문 체크 진행 후 반복문에 진입한다.

  while(queue.length !== 0) {  // 큐가 모두 비워질때까지 진행한다.
    let result = queue.shift();  
    let [y, x, cnt] = result;  // 큐에서 뺀 result 값을 각각 y,x,cnt로 구조분해 할당 
    
    for(let i = 0; i < 4; i++) {
      let dy = y + direction[i][0];  // robot이 이동할 다음 좌표 (현재 기준점에서 사방향을 모두 검사한다 [완전탐색])
      let dx = x + direction[i][1];

      // robot이 이동하기 전, 다음좌표가 이동이 가능한지 유효성 검사
      if(dx < 0 || dy < 0 || dx > nx || dy > ny ) continue;  // robot이 이동할 좌표가 room 배열을 벗어나는 경우
      if(room[dy][dx] === 1) continue;  // robot이 이동할 좌표가 장애물이 있는 경우
      if(visit[dy][dx]) continue;  // robot이 이동할 좌표가 이미 방문한적이 있는 경우

      // 다음 이동할 좌표가 dst(도착점) 좌표와 일치하다면 반복문 탈출
      if(dy === dst[0] && dx === dst[1]) return result[2];  // 이동할 좌표가 dst와 일치하다면 result 배열의 cnt값을 반환한다.

      // 유효성 검사를 통과했으며, 도착점도 아니라면 아래의 코드를 수행한다
      visit[dy][dx] = 1;  // 현재 좌표를 방문표시한다.
      queue.push([dy, dx, cnt + 1]);  // queue에 이동할 다음 좌표값을 넣고 cnt값을 증가시킨다.
    }
  }
};
```
--- 
**Reference Code**
```javascript
const robotPath = function (room, src, dst) {
  const aux = (M, N, candi, step) => {
    // 현재 위치
    const [row, col] = candi;

    // 배열의 범위를 벗어난 경우
    if (row < 0 || row >= M || col < 0 || col >= N) return;

    if (room[row][col] === 0 || room[row][col] > step) {
      room[row][col] = step;
    } else {
      // 장애물(1)이거나 이미 최소 시간(1)으로 통과가 가능한 경우
      return;
    }

    // dfs로 4가지 방향에 대해 탐색을 한다.
    // 완전탐색을 해야하므로 bfs나 dfs가 큰 차이가 없다.
    // bfs의 경우 목적지에 도착하는 경우 탐색을 중단해도 되므로,
    // 약간 더 효율적이다.
    aux(M, N, [row + 1, col], step + 1); // 상
    aux(M, N, [row - 1, col], step + 1); // 하
    aux(M, N, [row, col - 1], step + 1); // 좌
    aux(M, N, [row, col + 1], step + 1); // 우
  };

  // 로봇이 서 있는 위치를 1로 초기화하면 (다시 방문하지 않기 위해서),
  // 바로 옆 통로는 2가 된다.
  // 계산이 완료된 후에 최종값에 1을 빼주면 된다.
  aux(room.length, room[0].length, src, 1);

  const [r, c] = dst;
  return room[r][c] - 1;
};
```

## 오늘 느낀 점
```javascript
const visit = Array(room.length).fill().map(()=>Array(room[0].length).fill(0));
```
2차원 배열로 지도(방문여부 플래그)를 그리는 코드이다. `map` 메서드를 이용해서 `room.length` * `room[0].length` 사이즈의 2차원 배열을 생성한다. 생소하지만 앞으로 유용할 듯 하다. 


아직 BFS 탐색 알고리즘... 완전탐색 알고리즘이 익숙하지 않다. ~~(언제쯤 혼자 풀어볼까...)~~
## 내일 할 일
- TOY 26. LSCS
