---
title: TOY 26. LSCS
category: Algorithm
excerpt: "[Algorithm] TOY 26. LSCS"
sidebar:
  nav: docs
---

![Algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 26. LSCS
### 문제
---
정수를 요소로 갖는 배열을 입력받아 다음의 조건을 만족하는 LSCS*를 리턴해야 합니다.

- `LSCS`: 주어진 배열의 연속된 부분 배열*의 합을 구한다고 할 때, 이 중 가장 큰 값(Largest Sum of Contiguous Subarray)
- `연속된 부분 배열들`: 배열 `[1,2,3]`의 연속 부분 배열은 `[1]`, `[1, 2]`, `[1, 2, 3]`, `[2]`, `[2, 3]`, `[3]` 입니다.


### 입력
---
#### 인자 1 : arr
---
- `number` 타입을 요소로 갖는 배열
- `arr.length`는 60,000 이하
- `arr[i]`는 -100,000 이상 100,000 이하의 정수

### 출력
---
- `number` 타입을 리턴해야 합니다.

### 주의사항
---
- 배열의 모든 요소가 음수인 경우도 있습니다.

### 입출력 예시
---
```javascript
let output = LSCS([1, 2, 3]);
console.log(output); // --> 6

output = LSCS([1, 2, 3, -4]);
console.log(output); // --> 6 ([1, 2, 3])

LSCS([1, 2, 3, -4, 5]);
console.log(output); // --> 7 ([1, 2, 3, -4, 5])

LSCS([10, -11, 11]);
console.log(output); // --> 11 ([11])
```

## TOY 26. Solution
### 수도코드
---
~~문제가 잘 이해가 안갔다...~~ arr 배열의 요소들로 만들 수 있는 모든 부분 집합 배열들 중 합이 가장 큰 경우를 리턴해주면 되는 문제이다. 만약, 모든 배열의 요소가 양수라면 부분집합의 합중 가장 큰 부분집합은 자기 자신(arr)일것이다.


`O(n^2)`이라는 최악의 시간복잡도가 나오겠지만, 가장 쉬운 방법은 이중 for문으로 모든 요소를 탐색하며 부분집합의 합을 계산하여 가장 큰 값이 무엇인지 추려내는 과정일 것 이다.

### 문제풀이
---
```javascript
const LSCS = function (arr) {
  let max = -100000;  // 입력조건중 arr[i]의 최소값은 -100,000

  // for문을 2개를 사용하여, 모든 경우의 수를 탐색한다. O(n^2)
  for (let i = 0; i < arr.length; i++) {
    let sum = arr[i]; 
    if (sum > max) max = sum; 
    for (let j = i + 1; j < arr.length; j++) {
      sum = sum + arr[j];
      if (sum > max) max = sum;
    }
  }
  return max;
};
```
--- 
**Reference Code**
```javascript
const LSCS = function (arr) {
  let subArrSum = 0; // 연속 배열의 합
  let max = Number.MIN_SAFE_INTEGER; // JavaScript에서 안전한 최소 정수값
  
  for (let i = 0; i < arr.length; i++) {
    subArrSum = subArrSum + arr[i];

    // 배열의 모든 요소가 음수라면, 이 비교식에 걸려 배열의 모든 요소를 한번씩 탐색 후 가장 큰 정수 요소만 반환된다.
    if (subArrSum > max) max = subArrSum;  

    // 연속된 구간의 합이 음수인 경우, 0으로 초기화. 즉 LSCS와 상관없는 연산이되므로, 해당 값은 고려하지 않는다.
    if (subArrSum < 0) subArrSum = 0;
  }
  return max;  
};
```

## 오늘 느낀 점
사실 시간복잡도를 고려하기전 "부분집합의 합을 구하라"라는 문제라고 느껴서 ***부분집합을 모두 구한 뒤.. 해당 배열들의 합을 구해서... 리턴을해야하나?*** 라는 생각부터 들었다. 

문제를 아직 많이 풀어본 경험이 없어서 문제 자체를 너무 1차원적으로 받아들인다라고 스스로 느껴졌다. 

Reference Code는 특별한 알고리즘이 아닌 발상을 전환해서, 모든 수가 음수라면..가장 큰 음수를 max값으로 넣고 리턴해줄수 있을 뿐만아니라, 부분집합의 합이 음수가 되는 경우는 `LSCS`를 만족하지 못하는 경우의 수 이기때문에 연산에서 배제시키는 알고리즘을 구현하였다.

간단하면서도 풀이가 명확하다 느껴졌다. 

```javascript
Number.MIN_SAFE_INTEGER // JavaScript에서 안전한 최소 정수값
```
사담이지만, 이러한 정수값 표현 방법도 배웠다. 반대로 안전한 최대 정수값은 `MIN_SAFE_INTEGER`로 치환해주면 성립된다.
## 내일 할 일
- TOY 27. LSCS
