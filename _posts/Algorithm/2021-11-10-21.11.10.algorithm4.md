---
title: "[Algorithm] 빼빼로 데이 (GCD)"
excerpt: "[Algorithm] 빼빼로 데이 (GCD)"
category: Algorithm
---

![Algorithm](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## 빼빼로 데이
### 문제
---
오늘은 빼빼로 데이입니다. 한 회사의 팀장은 출근길에 아몬드 빼빼로 M개와 누드 빼빼로 N개를 구매하여 아침 일찍 출근길에 나섰습니다.

팀장은 자신보다 먼저 출근해 있는 직원들에게 구매한 빼빼로를 전부 나누어 주려고 합니다.<br>
단, 서로 질투하는 경우를 만들지 않기 위해 모든 직원들에게 공평하게 빼빼로를 나누어 주려고 합니다.<br>
직원들은 각각의 빼빼로를 똑같은 개수만큼 받아야 합니다. 빼빼로를 쪼개서 줄 수는 없습니다.

하지만 회사에 도착하기 전이라 몇 명의 직원들이 있는지 모르는 상황입니다.<br>
팀장이 아몬드 빼빼로를 4개, 누드 빼빼로를 8개를 구매 했다면, 다음과 같이 세 가지 방법으로 나누어 줄 수 있습니다.

- 출근한 직원이 1명이라면 아몬드 빼빼로 4개와 누드 빼빼로 8개를 줄 수 있습니다.
- 출근한 직원이 2명이라면 아몬드 빼빼로 2개와 누드 빼빼로 4개를 각각 줄 수 있습니다.
- 출근한 직원이 3명이라면 빼빼로를 남기지 않고 공평하게 주는 방법은 없습니다.
- 출근한 직원이 4명이라면 아몬드 빼빼로 1개와 누드 빼빼로 2개를 각각 줄 수 있습니다.

팀장은 출근한 직원 수에 따라 어떻게 빼빼로를 나누어 줄지 고민하고 있습니다.<br>
여러분이 직원 수에 따라 빼빼로를 나누어 주는 방법을 구하는 솔루션을 제공해 주세요.

### 입력
---
#### 인자 1: M
- `Number` 타입의 양의 정수 (1 ≤ M ≤ 1,000,000,000)

#### 인자 2: N
- `Number` 타입의 양의 정수 (1 ≤ M ≤ 1,000,000,000)

### 출력
---
- 2차원 배열 `output`을 리턴해야 합니다.
- `output[i]`은 다음과 같은 순서를 가진 길이 3의 배열입니다.
  - `[빼빼로를 받게 되는 직원의 수, 나누어 주는 아몬드 빼빼로의 수, 나누어 주는 누드 빼빼로의 수]`
- `output`은 `output[i][0]`, 즉 '빼빼로를 받게 되는 직원의 수'를 기준으로 오름차순으로 정렬합니다.

### 입출력 예시
---
```javascript
let M = 4;
let N = 8;
let output = divideChocolateStick(M, N);
console.log(output);
// [[1, 4, 8], [2, 2, 4], [4, 1, 2]]
```

## Solution
### 수도코드
---

1. 공약수들을 구해서 배열에 담는다.
2. 공약수 배열을 순회 하며 `[인원수, 아몬드 빼뺴로/인원수, 누드 빼뺴로/인원수]` 배열을 결과값 배열에 담아 리턴한다.


공약수는 M과 N을 각각 나누어서 나머지가 0인 수들이므로, 둘중 작은 숫자를 1부터 나눠보며 찾을 수 있다.

### 문제풀이 
---
```javascript
function divideChocolateStick(M, N) {
  let result = [];
  let divisor = [];

  for(let i=1; i<=Math.min(M,N); i++) {  // 공약수는 둘중 작은 숫자를 찾아
    if(M%i === 0 && N%i === 0){  // 둘다 나머지가 0으로 나눠떨어지는 숫자들이다
      divisor.push(i);  // 공약수 배열에 담는다.
    }
  }

  for(let div of divisor){  // 공약수 배열을 순회하며
    result.push([div, M/div, N/div]);  // 양식에 맞게 결과값 배열에 넣어준다
  }

  return result;
}
```
--- 

**Reference Code**
```javascript
// 최대 공약수(유클리드 호제법: Euclidean algorithm)
function gcd(m, n) {
  if (m % n === 0) return n;
  return gcd(n, m % n);
}

function divideChocolateStick(M, N) {
  const result = [];
  // 최대공약수를 구한다.
  // M, N의 순서는 상관없다.
  const GCD = gcd(M, N);
  let temp = 0; //

  // 약수는 대칭적이므로 제곱근까지만 반복해도 된다.
  // 예) 36의 약수는 1, 2, 3, 4, 6, 9, 12, 18, 36이다.
  // 제곱근을 기준으로 양쪽의 값 하나씩 곱했을 때 36이 되기 때문에
  // 제곱근 보다 큰 약수는 제곱근보다 작은 약수에서 구할 수 있다.
  const sqrt = Math.floor(Math.sqrt(GCD));
  for (let left = 1; left <= sqrt; left++) {
    if (GCD % left === 0) {
      // 최대공약수의 약수인 경우 중 제곱근 보다 작은 약수의 경우
      result.push([left, M / left, N / left]);
      if (left * left < GCD) {
        // 제곱근이 아닌 경우(제곱근 보다 작은)
        right = GCD / left; // 최대 공약수를 제곱근이 아닌 수로 나누면 제곱근 보다 큰 약수를 구할 수 있다.
        result.push([right, M / right, N / right]);
      }
    }
  }

  // '빼빼로를 받게 되는 직원의 수'를 기준으로 오름차순으로 정렬
  result.sort((op1, op2) => op1[0] - op2[0]);

  return result;
}
```

## 느낀 점

시간복잡도 문제인지 TEST CASE 1개를 통과하지 못하였다. 

**Reference Code**를 참조해보니 모든 약수를 체크하지 않고 제곱근까지 접근하는 로직으로 구현한걸 보았다. ~~귀찮아서 내 코드를 고치진 않았다...~~

최대 공약수를 구하는 알고리즘이 인상 깊었다. 자주 쓰이진 않겠지만 이렇게 구현이 된다는 것 자체가 신기하다...

```javascript
// 최대공약수(유클리드 호제법: Euclidean algorithm)
function gcd(m, n) {
  if (m % n === 0) return n;
  return gcd(n, m % n);
}
```
