---
title: Node.js 트래픽이 많아지는 경우 서버 과부화 대응 방법
category: TIL
excerpt: "[TIL] 트래픽이 많아지는 경우 서버 과부화 대응 방법"
---

![TIL](https://user-images.githubusercontent.com/83164003/157039191-32141e02-51fe-4d34-abeb-02bb8f897dde.jpeg)
## Today I Learnd

프로젝트들을 진행하며 대용량 서비스를 염두하고 서버를 개발해본 경험이 아직없다.

Node.js 기반의 웹 서버 사용시 트래픽이 많아지는 경우 서버에 걸리는 과부하에 대응 하는 방법들을 학습해 보고 글로 남겨보려 한다.

<br>
<br>
우선 Node.js 환경 뿐 아니라 대개의 서버는 중앙 집중형태로 다수의 클라이언트를 위해 존재한다.

![server](https://user-images.githubusercontent.com/83164003/157154569-5c971607-3357-424a-a2d4-e4511c353ecf.png)
<br>
<br>

때문에 클라이언트로부터 수많은 요청을 동시에 받으므로 병목현상이 발생하기 쉬우며 이를 대비해 처리 성능에 항상 주목해야 한다.

<br>
<br>

### 1. Node.js의 비동기 처리
---
Node.js는 비동기 IO를 지원하며 싱글 쓰레드 기반으로 동작하는 서버이다. ~~(여기서 비동기 처리란? 어떤 코드의 출력이 끝날 때까지 기다려주지 않고 다른 코드를 먼저 실행하는 방식이다.)~~

<br>
![eventloop](https://user-images.githubusercontent.com/83164003/157156519-26f217ba-ac29-4128-b318-552f94239f73.png)
<center><span style="font-size: 0.75em;">출처 : <a href="https://www.nextree.co.kr/p7292/" target="_blank">넥스트리</a></span></center><br>

비동기 처리방식은 이벤트 방식으로 풀어낸다.<br>
클라이언트에서 발생된 요청을 처리하기 위해 이벤트가 발생하며, 서버 내부에 메시지 형태로 전달된다. 이 메시지는 Event Loop에서 처리가 되며 서버는 다음 클라이언트 요청을 다시 받아들인다.

Event Loop에서 요청 처리가 완료되면 CallBack을 호출하여 처리완료를 서버에 알려준다. 이러한 이벤트 처리는 싱글 쓰레드 기반으로 Event Loop에서 처리되므로 Node.js는 싱글 쓰레드 기반으로 동작한다 일컫는다. 즉, 클라이언트 요청은 하나의 쓰레드 안에서 처리된다. 

그래서 이벤트 호출 측면으로 본다면 비동기로 처리되지만 요청의 작업 단위가 프로세스를 크게 요구하는 요청일 경우에는 쓰레드 하나에서 해당 처리작업이 오래걸리므로 전체 서버 처리에 영향을 미치게된다. (이는 Node.js의 치명적인 약점이다.)

<br>
<br>

따라서 Node.js의 Event Loop 처리 과정은 싱글 쓰레드 기반으로 작업이 처리가 되며, 클라이언트의 요청은 비동기 메시지로 처리된다.

따라서 사용자는 반드시 처리 로직을 비동기로 구현해야 Node.js를 올바르게 활용하는 방법이며, 클라이언트가 요청하는 처리 작업 단위가 CPU를 많이 소모하지 않는 작업이라면 고효율 고성능을 보장해주지만 CPU를 많이 소모하는 작업이라면 Node.js는 알맞지 않은 서버일 수 있다. 

서비스에 알맞는 서버 환경을 구축하는게 바람직한 방향이다.

> PayPal, Netflix, LinkedIn, Groupon 등 전 세계적인 서비스에서 이미 Node.js를 사용하고 있다.

<br>
<br>

#### 1-1. 연산자(일반)
---

공식문서에서 설명하는 연산자는 다음 아래와 같다.

```js
// Logical operator
[Op.and]: [{ a: 5 }, { b: 6 }],  // (a = 5) && (b = 6)
[Op.or]: [{ a: 5 }, { b: 6 }],  // (a = 5) || (b = 6)

// Basics
[Op.eq]: 3,  // = 3
[Op.ne]: 20,  // != 20
[Op.is]: null,  // IS NULL
[Op.not]: true,  // IS NOT TRUE
[Op.or]: [5, 6],  // (someAttribute = 5) OR (someAttribute = 6)

// Using dialect specific column identifiers (PG in the following example):
[Op.col]: 'user.organization_id',        // = "user"."organization_id"

// Number comparisons
[Op.gt]: 6,  // > 6
[Op.gte]: 6,  // >= 6
[Op.lt]: 10,  // < 10
[Op.lte]: 10,  // <= 10
[Op.between]: [6, 10],  // BETWEEN 6 AND 10
[Op.notBetween]: [11, 15],  // NOT BETWEEN 11 AND 15

// Other operators
[Op.all]: sequelize.literal('SELECT 1'), // > ALL (SELECT 1)

[Op.in]: [1, 2],  // IN [1, 2]
[Op.notIn]: [1, 2],  // NOT IN [1, 2]

[Op.like]: '%hat',  // LIKE '%hat'
[Op.notLike]: '%hat',  // NOT LIKE '%hat'
[Op.startsWith]: 'hat',  // LIKE 'hat%'
[Op.endsWith]: 'hat',  // LIKE '%hat'
[Op.substring]: 'hat',  // LIKE '%hat%'
[Op.iLike]: '%hat',  // ILIKE '%hat' (case insensitive) (PG only)
[Op.notILike]: '%hat',  // NOT ILIKE '%hat'  (PG only)
[Op.regexp]: '^[h|a|t]',  // REGEXP/~ '^[h|a|t]' (MySQL/PG only)
[Op.notRegexp]: '^[h|a|t]',  // NOT REGEXP/!~ '^[h|a|t]' (MySQL/PG only)
[Op.iRegexp]: '^[h|a|t]',  // ~* '^[h|a|t]' (PG only)
[Op.notIRegexp]: '^[h|a|t]',  // !~* '^[h|a|t]' (PG only)

[Op.any]: [2, 3],  // ANY ARRAY[2, 3]::INTEGER (PG only)
[Op.match]: Sequelize.fn('to_tsquery', 'fat & rat') // match text search for strings 'fat' and 'rat' (PG only)

// In Postgres, Op.like/Op.iLike/Op.notLike can be combined to Op.any:
[Op.like]: { [Op.any]: ['cat', 'hat'] }  // LIKE ANY ARRAY['cat', 'hat']
```
#### 1-2. 연산자(범위)
---

범위 연산자 또한 지원하여 다양한 종류의 범위를 쿼리할 수 있다.<br> 
공식문서에서 설명하는 범위 연산자는 아래와 같다.

```js
[Op.contains]: 2,            // @> '2'::integer  (PG range contains element operator)
[Op.contains]: [1, 2],       // @> [1, 2)        (PG range contains range operator)
[Op.contained]: [1, 2],      // <@ [1, 2)        (PG range is contained by operator)
[Op.overlap]: [1, 2],        // && [1, 2)        (PG range overlap (have points in common) operator)
[Op.adjacent]: [1, 2],       // -|- [1, 2)       (PG range is adjacent to operator)
[Op.strictLeft]: [1, 2],     // << [1, 2)        (PG range strictly left of operator)
[Op.strictRight]: [1, 2],    // >> [1, 2)        (PG range strictly right of operator)
[Op.noExtendRight]: [1, 2],  // &< [1, 2)        (PG range does not extend to the right of operator)
[Op.noExtendLeft]: [1, 2],   // &> [1, 2)        (PG range does not extend to the left of operator)
```

---

#### 1-3. 연산자 조합
---

```js
const { Op } = require("sequelize");

Foo.findAll({
  where: {
    rank: {
      [Op.or]: {
        [Op.lt]: 1000,
        [Op.eq]: null
      }
    },
    // rank < 1000 OR rank IS NULL

    {
      createdAt: {
        [Op.lt]: new Date(),
        [Op.gt]: new Date(new Date() - 24 * 60 * 60 * 1000)
      }
    },
    // createdAt < [timestamp] AND createdAt > [timestamp]

    {
      [Op.or]: [
        {
          title: {
            [Op.like]: 'Boat%'
          }
        },
        {
          description: {
            [Op.like]: '%boat%'
          }
        }
      ]
    }
    // title LIKE 'Boat%' OR description LIKE '%boat%'
  }
});
```

`where` 조건 객체에서 연산자들끼리의 중복 사용또한 가능하다.<br>
- 조건 객체에서 별 다른 연산자로 엮어주지 않고 속성을 나열한다면 AND로 간주된다.
- 연산자안에서 여러 컬럼을 다루는 경우에는 각 컬럼에 대한 조건을 담은 객체의 배열로 작성해야 한다.


<br>
<br>
## 오늘 느낀 점
~~항상 느끼지만 시퀄라이즈 공식문서는 너무 불친절..~~

공식문서에서는 자세한 사용 방식을 안내하기보다는 다양한 예시를 제공해 준 뒤, 이에 맞춰 사용자가 찾아서 써라(?)라는 느낌을 많이 받았다.

매번 `ctril + f` 로 검색하여 찾아 쓰기 귀찮아서 정리해보았다.
	
<br>
<br>
