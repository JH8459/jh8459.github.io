---
title: "[TOY] TOY 11. powerSet"
category: TOY
excerpt: "[TOY] TOY 11. powerSet"
sidebar:
  nav: docs
---

![TOY](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 11. powerSet
### 문제
---
하나의 집합을 의미하는 문자열을 입력받아 각 문자를 가지고 만들 수 있는 모든 부분집합을 리턴해야 합니다.



### 입력
---
#### 인자 1 : str
- `string` 타입의 공백이 없는 알파벳 소문자 문자열

### 출력
---
- 배열(`arr`)을 리턴해야 합니다.
- `arr[i]`는 각 부분집합의 원소로 구성된 문자열

### 주의사항
---
- `arr[i]`는 각 부분집합을 구성하는 원소를 연결한 문자열입니다.
- `arr[i]`는 알파벳 순서로 정렬되어야 합니다.
- 집합은 중복된 원소를 허용하지 않습니다.
- 부분집합은 빈 문자열을 포함합니다.
- `arr`은 사전식 순서(lexical order)로 정렬되어야 합니다.

### 입출력 예시
---
```javascript
let output1 = powerSet('abc');
console.log(output1); // ['', 'a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']

let output2 = powerSet('jjump');
console.log(output2); // ['', 'j', 'jm', 'jmp', 'jmpu', 'jmu', 'jp', 'jpu', 'ju', 'm', 'mp', 'mpu', 'mu', 'p', 'pu', 'u']
```


## TOY 11. Solution
### 수도코드
---
- 입력 받은 배열을 배열로 변환, 정렬
- 집합은 중복된 원소를 허용하지 않으므로, 정렬된 배열을 중복값을 제거해줌 (flilter...등 메소드 활용 필요)
- DFS 깊이 알고리즘을 통해 멱집합 알고리즘 구현. (flag 배열을 생성하여 중복값 여부 check)

### 문제풀이
---
```javascript 
const powerSet = function (str) {
  // TODO: 여기에 코드를 작성합니다.
  const sortArr = str.split('').sort(); // sortArr = str->arr 변환 후 정렬한다.
  const uniqueArr = sortArr.filter((el, index) => sortArr.indexOf(el) === index) 
  // 중복값 제거, filter 메소드를 이용하여 sortArr.indexOf(el)값이 index와 같은 조건의 uniqe한 값들로 채운 배열을 선언.
  let flag = new Array(uniqueArr.length).fill(false); // 플래그 생성.

  const subSets = [];

  const subSet = function DFS (depth) { // 부분 집합 구하는 재귀 함수, DFS 알고리즘
    if (depth === uniqueArr.length) { // 트리의 끝에 다다른 것 ==> 재귀 종료 조건
      const subSet = uniqueArr.filter((value, index) => flag[index]).join(''); 
      // subset = [ flag[index] === true 이면, uniqueArr[index]을 반환하는 배열이 생성된다]
      subSets.push(subSet); // 부분집합들을 담는 배열에 push

      return; // 이전 depth로 회귀
    }

    flag[depth] = true; // 해당 depth의 flag true = 트리의 왼쪽
    subSet(depth + 1); // 트리의 왼쪽에 대해 재귀호출

    flag[depth] = false; // 해당 depth의 flag false = 트리의 오른쪽
    subSet(depth + 1); // 트리의 오른쪽에 대해 재귀 호출
  }
  
  subSet(0); // depth 0 부터 시작
  return subSets.sort();
};

```
### Reference Code
---
```javascript
const powerSet = function (str) {
  // 정렬
  const sorted = str.split('').sort();

  // 중복 제거
  const deduplicated = sorted.reduce((acc, item) => {
    if (acc[acc.length - 1] === item) {
      return acc;
    } else {
      return acc.concat(item);
    }
  });

  let subSets = [];
  const pickOrNot = (idx, subset) => {
    // base case
    if (idx === deduplicated.length) {
      // 마지막 문자까지 검토한 경우
      subSets.push(subset);
      return;
    }

    // recursive case
    // idx번째 문자가 포함되지 않는 경우
    pickOrNot(idx + 1, subset);

    // idx번째 문자가 포함되는 경우
    pickOrNot(idx + 1, subset + deduplicated[idx]);
  };

  pickOrNot(0, '');

  return subSets.sort();
};
```
## 오늘 느낀 점
- 멱집합 알고리즘을 참조 하였다. 참조 : <a href="https://jun-choi-4928.medium.com/javascript%EB%A1%9C-%EB%A9%B1%EC%A7%91%ED%95%A9-powerset-%EB%A6%AC%ED%84%B4%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-f1cce8cc3268" target="_blank">https://jun-choi-4928.medium.com</a> 블로그

  ![dfs 부분배열 ](https://user-images.githubusercontent.com/83164003/132379995-ab48baeb-7ac0-476d-bd0c-39ca5ca1b140.png)

  참고한 사이트 자료가 너무 보기 좋게 정리되어있어서 이해는 어렵지 않았다. ~~(물론 손으로 당연히 쓰면서...)~~

- `return ;`이 의미하는 바가 무엇인지 정확히 이해하였다. 재귀를 구현하다보면 재귀의 스택이 쌓이기 마련이다. 이럴때 이전 단계로 회귀(?)하는 느낌을 받았다. DFS 알고리즘 경우 트리의 한 줄기의 깊이를 모두 탐색 후, 다른 줄기로 뻗어야 한다. Leaf 노드로 이르렀을때, 이전 노드로 돌아가기 위해 `return ;`을 사용해야한다는 개념을 확실히 익힌 알고리즘이었다.

- 외람되지만, 알고리즘 해결 위해 구글링 중 `set`이라는 자료구조를 접하였다. 
  > Set는 데이터를 비순차적(unordered)으로 저장할 수 있는 순열 자료구조 (collection)입니다. ... Array,List와 마찬가지로 Set는 수정이 가능합니다. 중복을 허용하지 않아서 같은값을 삽입하면 되면, 마지막에 삽입한 값 하나만 저장 됩니다. 

  중복을 허용하지 않은 자료구조 솔깃하다..

  ```javascript
  const sortArr = str.split('').sort();
  const uniqueArr = sortArr.filter((el, index) => sortArr.indexOf(el) === index)
	```
	
	위 행위를 뭔가 한코드로 줄일수 있을 듯한 느낌이 온다.
	
	
## 내일 할 일
- TOY 12. treeBFS
