---
title: "[TOY] TOY 27. gossipProtocol"
category: TOY
excerpt: "[TOY] TOY 27. gossipProtocol"
sidebar:
  nav: docs
---

![TOY](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 27. gossipProtocol
### 문제
---
세로와 가로의 길이가 각각 M, N인 마을지도가 배열로 주어졌을 때, `'1'`은 주민이 있는 집을 의미하고 `'0'`은 주민이 없는 땅을 의미합니다. 이 마을은 소문이 시작되면 하루에 상하좌우 한 칸 바로 옆에 있는 집으로 퍼집니다. 특정 주민의 집 (R, C)으로부터 어떤 소문이 시작될 경우, 마을 전체로 소문이 퍼지는데 걸리는 시간(일)을 리턴해야 합니다.


### 입력
---
#### 인자 1 : village
- `string` 타입을 요소로 갖는 배열
- `village.length`는 M
- `village[i]`는 `string` 타입
- `village[i].length`는 N
- `village[i][j]`는 세로로 i, 가로로 j인 지점의 정보를 의미
- `village[i][j]`는 `'0'` 또는 `'1'`

#### 인자 2: row
- `number` 타입의 0 이상의 정수
- 소문이 시작되는 집의 세로 위치

#### 인자 3: col
- `number` 타입의 0 이상의 정수
- 소문이 시작되는 집의 가로 위치

### 출력
---
- `number` 타입을 리턴해야 합니다.

### 주의사항
---
- M, N은 100 이하의 자연수입니다.
- `row`, `col`에는 항상 주민이 살고 있습니다.
- 모든 집은 연결되어 있습니다. 즉, 한 집에서 다른 집으로 가는 경로가 항상 존재합니다.
- village를 그래프로 구현하는 함수가 주어집니다.

### 입출력 예시
---
```javascript
let village = [
  '0101', // 첫 번째 줄
  '0111',
  '0110',
  '0100',
];
let row = 1;
let col = 2;
let output = gossipProtocol(village, row, col);
console.log(output); // --> 3
/*
1. 시작: (1, 2)에서 시작, 소문이 퍼진 곳을 x로 표기
 [
  '0101',
  '01x1',
  '0110',
  '0100',
 ]

2. 1일 뒤
 [
  '0101',
  '0xxx',
  '01x0',
  '0100',
 ]

3. 2일 뒤
 [
  '0x0x',
  '0xxx',
  '0xx0',
  '0100',
 ]

4. 3일 뒤: 소문이 전부 퍼짐 (끝)
 [
  '0x0x',
  '0xxx',
  '0xx0',
  '0x00',
 ]
/*
```

## TOY 27. Solution
### 수도코드
---
소문의 근원지 부터 시작하여 인근 인덱스 값이 1이면 소문을 퍼트리는 재귀를 구현하면 될 듯 싶었는데, 생각대로 되지 않았다. **Reference Code** 를 보았다.


### 문제풀이
---
```javascript

```
--- 
**Reference Code**
```javascript
const createMatrix = (village) => {
  const matrix = [];
  village.forEach((line) => {
    const row = [];
    for (let i = 0; i < line.length; i++) row.push(line[i]);
    matrix.push(row);
  });
  return matrix;
};

const gossipProtocol = function (village, row, col) {
  // bfs 구현을 위해 큐를 선언한다.
  // enQueue, deQueue시마다 인덱싱을 다시 하지 않기 위해
  // 순환 큐(circular queue)로 구현한다.
  // 문제의 특성에 따라 큐에는 좌표 평면의 한 점이 삽입되고, 한번 삽입된 요소는 두 번 다시 삽입되지 않는다.

  const R = village.length;
  const C = village[0].length;
  const matrix = createMatrix(village);
  const MOVES = [
    [-1, 0], // UP
    [1, 0], // DOWN
    [0, 1], // RIGHT
    [0, -1], // LEFT
  ];
  const isValid = (row, col) => row >= 0 && row < R && col >= 0 && col < C;
  // 마을을 벗어나는지 안 벗어나는지 검사
  const queue = [];

  const enQueue = (queue, pos) => {
    queue.push(pos)
  }; // 소문을 들은 집의 좌표를 queue에 넣는다.
  const deQueue = (queue) => {
    const pos = queue.shift();
    return pos;
  }; // 소문을 들은 집의 좌표를 queue에서 빼준다.

  let cnt = 0; //소문이 퍼진 시간

  enQueue(queue, [row, col]); // 시작점의 집을 먼저 queue에 넣어준다.
  
  matrix[row][col] = 0; // 마을 좌표의 값으로 소문이 퍼지는 데 걸리는 시간을 저장
  while (queue.length > 0) {
    // 큐의 가장 앞 자리의 좌표를 얻는다.
    const [row, col] = deQueue(queue);
    cnt = matrix[row][col];

    // 현재 지점을 기준으로 네 방향을 검토한다.
    MOVES.forEach((move) => {
      const nextRow = row + move[0];
      const nextCol = col + move[1];
      if (isValid(nextRow, nextCol) && matrix[nextRow][nextCol] === '1') { 
        // 마을을 벗어나지 않고 소문이 퍼지지 않은 집을 queue에 넣어준다.
        enQueue(queue, [nextRow, nextCol]);
        matrix[nextRow][nextCol] = matrix[row][col] + 1; // 소문이 퍼진 시간 증가
      }
    });
  }
  return cnt;
};
```

## 오늘 느낀 점
문제가 상당히 어렵다.. 길찾기(?) 알고리즘, 각 방향성을 갖고 모든 경우를 탐색하는 알고리즘이 다시 등장했다. 

일단 쭉쭉 읽어 내려가며 이해는 하였지만, 다시 같은 문제를 풀으라하면 잘 모르겠다.. ~~다시 풀어볼 예정~~


## 내일 할 일
- TOY 28. robotPath2
