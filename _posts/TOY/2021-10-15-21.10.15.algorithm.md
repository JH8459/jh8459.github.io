---
title: "[TOY] TOY 30. heapSort"
category: TOY
excerpt: "[TOY] TOY 30. heapSort"
sidebar:
  nav: docs
---

![TOY](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 30. heapSort
### 문제
---
정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.
### 입력
---
#### 인자 1 : arr
- `number` 타입을 요소로 갖는 배열
- `arr[i]`는 -100,000 이상 100,000 이하의 정수
- `arr.length`는 100,000 이하

### 출력
---
- `number` 타입을 요소로 갖는 배열을 리턴해야 합니다.

### 주의사항
---
- **힙 정렬**을 구현해야 합니다.
- `arr.sort` 사용은 금지됩니다.
- 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.
- **최소 힙(min heap)** 을 구현해야 합니다.
- 최소 힙 구현을 위해 선언된 함수들(`getParentIdx`, `insert`, `removeRoot`)을 전부 완성해야 합니다.
- `swap`, `getParentIdx`, `insert`, `removeRoot`를 전부 사용해야 합니다.
- `swap`, `binaryHeap`을 수정하지 않아야 합니다.
- 테스트 케이스에서 힙 함수들을 정확히 구현했는지 함께 테스트합니다.
- `removeRoot`의 시간 복잡도는 `O(logN)`입니다.

### 입출력 예시
---
```javascript
let output = heapSort([5, 4, 3, 2, 1]);
console.log(output); // --> [1, 2, 3, 4, 5]

output = heapSort([3, 1, 21]);
console.log(output); // --> [1, 3, 21]

output = heapSort([4, 10, 3, 5, 1]);
console.log(output); // --> [1, 3, 4, 5, 10]
```

### 힌트
---
- 앞에서 말했듯이, 최소 힙은 최대 힙과 구현이 거의 일치한다. 아래 링크를 다시 한번 참고하시기 바랍니다.
  - <a href="https://www.cs.usfca.edu/~galles/visualization/Heap.html" target="_blank">https://www.cs.usfca.edu/~galles/visualization/Heap.html</a>
- 아래와 같은 최소 힙에서 루트 노드의 값(2)은 전체 노드의 값 중에서 가장 작습니다. 루트 노드를 제거한 후에도 최소 힙을 유지해야 하려면 어떤 작업이 필요한 지 고민하시기 바랍니다. 2가 제거된 후의 최소 힙의 루트 노드는 2를 제외한 값 중 가장 작은 값(3)이 되어야 합니다. 아래와 같은 사실로부터 힙 정렬에 대한 아이디어를 얻길 바랍니다.
   - 루트 노드를 제거하고(가장 작은 값을 제거하고) 다시 최소 힙을 유지하면, 새로운 루트 노드의 값은 그 다음으로 가장 작은 값이다.

  ```javascript
      2
     / \
    5   3
   / \ / \
  6  8 7  9
  ```

## TOY 30. Solution
### 수도코드
---
<a href="https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC" target="_blank">heap 정렬</a>을 구현하는 알고리즘이다. max heap을 구현하는 알고리즘을 요구하며, 문제의 틀은 아래와 같이 이미 구현이 되어있다.

```javascript
// 아래 코드는 수정하지 마세요.
function swap(idx1, idx2, arr) {
  // 두 변수를 바꾸는 방법

  // 1) 임시 변수를 활용한 방법
  // let temp = arr[idx1];
  // arr[idx1] = arr[idx2];
  // arr[idx2] = temp;

  // 2) Destructuring assignment를 활용한 방법
  // arr이 reference type이라 가능
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];

  // 3) XOR 연산을 활용한 방법
  // arr이 reference type이라 가능
  // arr[idx1] ^= arr[idx2];
  // arr[idx2] ^= arr[idx1];
  // arr[idx1] ^= arr[idx2];
}

function getParentIdx(idx) {
  // TODO: 여기에 코드를 작성합니다.
}

function insert(heap, item) {
  // TODO: 여기에 코드를 작성합니다.
}

// 아래 코드는 수정하지 마세요.
const binaryHeap = function (arr) {
  return arr.reduce((heap, item) => {
    return insert(heap, item);
  }, []);
};
```

트리구조로 정렬된 구조를 배열로 max heap을 구현해야 하므로, `INDEX`를 철처히 관리해주어야 하는게 핵심이다.

`getParentIdx` 함수는 현재의 `idx`를 받아 부모 노드의 배열 `idx`를 반환 해주어야 한다. 인덱스값이 0부터 싲가하는 배열에 담는 **이진탐색트리** 구조이므로, 부모 노드는 자식 노드 `(idx-1)/2` 값의 소숫점을 버린 값이 된다.

![이진트리idx](https://user-images.githubusercontent.com/83164003/137182632-34cbbcfd-cf1e-4100-a4ea-f11ace9bc334.jpg)

위 그림을 보면 쉽게 이해 할 수 있다. 따라서 `getParentIdx` 함수는 `parseInt`혹은 `Math.floor` 메소드를 써서 쉽게 부모 노드의 `idx`값을 구할 수 있다.

다음으로 `insert`함수는 빈 heap에 새로 들어갈 요소의 인덱스를 기준으로 해당 부모 요소와 크기 비교 후 `swap`함수를 통해 두 요소의 위치를 바꿔주는 행위를 새 요소가 현재 인덱스 기준으로 부모 요소보다 큰 경우 반복해주면 된다.
### 문제풀이
---
```javascript
// 아래 코드는 수정하지 마세요.
function swap(idx1, idx2, arr) {
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}

function getParentIdx(idx) {
  // TODO: 여기에 코드를 작성합니다.
  return Math.floor((idx - 1) / 2);
}

function insert(heap, item) {
  heap.push(item);
  let curIdx = heap.length - 1;  // 현재 노드의 위차
  let pIdx = getParentIdx(curIdx);  // 부모 노드의 위치
  
  // 부모 노드의 값이 유효하며, 현재 노드에 들어간 값이 부모 노드의 값보다 크면 while 구문 실행
  while (pIdx >= 0 && heap[curIdx] < heap[pIdx]) { // max heap 반대
    // 현재 노드와 부모 노드 배열자리 swap
    swap(curIdx, pIdx, heap);
    // swap 후 idx 교체 작업
    curIdx = pIdx;
    // 부모 idx는 swap후 curIdx의 부모 idx로 값을 다시 할당
    pIdx = getParentIdx(curIdx);
  }
  return heap;
}

function removeRoot(heap) {
  // TODO: 여기에 코드를 작성합니다.
  swap(0, heap.length - 1, heap); // 배열의 첫번째(최솟값)과 배열의 마지막 값을 바꾼다.
  heap.pop(); // 배열의 최솟값 제거

  if (heap.length === 0) return [];

  // 다시 최소힙을 유지
  let curIdx;
  let minIdx = 0;
  while (curIdx !== minIdx) {
    curIdx = minIdx;
    let left = curIdx * 2 + 1;
    let right = curIdx * 2 + 2;
    if (left < heap.length && heap[left] < heap[minIdx]) {
      minIdx = left;
    }
    if (right < heap.length && heap[right] < heap[minIdx]) {
      minIdx = right;
    }
    swap(curIdx, minIdx, heap);
  }
  return heap;
}

// 아래 코드는 수정하지 마세요.
const binaryHeap = function (arr) {
  return arr.reduce((heap, item) => {
    return insert(heap, item);
  }, []);
};

const heapSort = function (arr) {
  let minHeap = binaryHeap(arr);
  // TODO: 여기에 코드를 작성합니다.
  const sorted = [];
  while (minHeap.length > 0) {
    sorted.push(minHeap[0]);
    minHeap = removeRoot(minHeap);
  }
  return sorted;
};

```
--- 
**Reference Code**
```javascript
// 아래 코드는 수정하지 마세요.
function swap(idx1, idx2, arr) {
  // 두 변수를 바꾸는 방법

  // 1) 임시 변수를 활용한 방법
  // let temp = arr[idx1];
  // arr[idx1] = arr[idx2];
  // arr[idx2] = temp;

  // 2) Destructuring assignment를 활용한 방법
  // arr이 reference type이라 가능
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];

  // 3) XOR 연산을 활용한 방법
  // arr이 reference type이라 가능
  // arr[idx1] ^= arr[idx2];
  // arr[idx2] ^= arr[idx1];
  // arr[idx1] ^= arr[idx2];
}

function getParentIdx(idx) {
  // TODO: 여기에 코드를 작성합니다.
  return Math.floor((idx - 1) / 2);
}

function insert(heap, item) {
  // TODO: 여기에 코드를 작성합니다.
  heap.push(item);
  let curIdx = heap.length - 1;
  let pIdx = getParentIdx(curIdx);
  while (pIdx >= 0 && heap[curIdx] > heap[pIdx]) {
    swap(curIdx, pIdx, heap);
    curIdx = pIdx;
    pIdx = getParentIdx(curIdx);
  }
  return heap;
}

// 아래 코드는 수정하지 마세요.
const binaryHeap = function (arr) {
  return arr.reduce((heap, item) => {
    return insert(heap, item);
  }, []);
};
```

## 오늘 느낀 점
정렬..참 종류도 많다. 힙 정렬 같은 경우 이진탐색 트리의 특성을 잘 활용한 정렬이라 느껴졌다. 

이진트리를 배열로 표현할 경우 인덱스를 구하는 방식의 규칙을 깨닫고나니 어려운 문제는 아니라 느껴졌다. ~~(물론 레퍼런스 코드를 보고 풀었지만..)~~
## 내일 할 일
- TOY 30. heapSort
