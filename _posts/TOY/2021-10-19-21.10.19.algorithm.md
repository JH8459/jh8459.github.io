---
title: "[TOY] TOY 32. largestRectangularArea"
category: TOY
excerpt: "[TOY] TOY 32. largestRectangularArea"
sidebar:
  nav: docs
---

![TOY](https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg)
## TOY 32. largestRectangularArea
### 문제
---
히스토그램(histogram)은 표(도수 분포표, 빈도표)로 되어 있는 도수 분포(frequency distribution)를 정보 그림으로 나타낸 것입니다. 예를 들어, 대학교의 한 학과에서 신입생들의 현재 거주 지역을 조사한 결과가 다음과 같다고 가정해 봅시다.

- 서울 2명, 경기 1명, 대전 4명, 부산 5명, 대구 1명, 광주 3명, 제주도 3명...

이 자료를 히스트그램으로 나타내면 각각 높이 2, 1, 4, 5, 1, 3, 3인 직사각형이 왼쪽부터 그려지게 됩니다. 편의상 직사각형의 너비는 1이라고 가정합니다. 이를 그림으로 나타내면 아래와 같습니다.

```
6 |
5 |       x
4 |     x x
3 |     x x   x x
2 | x   x x   x x
1 | x x x x x x x
------------------
```

이 히스토그램 내에서 만들 수 있는 가장 큰 직사각형의 면적은 8입니다 (O로 표시한 부분).

```
6 |
5 |       x
4 |     O O
3 |     O O   x x
2 | x   O O   x x
1 | x x O O x x x
------------------
```

이처럼 임의의 히스토그램 내에서 가장 큰 직사각형의 면적을 리턴해야 합니다.

### 입력
---
#### 인자 1 : histogram
- `number` 타입을 요소로 갖는 배열
- `histogram[i]`는 100,000 이하의 양의 정수
- `histogram.length`는 100,000 이하

### 출력
---
- `number` 타입을 리턴해야 합니다.

### 입출력 예시
---
```javascript
let histogram = [2, 1, 4, 5, 1, 3, 3];
let output = largestRectangularArea(histogram);
console.log(output); // --> 8

let histogram = [6, 2, 5, 4, 5, 1, 6];
let output = largestRectangularArea(histogram);
console.log(output); // --> 12
/*
6 | x           x
5 | x   x   x   x
4 | x   O O O   x
3 | x   O O O   x
2 | x x O O O   x
1 | x x O O O x x
------------------
*/
```

### Advanced
---
- 임의의 히스토그램에서 가장 큰 직사각형의 넓이를 계산하는 효율적인 알고리즘(`O(N * logN)`)이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.

### 힌트
---
- 문제를 어렵게 만드는 것은 높이를 포기하고 너비를 선택할지, 너비를 포기하고 높이를 선택할지 따져봐야 한다는 것입니다.
- 문제를 직접 풀어보고 유심히 관찰하는 것은 문제 해결의 첫 걸음입니다.
- 길이 `n`인 `histogram`에서 가장 큰 직사각형이 `histogram[i]`부터 막대 `histogram[j]`까지라고 가정해봅시다. `i`와 `j`는 `0 ~ n-1` 사이에 놓여 있습니다. (`0 <= i <= j <= n-1`)
- 이 사각형의 높이는 이 구간의 막대 중 가장 낮은 높이를 가진 막대(`histogram[k]`)의 높이와 같습니다.
- 이 사각형은 전체 구간(`0 ~ n-1`) 중 가장 낮은 막대를 포함하고 있거나 그렇지 않은 경우로 나뉩니다.
- 전자는 `i === 0`이고 `j === n-1`인 경우 뿐입니다.
- 후자는 이 직사각형이 차지하는 구간 바깥에 존재합니다. (`k < i`이거나 `j < k`)
- 이 이후부터는 스스로 생각해보시기 바랍니다.
- 구간 트리(segment tree)를 약간 변형하여 해결합니다.

## TOY 32. Solution
### 수도코드
---
그려진 히스토그램 내에서 가장 큰 직사각형을 찾는 문제이다. **Reference Code** 를 보았다.

### 문제풀이 
**(스택을 활용한 풀이)**

---
```javascript
const largestRectangularArea = function (histogram) {
  const n = histogram.length, stack = [];
  let maxArea = 0;

  for (let i=0; i<n; i++) {
  // Check if the current bar is lower than the previous bar in the stack
    while (stack.length && histogram[i] <= histogram[stack[stack.length-1]]) {
      // Calculate the area
      maxArea = Math.max(maxArea, getArea(i, histogram, stack));
    }
    stack.push(i);
  }

  // Calcualte the remaining bar in the stack
  while (stack.length) {
    maxArea = Math.max(maxArea, getArea(n, histogram, stack));
  }

  return maxArea;
};

const getArea = (i, histogram, stack) => {
  const h = histogram[stack.pop()];
  const w = stack.length ? i - stack[stack.length-1] - 1 : i;

  return h * w;
};
```
--- 

**Reference Code**
```javascript
// naive solution: O(N) (search only)
// const rangeMinimum = function (arr, ranges) {
//   return ranges.map((range) => {
//     const [start, end] = range;
//     let min = Number.MAX_SAFE_INTEGER;
//     for (let i = start; i <= end; i++) {
//       if (arr[i] < min) min = arr[i];
//     }
//     return min;
//   });
// };
/* 단순하게 밑변의 모든 경우랑 윗변의 모든 경우를 구해보고 그 중 최댓값을 구하는 코드이기에 시간 복잡도를 많이 소모한다. */

// solution with segment tree: O(logN) (search only)
// object implementaion
const rangeMinimum = function (arr, ranges) {
  // ts: tree start. te: tree end
  // arr의 ts부터 te까지를 tree로 만든다.
  const createMinTree = (arr, ts, te) => {
    // base case
    if (ts === te) {
      return { value: arr[ts] };
    }

    // recursive case
    // 현재 범위를 절반을 기준으로 왼쪽과 오른쪽으로 나눈다
    const mid = parseInt((ts + te) / 2);
    const left = createMinTree(arr, ts, mid);
    const right = createMinTree(arr, mid + 1, te);

    return {
      value: Math.min(left.value, right.value),
      left,
      right,
    };
  };
  const tree = createMinTree(arr, 0, arr.length - 1);

  // rs: range start, re: reange end
  const findMin = (ts, te, rs, re, tree) => {
    // 현재 tree와 구간이 정확히 일치하거나
    // 구간이 tree를 포함할 경우
    if (rs <= ts && te <= re) {
      return tree.value;
    }

    // 현재 tree에 주어진 구간이 겹치지 않는 경우
    if (te < rs || re < ts) {
      return Number.MAX_SAFE_INTEGER;
    }

    // 겹치는 부분이 존재하는 경우
    const mid = parseInt((ts + te) / 2);
    return Math.min(
      findMin(ts, mid, rs, re, tree.left), //
      findMin(mid + 1, te, rs, re, tree.right)
    );
  };

  const mins = ranges.map((range) => {
    const [start, end] = range;
    return findMin(0, arr.length - 1, start, end, tree);
  });
  return mins;
};

// solution with segment tree: O(logN) (search only)
// array implementaion
// const rangeMinimum = function (arr, ranges) {
//   const createMinTree = (arr, ts, te, tree, idx) => {
//     if (ts === te) {
//       tree[idx] = arr[ts];
//       return arr[ts];
//     }

//     const mid = Math.floor((ts + te) / 2);
//     tree[idx] = Math.min(
//       createMinTree(arr, ts, mid, tree, idx * 2 + 1), //
//       createMinTree(arr, mid + 1, te, tree, idx * 2 + 2)
//     );

//     return tree[idx];
//   };

//   // 트리 전체의 높이(루트 노트에서 가장 깊은 리프 노드까지의 거리)를 구하고
//   // 전체 배열의 크기를 구한다.
//   const height = Math.ceil(Math.log2(arr.length));
//   const size = Math.pow(2, height + 1) - 1;
//   const tree = Array(size).fill(null);
//   createMinTree(arr, 0, arr.length - 1, tree, 0);

//   const findMin = (ts, te, rs, re, idx) => {
//     if (rs <= ts && te <= re) {
//       return tree[idx];
//     }

//     if (te < rs || re < ts) {
//       return Number.MAX_SAFE_INTEGER;
//     }

//     const mid = parseInt((ts + te) / 2);
//     return Math.min(
//       findMin(ts, mid, rs, re, 2 * idx + 1), //
//       findMin(mid + 1, te, rs, re, 2 * idx + 2)
//     );
//   };

//   const mins = ranges.map((range) => {
//     const [start, end] = range;
//     return findMin(0, arr.length - 1, start, end, 0);
//   });
//   return mins;
// };
```

## 오늘 느낀 점
이미 너무 유명한 문제였다. 문제가 어려워 힌트를 얻고자 구글링을 해보니 백준, leetcode등 사이트에서 다양한 코드리뷰들이 많이 나왔다. ~~HARD문제다...~~

지금은 이해가 안가지만 깔끔히 정리된 코드가 보여 풀이과정에 우선 올려두었다. 

우선은 **Reference Code**를 보고 이해하는 수준에서 마무리하였다.  ~~다시 풀어 볼 예정~~
## 내일 할 일
- TOY 33. LIS
