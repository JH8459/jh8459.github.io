<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><img src="https://user-images.githubusercontent.com/83164003/131701318-f0ff36c4-1fcc-4f21-b978-18a9d8ec3386.jpg" alt="Algorithm"></p>
<h2 id="빼빼로-데이">빼빼로 데이</h2>
<h3 id="문제">문제</h3>
<hr>
<p>오늘은 빼빼로 데이입니다. 한 회사의 팀장은 출근길에 아몬드 빼빼로 M개와 누드 빼빼로 N개를 구매하여 아침 일찍 출근길에 나섰습니다.</p>

<p>팀장은 자신보다 먼저 출근해 있는 직원들에게 구매한 빼빼로를 전부 나누어 주려고 합니다.<br>
단, 서로 질투하는 경우를 만들지 않기 위해 모든 직원들에게 공평하게 빼빼로를 나누어 주려고 합니다.<br>
직원들은 각각의 빼빼로를 똑같은 개수만큼 받아야 합니다. 빼빼로를 쪼개서 줄 수는 없습니다.</p>

<p>하지만 회사에 도착하기 전이라 몇 명의 직원들이 있는지 모르는 상황입니다.<br>
팀장이 아몬드 빼빼로를 4개, 누드 빼빼로를 8개를 구매 했다면, 다음과 같이 세 가지 방법으로 나누어 줄 수 있습니다.</p>

<ul>
  <li>출근한 직원이 1명이라면 아몬드 빼빼로 4개와 누드 빼빼로 8개를 줄 수 있습니다.</li>
  <li>출근한 직원이 2명이라면 아몬드 빼빼로 2개와 누드 빼빼로 4개를 각각 줄 수 있습니다.</li>
  <li>출근한 직원이 3명이라면 빼빼로를 남기지 않고 공평하게 주는 방법은 없습니다.</li>
  <li>출근한 직원이 4명이라면 아몬드 빼빼로 1개와 누드 빼빼로 2개를 각각 줄 수 있습니다.</li>
</ul>

<p>팀장은 출근한 직원 수에 따라 어떻게 빼빼로를 나누어 줄지 고민하고 있습니다.<br>
여러분이 직원 수에 따라 빼빼로를 나누어 주는 방법을 구하는 솔루션을 제공해 주세요.</p>

<h3 id="입력">입력</h3>
<hr>
<h4 id="인자-1-m">인자 1: M</h4>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Number</code> 타입의 양의 정수 (1 ≤ M ≤ 1,000,000,000)</li>
</ul>

<h4 id="인자-2-n">인자 2: N</h4>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Number</code> 타입의 양의 정수 (1 ≤ M ≤ 1,000,000,000)</li>
</ul>

<h3 id="출력">출력</h3>
<hr>
<ul>
  <li>2차원 배열 <code class="language-plaintext highlighter-rouge">output</code>을 리턴해야 합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">output[i]</code>은 다음과 같은 순서를 가진 길이 3의 배열입니다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">[빼빼로를 받게 되는 직원의 수, 나누어 주는 아몬드 빼빼로의 수, 나누어 주는 누드 빼빼로의 수]</code></li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">output</code>은 <code class="language-plaintext highlighter-rouge">output[i][0]</code>, 즉 ‘빼빼로를 받게 되는 직원의 수’를 기준으로 오름차순으로 정렬합니다.</li>
</ul>

<h3 id="입출력-예시">입출력 예시</h3>
<hr>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">M</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">N</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">divideChocolateStick</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span>
<span class="c1">// [[1, 4, 8], [2, 2, 4], [4, 1, 2]]</span>
</code></pre></div></div>

<h2 id="solution">Solution</h2>
<h3 id="수도코드">수도코드</h3>
<hr>

<ol>
  <li>공약수들을 구해서 배열에 담는다.</li>
  <li>공약수 배열을 순회 하며 <code class="language-plaintext highlighter-rouge">[인원수, 아몬드 빼뺴로/인원수, 누드 빼뺴로/인원수]</code> 배열을 결과값 배열에 담아 리턴한다.</li>
</ol>

<p>공약수는 M과 N을 각각 나누어서 나머지가 0인 수들이므로, 둘중 작은 숫자를 1부터 나눠보며 찾을 수 있다.</p>

<h3 id="문제풀이">문제풀이</h3>
<hr>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">divideChocolateStick</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">divisor</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span><span class="nx">N</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 공약수는 둘중 작은 숫자를 찾아</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">M</span><span class="o">%</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">N</span><span class="o">%</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">// 둘다 나머지가 0으로 나눠떨어지는 숫자들이다</span>
      <span class="nx">divisor</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>  <span class="c1">// 공약수 배열에 담는다.</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">div</span> <span class="k">of</span> <span class="nx">divisor</span><span class="p">){</span>  <span class="c1">// 공약수 배열을 순회하며</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">div</span><span class="p">,</span> <span class="nx">M</span><span class="o">/</span><span class="nx">div</span><span class="p">,</span> <span class="nx">N</span><span class="o">/</span><span class="nx">div</span><span class="p">]);</span>  <span class="c1">// 양식에 맞게 결과값 배열에 넣어준다</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<hr>

<p><strong>Reference Code</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최대 공약수(유클리드 호제법: Euclidean algorithm)</span>
<span class="kd">function</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">divideChocolateStick</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 최대공약수를 구한다.</span>
  <span class="c1">// M, N의 순서는 상관없다.</span>
  <span class="kd">const</span> <span class="nx">GCD</span> <span class="o">=</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">M</span><span class="p">,</span> <span class="nx">N</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//</span>

  <span class="c1">// 약수는 대칭적이므로 제곱근까지만 반복해도 된다.</span>
  <span class="c1">// 예) 36의 약수는 1, 2, 3, 4, 6, 9, 12, 18, 36이다.</span>
  <span class="c1">// 제곱근을 기준으로 양쪽의 값 하나씩 곱했을 때 36이 되기 때문에</span>
  <span class="c1">// 제곱근 보다 큰 약수는 제곱근보다 작은 약수에서 구할 수 있다.</span>
  <span class="kd">const</span> <span class="nx">sqrt</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">GCD</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">sqrt</span><span class="p">;</span> <span class="nx">left</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">GCD</span> <span class="o">%</span> <span class="nx">left</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 최대공약수의 약수인 경우 중 제곱근 보다 작은 약수의 경우</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">left</span><span class="p">,</span> <span class="nx">M</span> <span class="o">/</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">N</span> <span class="o">/</span> <span class="nx">left</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">*</span> <span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">GCD</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 제곱근이 아닌 경우(제곱근 보다 작은)</span>
        <span class="nx">right</span> <span class="o">=</span> <span class="nx">GCD</span> <span class="o">/</span> <span class="nx">left</span><span class="p">;</span> <span class="c1">// 최대 공약수를 제곱근이 아닌 수로 나누면 제곱근 보다 큰 약수를 구할 수 있다.</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">right</span><span class="p">,</span> <span class="nx">M</span> <span class="o">/</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">N</span> <span class="o">/</span> <span class="nx">right</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// '빼빼로를 받게 되는 직원의 수'를 기준으로 오름차순으로 정렬</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">op1</span><span class="p">,</span> <span class="nx">op2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="느낀-점">느낀 점</h2>

<p>시간복잡도 문제인지 TEST CASE 1개를 통과하지 못하였다.</p>

<p><strong>Reference Code</strong>를 참조해보니 모든 약수를 체크하지 않고 제곱근까지 접근하는 로직으로 구현한걸 보았다. <del>귀찮아서 내 코드를 고치진 않았다…</del></p>

<p>최대 공약수를 구하는 알고리즘이 인상 깊었다. 자주 쓰이진 않겠지만 이렇게 구현이 된다는 것 자체가 신기하다…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최대공약수(유클리드 호제법: Euclidean algorithm)</span>
<span class="kd">function</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">%</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
</body></html>
