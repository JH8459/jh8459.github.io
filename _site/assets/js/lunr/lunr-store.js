var store = [{
        "title": "[TIL] 21.07.19 / 코드스테이츠 1일차",
        "excerpt":"    Today I Learned  1. 학습 툴 셋팅     리눅스 환경 (ubuntu os) 에 개발환경 구축.         오늘 느낀 점           코드스테이츠 1일차 앞으로의 강의 일정 및 학습에 대해서 설명을 들었다. 강의라기보다는 줌을 통해서 소통한 느낌.            자기주도적 학습을 강조하였다. 실제로 온라인을 통하여 수업이 진행되며 커리큘럼이 진행되기때문에.. 혼자 학습시간을 지키려 노력하고 이런 노력들 자체도 모두 자기주도적 학습이라 생각한다. 이러한 학습태도는 앞으로 수료시점까지는 당연하며 개발자로써 평생 몸에 지녀야할 기본소양이라 느껴진다. 평생 공부해야지..             내일 할 일      변수, 타입, 함수, 조건문  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.19-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.20 / 1. 변수, 2. 타입, 3. 함수, 4. 조건문",
        "excerpt":"    Today I Learnd  1. 변수     변수를 이용하면 데이터를 편리하게 저장하고 꺼내 쓸 수 있게 한다.   변수의 선언과 값의 할당에 대해서 학습하였다.            선언(declaration)을 통하여 변수를 선언할 수 있다.       할당(assignment)을 통하여 변수에 값을 저장하게 된다. 이때 사용되는 ‘=’은 같다라는 뜻이 아닌 ‘할당 연산자(Assignment operator)’이다.       var, let, const 선언방식의 차이점을 학습하였다.                                                                                   var                 let                 const                                                                         중복선언                 O                 X                 X                                               재할당                 O                 O                 X                                                                  변수명은 다음의 규칙에 따라 명명된다. reference. Camel Case     할당이 없는 변수의 경우 undefined 값을 가진다. (값이 없는게 아닌 해당 undefined값을 가진다)   2. 타입     원시 자료형, 참조 자료형 in JS 를 학습하였다.   typeof 연산자를 통하여 특정 갑의 타입을 확인할 수 있다.   3. 함수          함수는 “작은 기능의 단위”이며 키워드(keyword), 이름(name), 매개변수(parameter), 몸통(body)로 구분된다         function muntiPle(num){ // function(키워드), multiPle(이름), num(매개변수)       console.log(num*1);       console.log(num*2);       console.log(num*3);       console.log(num*4);       console.log(num*5);       console.log(num*6);       console.log(num*7);       console.log(num*8);       console.log(num*9); // body 부분   }                구체적인 입력과 출력을 가지고있으며, 호출 후에는 반드시 return 된다.       4. 조건문          조건문은 어떠한 조건을 판별한다. 그렇기에 비교 연산자(comparison operator)가 필요하다.         3 &gt; 5;\t\t// false   3 &lt; 5;\t\t// true   'hi' === 'hello'\t// false   'hi' !== 'hello'\t// true                 비교 연산자의 결과는 늘 Boolean, 즉 true 혹은 false 이다.       주의 해야 할 비교 연산자 ( == , != ) : 값 만을 비교 (data type은 논외) 하기 때문에 엄격한 비교가 불가능하다. 예외가 많기 떄문에 === 와 비교하면 오류가 많다.                두가지 조건이 한번에 적용되는 경우가 필요 할 땐, 논리 연산자(logical operator)를 사용하여 조건문을 작성한다.         isStudent &amp;&amp; isFemale;\t// 학생이면서 여성일때 통과   isStudent || isFemale;\t// 학생이거나 여성이면 통과   !isStudent &amp;&amp; isFemale;\t// 학생이 아니면서 여성일때 통과                truthy와 falsy가 조건문에서 작동하는 방식을 이해할 수 있다.             기억해야 할 6가지 falsy 값, 해당 값들은 false로 반환되므로 if문이 실행되지 않는다.                    false,  null, undefined, 0, NaN, ''                            5. HTML     하이퍼텍스트를 (링크) 가장 중요한 특징으로 하는 마크업이라는 형식을 가진 컴퓨터 프로그래밍 언어.            Markup이란? 그 파일이 프린터로 출력되거나 화면에서 어떻게 보여야할 것인지를 나타내기 위해 또는 그 문서의 논리적인 구조를 묘사하기 위해서, 텍스트나 워드프로세싱 파일의 특정위치에 삽입되는 일련의 문자들이나 기호들을 말한다. 마크업에 사용되는 표지를 흔히 ‘태그’라고 부른다.           태그 설명은 reference. HTML tag         오늘 느낀 점           코드스테이츠 2일차.. 잠을 엄청 설쳤다… 부담감 때문인가? 스트레스 컨트롤도 중요해보인다…            블로그에 학습내용 포스팅은 계속 진행할 예정.       구글은 신이다.            mdn 키워드 mdn 자체가 읽기가 어려워….. 익숙해지자       키워드를 통한 검색 생활화 하기. 영어로 검색하자       Stack Overflow 애용하기 아직은 봐도 잘 모르겠다…                처음으로 둘 이상의 인원이 모여 ZOOM을 통한 협업으로 코드 풀이를 해보았다. 생각보다 ZOOM 을 통한 협업은 불편하지 않았다, 화면쉐어링 등 기본 제공하는 툴들만으로도 의견 전달에는 문제가 없었다. pair 훈련 자체가 오늘 첫 시행이라 난이도가 낮았기에 시간은 제공된 시간 보다는 빠르게 소화할 수 있었다. 앞으로는 거부감 없이 할 수 있을 듯 하다.       생활코딩 수업 html, css, javascript 다시 듣기. 웹애플리케이션만들기 수업정도만 겉핣기식 따라하기 수업은 머릿속에 개념만 넣는 정도였다. 조금더 심화내용 수업을 들으며 개념확장 필요하다 생각된다.         내일 할 일           문자열            생활코딩 html css             html은 너무 기본적인 문법 및 코드스테이츠 커리큘럼과는 맞지 않는 방향이라 개념만 정립 후 css 수업으로 진행 예정.          ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.20-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.21 / 1. 문자열, 2. 반복문, 3. 호이스팅, 4. React",
        "excerpt":"    Today I Learnd  1. 문자열     문자열은 배열처럼 요소 하나씩 접근이 가능하다. index로 접근은 가능하지만 쓸 수는 없다는 (read-only) 특징을 가진다.   문자열은 + 연산자를 쓸 수 있다. string 타입과 다른 타입 사이에 + 연산자를 쓰면, string 형식으로 변환된다. (toString)        문자열의 표현방식중 템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴이다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있다. 이전 버전의 ES2015사양 명세에서는 “template strings” (템플릿 문자열) 라고 불려 왔다.   ES6는 템플릿 리터럴(Template literal) 이라고 불리는 새로운 문자열 표기법을 도입하였다. 템플릿 리터럴은 일반 문자열과 비슷해 보이지만, ‘ 또는 “ 같은 통상적인 따옴표 문자 대신 백틱(backtick) 문자 ` 를 사용한다.        var a = 5; var b = 10; console.log(\"Fifteen is \" + (a + b) + \" and \\n not \" + (2 * a + b) + \".\"); // \"Fifteen is 15 and // not 20.\"  var a = 5; var b = 10; console.log(`Fifteen is ${a + b} and not ${2 * a + b}.`); // \"Fifteen is 15 and // not 20.\"           2. 호이스팅     함수 안에 있는 선언들을 모두 끌어 올려서 해당 함수 유효범위(scope)의 최상단에 선언하는 것을 말한다.   자바스크립트 해석기(parser)는 함수가 실행 되기전 해당 함수를 한 번 훑는다.   함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행시킨다.   이는 실제로 메모리 변화라던지, 코드가 끌어 올라가는 물리적 이동이 아닌, 자바스크립트 해석기 내부적으로 끌어올려서 처리하는것이므로 코드의 물리적 변화는 이뤄지지 않는다.   var 변수 선언과 함수 선언문 에서만 호이스팅이 일어난다.   var 변수 / 함수의 선언만 위로 끌어 올려지며, 할당은 끌어 올려지지 않는다.   코드의 가독성과 유지보수를 위해 호이스팅은 가급적 일어나지 않도록 해야 한다.            호이스팅을 잘 모르더라도 함수와 변수의 선언은 가급적 코드 상단부에서 이뤄지게끔 하자.       var 선언 방식은 불분문한 호이스팅의 주범이다. let/const 선언방식을 써서 불분문한 호이스팅이 이뤄지지 않게끔 통제가 필요하다.           3. 반복문  4. react  찍먹     생활코딩 React 수업을 진행하며 첫 챕터부터 가장 많이 들은 단어는 ‘가독성’, ‘재사용성’, ‘유지보수’ 이다. 세 단어 모두 다르지만 맥락은 비슷하다. Component를 어떻게 분리하며, 재사용 하는지가 이번 수업의 핵심이라 생각이 든다.            jsx (facebook 에서 개발된 유사 js) 를 이용한 효율적인 코딩.       component 를 통한 가독성 향상       build 를 통한 효율적인 네트워크 리소스 관리 이점.                 오늘 느낀 점           ZOOM 협업은 어제보다 익숙하다, 확실히 조건문부터는 코드풀이 난이도가 급 상승하였다. 좀더 간결하게 코드를 짜보자는 pair 와 의견을 나누고나서 코드의 재사용화, 다양한 기존 함수나 메소드를 통하여 간결한 문장 생성을 하려고 pair분과 소통하다보니 주어진시간이 짧게 느껴졌다.            pair에게 배울점이 많았다. 우선 같은 문항을 보았을때 짧은 시간내에 도출해 내는 의견들이 대게로는 비슷하였지만, 풀이과정에서 다른 방식으로 접근할 때가 있었다. 해당 부분은 전혀 생각지 못한 부분들도 있었으며, 생각은 해보았지만 어느 순간 막혀서 포기했던 접근방식들 또한 있었다. 이러한 생각을 공유할 수 있는 경험은 좋은 경험이었다.            2015년 이후 ES6에서 새롭게 추가되었다는 방식의 템플릿 리터럴을 오늘 처음 접하였다. 기존 es5 이전에서는 템플릿 문자열로 불려 왔는데, 이는 문법 정도로 해석하면 될 듯 하다. 기존 쓰는 방식인 표현식 삽입법은 직관적이지 않다는 단점과, 코드 작성 자체의 불편함이 공존하였다, 하지만 ES6 이후 템플릿 리터럴을 사용하게 되면, 이를 더욱 읽기도 쉬우며 코드 작성 또한 직관적이고 편리하게 관리 할 수 있게 되었다.       let name = \"KJH\"; let age = 32; console.log(name + 'is' + age + ' years old.');\t\t// KJH is 32 years old. console.log(`${name} is ${age} years old.`);\t\t// KJH is 32 years old.                그 외 ES6 이후 편리한 점은 호이스팅 (Hoisting) 이라는 개념이다. 자세한 개념은 위 학습한 내용에 기술해두었다. 개념만 말하자면, 변수 및 함수 선언이 작성한 코드의 상단으로 옮겨진다는 개념이다. 물론 실제로는 그렇지는 않지만, 이정도로만 해석하고 넘어가도록 하자.             내일 할 일           문자열            생활코딩 html css      ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.21-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.22 / 1. 반복문 코플릿",
        "excerpt":"    Today I Learnd  1. 반복문 코플릿          오늘 학습한 내용 중 가장 인상 깊었던 코드 풀이를 다시 한번 복습해보겠다. 수를 입력받아 홀수인지 여부를 리턴해야 한다. 반복문(while)문을 사용해야 합니다. 나눗셈(/), 나머지(%) 연산자 사용은 금지됩니다. 0은 짝수로 간주합니다.          /*---입출력 예시---*/ let output = isOdd(17); console.log(output); // --&gt; true output = isOdd(-8); console.log(output); // --&gt; false  /*---함수 작성---*/ function isOdd(num) {   let i = 0;\t\t// while 문의 조건식을 검색할 인자. 변수 i 선언 및 초기값 0 할당.   let evenOdd = 1;\t// 짝수와 홀수를 evenOdd에 담긴 양수(홀수)와 음수(짝수)의 값으로 판단 할 예정이므로 evenOdd 변수 선언 (초기 값은 1을 주어서, 0을 짝수로 간주한다. ex)num = 0일 경우 단 한번의 while문 만 실행되므로, evenOdd = -1(음수=짝수) 로 반복문을 나가게 된다. )    while(i&lt;=Math.abs(num)){\t// num값이 음수로 들어 올경우 Math.abs 메소드를 이용하여 절대값으로 연산한다.     evenOdd *= -1;\t\t// evenOdd 값에 -1을 곱하여 재 할당한다.     i++;\t\t\t// i를 1만큼 증가시킨다.   }\t\t\t\t// Math.abs(num)까지 i 가 while문 안을 수행 후 } 를 빠져나오면 evenOdd는 -1 또는 1의 값 두가지 값중 한가지 값을 내포한다.    if(evenOdd &gt; 0)\t\t// evenOdd의 값이 양수일 경우 true 값을 return 하여 홀수임을 나타낸다     return true;   else \t\t\t\t// evenOdd의 값이 그 외에 경우 false 값을 return 하여 짝수임을 나타낸다     return false; }                 오늘 느낀 점           읭?.. 반복문 개념학습은 1시간 코드풀이는 5시간.., 이중반복문 좀(좀 많이) 애먹었지만 확실히 문제를 풀어가며 pair분과 머리를 맞대며 도출해내는 과정은 희열감이 느껴지기도 했다. 확실히 개념 수업이라 일컫는 TEXT 읽는 것 보단 직접 짜본 내 코드들이 내 학습에는 더욱 도움이 되는 듯 하였다, 실제로 몇시간은 금방금방 지나가는 기적을 겪였다…            기본 수업 외에 오늘은 내 학습을 못한듯하다… 어젠 분명 리액트 수업이 재밌었는데.. 개발환경 구축하고 오늘은 터미널 켜보지도 않았다. 스트레스 컨트롤도 중요하다. 장기전이라 생각하고 임하자.             내일 할 일      다음주 수업은 새로운 pair 와 계산기, 짝수 생성기(?) 간단한 프로그래밍 코딩을 할 예정인듯 보인다. 이번주 수업 내용 복습 및 부족한 부분 check 는 내일 필수적으로 이뤄져야 할 듯 하다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.22-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.23 / 1. 소비자들과 맞닿는 영역에서의 CSS",
        "excerpt":"    Today I Learnd  1. CSS          CSS 문법        선택자(selector) 에는 태그이름이나 id 또는 클래스 등이 올수있다. 선택자로 특정 요소를 선택할수 있으며, 선택 후 중괄호 안의 선언 블럭에서 이 선택자에 적용 할 내용들을 작성한다.            id는 한 문서에 단 하나의 id 값을 가질수 있으며 # 기호를 이용하여 선택한다.       class는 동일한 기능을 하는 css를 여러 요소에 적용하기 위해 선택되며 . 기호를 이용하여 선택한다.           속성은 선택자 안에 요소로써 적용할 수 있는 내용이다. 속성과 값의 끝에는 세미콜론 ;을 붙여 속성끼리 구분한다.            다양한 속성 값은 해당링크에서 참조하자 CSS 참고서 -MDN.                박스모델은 레이아웃 설계시 가장 주의하여 구성해야 한다. (줄바꿈이 되는 박스(block), 옆으로 붙는 박스(inline, inline-block)가 있기에 설계시 미리 계획 후 설계해야한다.)                                              block           inline-block           inline                                           줄바꿈 여부           O           X           X                             기본적으로 갖는 너비(width)           100%           글자가 차지하는 만큼           글자가 차지하는 만큼                             width, height 사용 가능여부           O           O           X                                  줄바꿈이 되는 태그 : &lt;h1&gt; &lt;p&gt;, … 그 외 태그 알아보기 : Block-level elements MDN       줄바꿈이 되지 않는 태그 : &lt;span&gt;, … 그 외 태그 알아보기 : Inline elements MDN                박스를 구성하는 요소는 다음 그림안의 요소들을 기억하자.                    오늘 느낀 점           질문의 중요성, 이제껏 모르는 점들을 구글링만으로 검색을 해보았다. 하지만 구글은 너무 다양한 질문들이 존재하였다.  아고라스테이츠  를 보니 나와 비슷한 수준, 비슷한 경험을 가진 사람들이 올린 질문들이 많으니 활용하는게 좋아보인다.            이제껏 CSS는 디자이너(?) 의 영역이라 생각하며 소홀히 해왔는데, 잘못생각했다… 반응형 웹이라던지 소비자들과 맞닿는 영역에서 이뤄지는 CSS도 굉장히 중요하다 생각된다.             예를 들면, 오늘의 집과 집꾸미기 사이트를 보면 CSS의 중요성을 한 눈에 볼 수 있다 생각한다. (오늘의집과 집꾸미기는 필자와는 상관없습니다…) (21.07.23 기준 작성)                                스크롤을 내려도 구매옵션과 구매란이 따라오는 CSS 디자인은 상품상세설명을 쉽게 보면서 구매까지 소비자가 불편함없이 프로세스가 이어진다.                         반면 스크롤을 내리면 구매옵션과 구매란이 따라 오지 않는 고정적인 CSS 디자인은 소비자에게 옵션암기(!?) 라는 불편함을  강요를 한다. (구매색상이 마음에 들어 구매하려고 상단으로 올려서 모든 옵션을 다 고른뒤 구매버튼을 누르면 “아 색상이 뭐였지..?” 라는 생각이 다시 떠올라 웹페이지를 다시 내려본다는 등의 불편함이 야기될수 있음)                 내일 할 일      CSS 실습 필요. 학습보다는 다양한 id, class를 선언해가며 속성값을 주는 실습이 필요로해보인다.   구글의 기술트렌드 리포트를 보니 과거에는 jQuery 가 주요 기술 트렌드였다면 16~18년도 이후  부터는 그 자리를 React에게 내주었다는 리포트를 오늘 학습도중 알게되었다.  그렇기에 React는 꾸준히 학습이 필요로 보인다… 아직 찍먹 수준이라 본수업이 다가오기전 매주 주말 통하여 충분한 학습이 필요로 할 듯 하다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.23-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.26 / 1. 계산기 실습",
        "excerpt":"    Today I Learnd  1. 계산기 실습 : github repository            오늘 느낀 점     html, css, js 세분화 된 학습이 아닌, 세가지의 모든 기능을 더한 웹페이지 만들기는 생각보다 상호간 작용을 염두해야 원활이 구현된다.         내일 할 일     계산기 실습 level nightmare 까지 구현해보기.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.26-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.27 / 1. 계산기 실습(nightmare)",
        "excerpt":"    Today I Learnd  1. 계산기 실습 : Github 참조.            오늘 느낀 점     점점.. 수업에 내가 밀려나간다. 장기전이다, 멘탈 관리. 모르는 부분이있다면 붙잡고 끙끙 앓기보다는 조금더 학습 후 주말중 부족한 부분을 다시 학습하여 멘탈 관리 및 부족한 부분을 메꿔나가야 할 듯 하다.   CSS .. 만만히 볼 분야가 절대 아니다. JS를 통하여 CSS를 조작하거나 제어하는 분야 말고도 특정한 상태나 규칙에 따라 CSS 스스로 동작하는 선택자들 또한 존재하였다. 단순 코드 몇줄 만으로도 코드가 다이나믹해지는 효과를 볼 수 있다.   선택자에는 태그, id, class만 선택되는줄 알았다..복합선택자, 부모/자식 개념 만만하지않다…         내일 할 일     내일 일정은 리눅스 기초 수업이다. React를 맛만 보았을때 node.js 개발 환경은 이미 내 PC에 셋팅을 해두었다. 수업방향에 맞춰서 다시 세팅해보고 React 또한 다시 학습해보는 기회를 가져봐야겠다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.27-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.28 / 1. Linux CLI, 2. 패키지와 패키지 매니저, 3. Node.js, 4. React",
        "excerpt":"    Today I Learnd  1. Linux CLI     명령 줄 인터페이스(CLI, Command line interface) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식을 뜻한다. 즉, 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다.   2. 패키지와 패키지 매니저  2-1. 패키지     리눅스에서 빈번하게 사용하는 ‘패키지’란 커널 및 라이브러리 버전의 배포판 환경에 맞추어 빌드한 실행파일을 압축한 것이다.   우분투 환경에서는 데미안 스타일의 패키지 방식을 이용하기에 해당 방식을 학습하였으며, 해당 환경으로 환경을 구성하였다.   2-2. 패키지 매니저     APT(Advanced Packaging Tool)는 데비안과 우분투를 포함하여 데비안 계열 리눅스 배포판들의 주 패키지 관리 도구이다.   3. Node.js     쉽게 말하면 JavaScript 런타임(Runtime)이다., 여기서 런타임이란 프로그래밍 언어가 구동되는 환경을 뜻한다. Node.js 는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임이다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이다.   3-1. Node.js를 왜 사용하나?          Node.js 라이브러리 내의 API는 모두 비동기식이다. None-Blocking 즉, 멈추지 않는다는 의미이다. API를 실행 하고 완료되기까지 기다리지 않고 바로 다음 API를 실행한다. 그리고 예전에 실행한 API가 값을 반환하면 이벤트 루프가 이를 확인하고 값을 받아온다. 단일 쓰레드 모델을 사용하며, 이벤트 메커니즘을 통하여 서버가 멈추지 않고 반응할 수 있기에 확장성이 좋다.       위와같은 특징때문에 데이터를 실시간을 다루는 애플리케이션이나 싱글페이지 애플리케이션(SPA), 입출력이 잦은 애플리케이션을 개발할 때 뛰어난 효율성을 발휘할 수 있다. 다만, 싱글 쓰레드 모델이기 때문에 하나의 작업 자체가 시간이 많이 걸리면 전체 시스템의 성능이 아주 급격하게 나빠지므로 CPU 사용률이 높은 애플리케이션에선 권장되지 않는다.       3-2. nvm ?          NVM(Node Version Manager)은 Node.js의 버전을 관리하기 위한 도구이다. 개발툴들이 다양해 질수록 경우에 따라서 Node.js의 버전을 달리 사용해야 할 필요성이 생기게되었다.       사용목적은 협업 혹은 다양한 프로젝트를 동시에 진행 할 때 다양한 라이브러리 / 프레임워크 / 개발 툴들의 버전 호환 문제를 피할수있는 가장 편리한 방법중 하나이기 때문이다. 또한 nvm을 통하면 다양한 버전의 Node.js를 설치를 간편하게 할 수 있으며, use 커맨드를 이용하여 필요한 Node.js의 버전으로 스위칭 할수 있게된다. 디폴트 버전 설정, 설치한 버전들의 리스트 확인, 필요 없는 버전 삭제 등 소위 버전 관리가 매우 간편해 진다.       3-3. npm ?     하나의 프로그램은 다양한 모듈이 합쳐져서 만들어진다. 이때 개발자는 이 모듈을 모두 개발할 이유가 없다. 이미 만들어진 검증된 코드(모듈)을 잘 가져와서 효율적인 방법으로 쓰게끔 도와주는게 npm(Node Package Manager)이다.   3-4. package.json     프로젝트 전반에 관한 정보를 정의하고 의존하는 패키지 버전 정보를 명시해주는 파일이다.   package.json 파일과 함께 프로젝트 배포시 이점은 상당하다. 해당 프로젝트가 포함하고 있는 모든 모듈을 모두 전달하지 않아도, package.json 에 필요 모듈이 모두 명시되어 있기 때문에 사용자가 배포자가 모든 모듈을 배포하지 않아도 필요한 모듈은 npm을 통하여 직접 다운받아서 쓰면 되기때문이다.   4. ~ 코딩애플 React 기초 3강         오늘 느낀 점          아직 CLI환경에서의 작업은 익숙하지 않다. 진짜 컴퓨터와 대화하는 느낌이랄까…GUI가 확실히 편리하지만, 개발자는 컴퓨터와 가까운 직업이라 생각하므로 필히 학습하고 넘어가자.            Node.js 에서 npm 을 통하여 사용하는 패키지들은 프로젝트의 배포와 설치의 유연함이 강력했다. package.json 에 명시된 정보만으로 빠르게 프로젝트에 필요한 모듈들을 파악할 수 있었으며, npm install 명령어 한줄로 필요한 모듈들의 모음인 패키지를 받을수 있었다.            React 에서의 변수는 일반적인 변수 선언보다는 state를 쓰는게 웹앱 사이트 제작에 도움이 된다. 갓 state             내일 할 일     생활코딩 리액트 강의는 구 버전임을 깨닫고 유튜브 채널 중 코딩애플 님 클론 코딩을 우선 따라하기 방식으로 학습하기로 결정.            4강 수업전, 블로그 글 리스트 UI 3개 완성하기 (제목 내용은 state 이용)           React 와 DOM 은 필히 선행학습이 수반되어야 할듯하다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.28-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.29 / 1. Git",
        "excerpt":"    Today I Learnd  1. Git     Git이란 분산형 버전 관리 시스템(Version Control System) 의 한 종류이며, 빠른 수행 속도에 중점을 둔다.            “버전 관리 시스템” 이란 파일 변화를 시간에 따라 기록했다가 이후에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다. 동일한 정보에 대한 여러 버전을 관리하게 되며, 버전을 통해 시간적으로 변경 사항과 변경 사항을 작성한 작업자를 추적할 수 있다.           1-1. GitHub     Git을 통하여 버전관리를 한다 이미 언급을하였다. 그렇다면 Github는 무엇일까? Github는 Git Repository를 관리할 수 있는 클라우드 기반 서비스이다. 즉 Git으로 버전을 관리하는 폴더에 대해서 Github을 통해 여러 사람들이 공유하고 접근할 수 있게되기때문에 Git이 분산형 버전 관리 시스템으로 불리울 수 있게된다.   1-2. Git Repository     내가 작업하는 소스 코드 폴더가 버전 관리를 받게 하기 위해서는 내 폴더를 Git의 관리 아래에 두어야 한다. 이때 Git으로 관리되는 폴더를 Git repository 라고 부른다. Git repository 는 Remote Repository와 Local Repository 두 종류의 저장소를 제공한다.            Remote Repository : 원격 온라인 서버 상의 저장소이다. 여러 사람이 함께 공유가 가능하다.       Local Repository : 내 컴퓨터의 저장소이다. 개인 전용 저장소이며 내 컴퓨터 안의 저장소이기 때문에 오프라인 작업또한 가능하다.                  1-3. Git을 통한 작업시 WorkFlow        Remote에 있는 다른 Repository에서 Fork를 해서 Remote에 있는 내 Repository에 가지고 온다.   이 코드를 수정하기 위해서는 내 컴퓨터로 가져오는 작업이 또 필요하다. 내 컴퓨터에서 작업을 하기 위해서 git clone을 한다.   이제 내 컴퓨터의 작업 공간 (work space) 에서 작업에 들어간 파일들을 git의 관리 하에 있는 상태로 변경할 수 있다. 이 영역을 staging area라고 말한다. 즉, staging area에 들어오지 않은 파일은 unstaged 혹은 untracked file이라고 말하며, staging area에 있는 파일들은 staged 된 파일이라고 말할 수 있다. git commit 을 하기 위해서 현재 Local Repository에 변경된 파일들이 어떤것인지 확인하려면 git status를 통하여 staging area와 untracked files 목록에 어떤 것들이 있는지 확인할 수 있다.   staging area에 들어온 파일들은 git commit이 가능하다. commit을 하고 나면 내 remote repository에 git push 해서 commit 기록을 remote 에도 남겨줄 수 있다. 남긴 commit들이 잘 기록되어있는지 확인하려면 git log를 통하여 로그들을 터미널 창에서 확인할 수 있다.   git push를 완료한 후 이제 remote의 원래 레파지토리에 pull request를 보내면 Remote Repository로 내가 수정한 코드를 업로드할 수 있다.   2. 코딩애플 React         오늘 느낀 점     깃깃깃깃깃. 말로만 들었지 왜 협업에 유리하며, 분산관리에 유리하며.. 버전관리에 유리하며.. 많은 기업들이 해당 툴을 모두 사용하는지 짧은 시간이지만 크게 와닿았다. 협업 과정 중 commit을 들여다보면 누가..언제..몇분전에.. 무슨작업을..무슨코드를 뻘짓(?)거리 하였는지 적나라하게 나오는걸 보니 정말 투명하고 실시간으로 코드유지가 된다는 느낌을 받았다.         내일 할 일     이번주 마무리. 배열,객체 수업 후 배열은 코플릿 페어 진행이 예정되어있다. 저번주 반복문 코플릿이후 오랫만의 코플릿이기때문에 걱정된다. 배열은 오늘 자기 전 개념정도만 한번 훑고 자야겠다. 아직도 소수 찾는 이중반복문이 머릿속에 그려진다.   리액트 선행학습 위한 코딩애플…유료다. 유튜브 코딩앙마 님의 수업이 유익해보이며 무료로 시청이 가능해보인다. 이번주~다음주 중 리액트 클론 코딩 및 따라하기는 우선 코딩앙마님의 해당 수업으로 진행해볼 예정이다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.29-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.07.30 / 1. 배열, 2. 객체",
        "excerpt":"    Today I Learnd  1. 배열     배열은 순서가 있는 값이다. 순서는 인덱스(index)라고 부르며, 1이 아닌 0부터 매긴다.            배열의 값 접근은 인덱스를 이용하여 값에 접근한다.           [] 대괄호를 이용해서 배열을 만드며, 각각의 원소(element)는 쉼표(comma)로 구분해준다.   let myNumber = [ 73, 98, 86, 61, 96]; myNumber[3]; // 61 myNumber[4] = 200; // 배열의 4번째 인덱스의 값을 200으로 변경 myNumber; // [73, 98, 86, 61, 200];      배열의 속성에 접근하거나 메소드를 추가할때는 .(온점)을 이용하여 접근한다.            myNumber.length;  // 4  : 온점(dot)을 이용해서 변수가 가지고 있는 속성(property)에 접근할 수 있다.       myNumber.push(98);  // myNumber 배열 끝에 96이라는 값을 추가한다 : 온점(dot)을 이용해서 관련된 명령(method)도 실행할 수 있다. 명령을 실행할 때는, 함수를 실행하듯 괄호를 열고 닫는 형태로 실행한다.           1-1. 배열의 기초 메소드          Array.isArray : 배열의 기본 type은 “object”이다. 그래서 특정 값이 배열인지 아닌지 typeof()로 판별할 수 없다. Array.isArray()는 배열인지 아닌지 판별할 수 있는 메소드이다. 반환값은 boolean 이다.       let num = 10; let words = ['피', '땀', '눈물']; typeof num;  // \"number\" typeof words;  // \"object\" Array.isArray(num)  // false Array.isArray(words)  // true                push, pop :  배열의 뒤에서 요소를 추가 및 삭제할 수 있다. (mutable)       let words = ['피', '땀', '눈물']; words.push('BTS');  // 4 (기본 리턴 값은 '.length')   words;  // (4) , ['피', '땀', '눈물', 'BTS') , 원본 값이 바뀐다(mutable). words.pop();  // 'BTS' (기본 리턴 값은 삭제된 값이 리턴된다.)   words;  // (3) [\"피\", \"땀\", \"눈물\"]                 shift, unshift : 배열의 앞에서 요소를 추가 및 삭제할 수 있다. (mutable)       2. 객체     객체란 키(key)와 값(value)으로 구성된 프로퍼티(property)의 정렬되지 않은 집합이다.            중괄호를 이용하여 객체를 만드며 그 내부에 키와 값은 쌍으로 구성되며 (key-value paor), 키-값 쌍은 쉼표(comma)로 구분해준다.              2-1. 객체의 사용     객체의 값을 사용하는 방법은 두 가지가 있다.     let user = { firstName : 'JeongHyun', lastName : 'Kim', email : 'kk_ong2233@naver.com', city : 'Seoul' };                Dot notation : 객체명 뒤에 .을 통하여 key값에 접근한다.       user.firstName;  // 'JeongHyun' user.city;  // 'Seoul'                Bracket notation : 객체명 뒤에 [] 대괄호 안 값이 문자열처럼 '' 안에 들어가야한다.       user['firstName'];  // 'JeongHyun' user['city'];  // 'Seoul'                키 값이 동적일 경우에는 브라켓 노테이션을 반드시 사용한다.         let person = {     name : 'Kim',       age : 20   } \t   function getProperty(obj, propertyName){     return obj[propertyName];   } \t   let output = getProperty(person, 'name');  // 'Kim'   let output = getProperty(person, 'age');  // '20'           2-2 객체의 추가/삭제 및 확인          dot/bracket notation을 이용해 값을 추가할 수 있다.         user.age = '20';  // user 객체에 age = '20' 의 키값쌍 추가   user.['city'] = 'Seoul';                delete 키워드를 이용해 삭제가 가능하다.         delete user.age;  // user 객체에 있는 age 키 제거                in 연산자를 이용해 해당하는 키가 있는지 확인할 수 있다.         'age' in user; // false   'city' in user; // true                 오늘 느낀 점     배열은 문자열과 유사하다. 문자열은 원본을 수정하지 않았기에 문자열을 복사해서 가져온뒤 작업을 많이하였다. 하지만 배열에서는 원본을 바꾸는지 여부가 중요하다 (mutable 여부). 무분별한 원본값을 바꾸는 행위는 예상치 못한 버그(?)를 야기시킬수 있기에 잘 생각한 뒤 사용해야 할것같다.         내일 할 일     주말이며 다음주 부터는 8월이다. 이번달 7월간의 회고 기록도 포스팅으로 남겨봐야겠다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.30-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.02 / 1. 객체 코플릿",
        "excerpt":"    Today I Learnd  1. 객체 코플릿     객체는 배열과 다르게 순서성을 가지지 않으며, 묶음으로 된 데이터에 이름을 붙혀, 의미를 부여할 수 있다. 배열또한 각 값이 하나의 변수로 묶인 데이터이지만, 각 index가 어떤 정보를 갖고 있는지 알아야지 해당 값에 접근이 용이하다.            객체는 키쌍값(key-value pair)으로 이루어져 있다.            객체의 값을 사용하거나 추가할 땐 Dot notation, Bracket notation 방식을 사용한다   할당된 키와 값을 지울 땐 delete 키워드를 이용해 삭제가 가능하다.        객체 안에 특정한 키가 있는지 확인이 필요할 땐, in 연산자를 이용하여 확인한다.            for ... in : 상속된 열거 가능한 속성들을 포함하여 객체에서 문자열로 키가 지정된 모든 열거 가능한 속성에 대해 반복합니다.           for (variable in object) { ... }                 variable : 매번 반복마다 다른 속성이름(Value name)이 변수(variable)로 지정됩니다.       object :  반복작업을 수행할 객체로 열거형 속성을 가지고 있는 객체.              Note: for…in은 인덱스의 순서가 중요한 Array에서 반복을 위해 사용할 수 없습니다.    2. Github 블로그 이사         블로그를 velog에서 git에서 jekyll 환경으로 세팅하는 블로그로 변경해보았다.     https://honbabzone.com/ 해당 블로그를 통해서 minimal-mistakes 테마를 이용하여 세팅을 해보았다. 우선 불필요한 포스팅을 줄이고 오늘 배운 내용 및 시간을 어떻게 보냈는지, 어떤점을 느끼고 발전했는지에 대한 부분만 짚고 넘어갈 예정이다.            오늘 느낀 점      어렵다… git blog .. 8.1 ~ 8.2, 이틀동안 지금 챕터진행 말고 블로그 셋팅 씨름한 덕에 포스트 commit 하고 푸쉬할 수 있게되었다. 물론 지금 테마 및 셋팅이 맘에 드는건 아니지만, 일단 나중으로 미루고 포스팅이 우선인듯하여 우선 급하게 셋팅을 마무리 지었다.   추후 상단 nav에 위치한 메뉴버튼들을 좌측 사이드바로 옮기고 싶다.  스크롤에 반응하는 author_ profile 목록은 그렇게 유용하진 않는듯하다..   사소한거지만.. html 구조파악에 시간이 너무 오래걸렸다. 셋팅 위한 한글 포스팅도 많이 없는 상황이다 (상단에 올려둔 7271kim 님의 블로그 세팅이 거의 대중화(?)되었다고 보면 될 듯하다. 우선은 천천히 코드및 구조를 뜯어보며 변경해보는거로 미뤄둬야겠다.         내일 할 일     CSS 챕터 학습   남은 기존 posts 이동하기 &amp;&amp; 7월 19일 부터 달려온, 보름정도의 기간 self-check 회고 posting 하기 (blog setting 은 현재 상태로 만족하고 학습에 몰두해야겠다.)   DOM 개념 잡기  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.02-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.03 / 1. 다양한 CSS 셀렉터, 2 . CSS layout, 3. HTML/CSS 목업 와이어프레임 실습",
        "excerpt":"    Today I Learnd  1. 다양한 CSS 셀렉터  h1 {  }  // 셀렉터 div {  }    * {  }  // 전체 셀렉터  section, h1 {  }  // 태그 셀렉터  #only {  }  // ID 셀렉터  .center {  }  // class 셀렉터  a[href] { }  // attribute 셀렉터 p[id=\"only\"] { }  header h1 {}  // 후손 셀렉터  header &gt; p { }  // 자식 셀렉터  section + p { }  // 인접 형제 셀렉터  section ~ p { }  // 형제 셀렉터  a:hover { }  // 가상 셀렉터 a:active { }  input:checked + span { }  // 요소 상태 셀렉터 input:enabled + span { }  p:first-child { }  // 구조 가상 클래스 셀렉터 ul &gt; li:last-child { }  input:not([type=\"password\"]) { } // 부정 셀렉터 div:not(:nth-of-type(2)) { }  input[type=\"text\"]:valid { }  // 정합성 확인 셀렉터 input[type=\"text\"]:invalid { }      새로 학습한 셀렉터          attribute 셀렉터  ,  부정 셀렉터         2-1 . CSS layout     &lt;div id=\"container\"&gt;   &lt;div class=\"col w10\"&gt;      &lt;div class=\"icon\"&gt;아이콘 1&lt;/div&gt;     &lt;div class=\"icon\"&gt;아이콘 2&lt;/div&gt;     &lt;div class=\"icon\"&gt;아이콘 3&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"col w20\"&gt;     &lt;div class=\"row h40\"&gt;영역1&lt;/div&gt;     &lt;div class=\"row h40\"&gt;영역2&lt;/div&gt;     &lt;div class=\"row h20\"&gt;영역3&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"col w70\"&gt;     &lt;div class=\"row h80\"&gt;영역4&lt;/div&gt;     &lt;div class=\"row h20\"&gt;영역5&lt;/div&gt;   &lt;/div&gt; &lt;/div&gt;   .w70 { width: 70%; } .h40 { height: 40%; }  * {  // 기본 스타일 제거 (box-sizing)   box-sizing: border-box; }  body {  // 기본 스타일 제거 (여백 제거)   margin: 0;   padding: 0; }     박스의 시작을 정확히 (0,0)의 위치에서 시작하고 싶은데, &lt;body&gt; 태그가 가진 기본 스타일에 약간의 여백을 포함하지 않아 계산에 어려움이 있다. 위에 언급한 문제를 해결할 몇 줄의 코드를 적용시키면, 기본 스타일링을 제거하여 디자인한 대로 레이아웃을 구현할 수 있습니다.   이렇게 클래스 이름과 구현을 1:1로 일치시켜 아주 작은 단위로 CSS를 작성 기법을 Atomic CSS 방법론이라고 한다.     2-2. CSS layout (flexbox)     flexbox로 레이아웃을 구성한다는 것은, 박스를 유연하게 늘리거나 줄여 레이아웃을 잡는 방법이다.   &lt;div id=\"outer\"&gt;   &lt;div class=\"box\"&gt;box1&lt;/div&gt;   &lt;div class=\"box\"&gt;box2&lt;/div&gt;   &lt;div class=\"box\"&gt;box3&lt;/div&gt; &lt;/div&gt;   #outer {   display: flex;   border: 1px dotted red;   padding: 10px; }  .box {   border: 1px solid green;   padding: 10px; }              부모 박스요소에 display: flex를 적용해, 자식 박스의 방향과 크기를 결정한다. 기본값으로, display: flex가 적용된 부모 박스의 자식 요소는 왼쪽부터 차례대로 이어 배치된다.       반드시 알아두기: grow(팽창 지수), shrink(수축 지수), basis(기본 크기)            자식 박스에 어떠한 속성도 주지 않으면, flex: 0 1 auto; 기본값이 적용됩니다.           grow, shrink 속성은 단위가 없고, 비율에 따라 결과가 달라진다. 부모 박스 안에 n개의 자식 박스가 있다고 가정하고 각 자식 박스가 갖는 grow값의 총 합이 n이라면,  grow 속성의 값을 1로 설정하는 것은 1/n 가로 또는 세로길이를 적용한다는 의미이다.    &lt;div id=\"outer\"&gt;   &lt;div class=\"box target\"&gt;.box.target&lt;/div&gt;   &lt;div class=\"box\"&gt;.box&lt;/div&gt;   &lt;div class=\"box\"&gt;.box&lt;/div&gt; &lt;/div&gt;   .target {   flex: 1 1 auto; }        flex-grow  : 1 이다. box.target은 부모 박스의 가로 길이 중에서 남은 빈 영역만큼 늘어나게 된다. 위 설명대로라면 전체 자식요소가 가진 grow 값의 합은 1+0+0 = 1이므로, box.target의 가로 크기는 1/1 = 100% 이다. 그러나 다른 자식 박스 안에 이미 콘텐츠가 존재하므로, 다른 자식 박스안의 콘텐츠가 담긴 길이를 제외한 나머지 가로 길이가 box.target의 가로 길이가 된다.   .target {   flex: 1 1 auto; }   .box {   flex: 1 1 auto; }     만약 .box의 flex-grow : 1로 설정하면, 모든 박스가 늘어나려고(grow) 합니다. 결과적으로 모든 박스가 동일한 비율로 가로 길이가 늘어납니다. (총 grow 값 1+1+1, 각 박스는 1/3씩 크기를 가짐)              shrink는 grow와 반대로, 설정한 비율만큼 박스 크기가 작아진다. 그러나 flex-grow 속성과 flex-shrink 속성을 함께 사용시 flex-shrink 속성은 width나 이후 설명할 flex-basis 속성에 따른 비율이므로 실제 크기를 예측하기가 어렵게 된다. flex-grow 속성으로 비율을 변경하는 경우, flex-shrink 속성은 기본값인 1로 두어도 무방하다.            basis는 자식박스가 flex-grow나 flex-shrink에 의해 늘어나거나 줄어들기 전에 가지는 기본 크기이다.       2-3. CSS layout (flexbox 콘텐츠 정렬 방법)     Flexbox를 원하는대로 제어하기 위해서는 axis(축)의 개념에 대한 이해가 필요하다.  axis는 main axis 와 cross axis로 구분된다.            main axis는 flex-direction 속성에 의해서 결정된다. flex-direction의 기본 값인 row 인 상태일 때 main axis 는 가로축(가로축이 default)이 된다.       cross axis는 여러 개의 main axis와 수직을 이루는 방향입니다. main axis가 가로일 때 cross axis는 세로가 됩니다.                  그렇다면 위의 layout을 flexbox 방식으로 CSS를 구성해보자   * {     margin: 0;     padding: 0;     font-size: large;     box-sizing: border-box; }  #container {     display: flex;     margin: 0.4rem;     padding: 0.4rem;     min-height: 100vh; }  .col {     display:flex;     flex-direction: column;     margin: 0.4rem;     padding: 0.4rem;     border: 1px solid red; }  .icon {     margin: 0.4rem;     padding: 0.4rem;     border: 1px dashed orange; }  .row {     margin: 0.4rem;     padding: 0.4rem;     border: 1px dashed purple; }  .w10 {     flex: 1 0 0; }  .w20 {     flex: 2 0 0; }  .w70 {     flex: 7 0 0; }  .h20 {     flex: 2 0 0; }  .h40 {     flex: 4 0 0 ; }  .h80 {     flex: 8 0 0; }   3. HTML/CSS 목업 와이어프레임 실습     실습결과 코드는 GitHub 참조.         오늘 느낀 점          ` CSS 진짜로 개어렵다.` 우선 오늘  실습을 해보며 HTML을 이용하여 프레임을짜고, 그 각각의 프레임을 선택자로 구분하여 CSS를 입혀보았다. 우선 답이 없는 영역이다.  HTML로 해당 구성의 프레임을 짜는거까지는 어렵지않았지만 각 선택자에 들어가는 CSS 요소들을 우선 너무 모른다.. 몰라도 너무 몰라서 검색조차 못하는 단계랄까..?? 나아지겠지.. 우선 틀을 짜고 선택자로 해당 요소를 컨택한다는 점에서 만족하고 나중에 다시 CSS는 꾸준히..손에 익혀봐야겠다. (나중엔 라이브러리 쓰겠지…)            git repository와 내 local directory 를 오늘 동기화(?) 시켜보았다. 수업을 들으며 진행하는 예제가 늘어나면서 잡다한(?) repository 및.. 불필요한 fork 된 repository 가 너무 늘었다.  git repository를 뜯어고쳐서 내 작업공간과 유사하게 셋팅을 해놓았다.              내 작업환경과 유사한 git repository 유지가 필요할 듯 하다. 앞으로 점차 늘어갈 프로젝트 및 실습 데이터들을 관리 유지하는것도 자기관리라 생각해야겠다.             내일 할 일     오늘은 생각보다 HTML/CSS 실습에 쫓기고, gitHub 환경셋팅에 쫓겨서 개별학습은 못하였다. 핑계는..   내일 커리큘럼에는 스코프/클로저 개념학습뿐이다. 어려운 개념이라 생각되지만, 오전~오후 시간 중에는 집중해서 빠르게 습득하고, 저녁에는 부족할거라 예상되는 React/DOM 및 blog 이전글 이사도 모두 마쳐볼 예정이다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.03-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.04 / 1. 원시 자료형&참조 자료형, 2. 스코프, 3. 클로저",
        "excerpt":"    Today I Learnd  1. 원시 자료형과 참조 자료형.    1-1. 원시 자료형.     자바스크립트에서 원시 타입의 데이터(primitive data types; 원시 자료형)는 객체가 아니면서 method를 가지지 않는 6 가지의 타입            string, number,bigint, boolean, undefined, symbol, (null)                 null은 원시 타입과 거의 같게 사용된다고 볼 수 있다. 작동 방식 또한 다른 원시 타입과 같으나, 다만 엄밀하게 따지자면 원시 타입이라고 볼 수 없는 자료형이다.                        원시 자료형은 모두 “하나”의 정보, 즉, 데이터를 담고 있다.  원시 자료형은 값 자체에 대한 변경이 불가능(immutable)하지만, 변수에 다른 데이터를 할당할 수는 있다.       \"hello world!\" \"Hi!\" // \"hello world!\" 와 \"Hi!\"는 모두 변경할 수 없는 고정된 값입니다.  let word = \"hello world!\"  word = \"Hi!\"  // 하지만, word라는 변수에 재할당을 하여 변수에 담긴 내용을 변경은 가능합니다.            1-2. 참조 자료형.          자바스크립트에서 원시 자료형이 아닌 모든 것은 참조 자료형이다. 이런 자료형을 자바스크립트에서는 참조 자료형(reference data type; 참조 타입)이라고도 부른다. 대표적인 참조 자료형으로는 배열([])과 객체({}), 함수(function(){})가 있다.       참조 자료형에는 하나의 데이터가 아닌 여러 데이터가 담기게 된다. 그래서 참조 자료형의 데이터 “값” 자체는 지금까지 배웠던 원시 자료형처럼 1:1로 할당되는 것이 아닌 특별한 데이터 보관함(heap)에 저장됩며, 변수에는 데이터 “값이 위치한곳(메모리 상 주소)”을 가리키는 주소가  저장되게 된다.                     heap은 별도로 관리되며 사이즈 또한 참조 자료형 값에 따라 동적으로 변할수 있다. (고정값은 비효율적인 설계)                                                                  데이터 값               주소                                                               저장위치               heap(동적으로 저장됨)               변수에 할당됨(heap을 가르키는 address)                                                        참조 자료형은 변수에는 주소가 담겨져있기떄문에, 각 변수간에 값을 복사할 경우에 주소가 복사되게 되므로 원본값이 바뀌는 경우가 발생할 수 있다.       let a = [10,20];   let b = a;  // b에 a의 값을 복사한게 아닌, a의 주소가 b에 할당됨. \t \t   b[0]=50;   a; // (2) [50,20] 의 값이 나오게된다.            2. 스코프          예제로 우선 스코프에 대해 알아보자.       let greeting = 'Hello'; function greetSomeone() {   let firstName = 'Josh';   return greeting + ' ' + firstName; } console.log(greetSomeone()); // 'Hello Josh' console.log(firstName); // Reference Error                 greeting 변수는 바깥 스코프에 정의되어 있으므로, 함수 안쪽에서 사용할 수 있다. 반면에, firstName 변수는 함수의 안쪽 스코프에 정의되어 있으므로 함수의 바깥쪽에서는 접근이 불가능하다. 따라서 ReferenceError가 출력된다.                이처럼 변수에 접근할 수 있는 범위가 존재한다. 중괄호(블록) 안쪽에 변수가 선언되었는가, 바깥쪽에 변수가 선언되었는가가 중요한 조건이다. 이 범위를 우리는 스코프라고 부른다.        2-1. 스코프 주요 규칙          첫번째 규칙은, “바깥쪽 스코프에서 선언한 변수는 안쪽 스코프에서 사용 가능한 반면에, 안쪽에서 선언한 변수는 바깥쪽 스코프에서는 사용할 수 없다”라는 점이다.  위의 예제를 통하여 확인해보았다.            두번째 규칙은, “스코프는 중첩이 가능하다”는 것이다, 스코프는 마치 중첩된 울타리와 같다.                     특별히 가장 바깥쪽의 스코프는 전역 스코프(Global Scope)라고 부른다. 그 외의 스코프들은 지역(local) 스코프로 부르며, 전역이 아닌 다른 스코프는 전부 지역 스코프(local scope)이다.                세번째 규칙은, “지역 변수는 전역 변수보다 더 높은 우선순위를 가진다” 이다.        2-2. 스코프의 종류          블록 스코프(block scope) : 중괄호를 기준으로 범위가 구분된다.            함수 스코프(function scope) : function 키워드가 등장하는 함수 선언식 및 함수 표현식은 함수 스코프를 만든다.             화살표 함수는 블록 스코프로 취급된다. 함수 스코프 ( X)            2-3. let, const, var 변수 선언에서 주의할 점     var 키워드로 정의한 변수는 블록 스코프를 무시하고, 함수 스코프만 따른다.            그러나, 모든 블록 스코프를 무시하는 건 아니며, 화살표 함수의 블록 스코프는 무시하지 않는다.                var 키워드로 선언된 전역 변수 및 전역 함수는 window 객체에 속하게 된다.             var myName = 'KJH'; \t     console.log(window.myName);  // KJH                           보통 코드를 작성할 때 블록은 들여쓰기가 적용되고, 그 구분이 시각적으로 분명해서 많은 사람들은 블록 스코프를 기준으로 코드를 작성하고, 생각하기 마련이다. 그러나 var는 이 규칙을 무시하므로, 사용이 권장되지 않는다.                          let       const       var                       유효 스코프 범위       블록 스코프 및 함수 스코프       블록 스코프 및 함수 스코프       함수 스코프                 값 재할당       가능       불가능       가능                 재선언       불가능       불가능       가능               전역 변수는 가장 바깥 스코프에 정의한 변수이다. 따라서, 어디서든 접근이 가능하므로 편리하지만, 다른 함수 혹은 로직에 의해 의도되지 않은 변경이 발생할 수 있다. 이를 부수 효과(side effect) 라 부르며 이를 최소화 하는것이 좋은 프로그래밍 설계 방법이다.                     실수를 방지하기 위해 strict mode를 적용하여 사용할 수 있다 . 브라우저가 보다 엄격하게 작동하도록 만들어주도록 도와준다             'use strict';  // js 파일 상단에 선언, 문법적으로 실수할 수 있는 부분들을 에러로 판단해준다. \t     function showAge() {     age = 90;  // 키워드 없이 변수가 선언되었기 때문에 엄격한 판단에 의해 Error가 발생된다.       console.log(age);   }   showAge();                           유효 범위를 나타내는 스코프는 스코프들간의 유효 범위가 연결리스트 형식으로 관리되는데, 이 스코프간의 상하관계를 스코프 체인 이라 일컫는다.   3. 클로저     MDN에서의 클로저 정의에 따르면, 다음과 같다.      “함수와 함수가 선언된 어휘적(lexical) 환경의 조합을 말한다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.”       “함수를 리턴하는 함수중, 내부 함수의 리턴값이 외부 함수의 변수에 영향을 미친다면 이를 클로저 함수라 일컫는다.”   3-1. 클로저 함수의 특징  // const adder = x =&gt; y =&gt; x + y; \t // 위의 코드와 동일하게 작동하는 코드. const adder = function(x) {   let result = 0; \treturn function(y) {  // 익명의 클로저 함수(내부 함수의 리턴값이 외부 함수의 변수에 영향을 미친다) \t  result = x + y; \t  return result; \t} }  adder(5)(7);  // 12 typeof adder(5)  // 'function', 리턴값이 함수의 형태이다.\t              위 사진과 같이 클로저 함수는 “내부 함수는 외부 함수에 선언된 변수에 접근 가능하다” 라는 특징을 갖는다            일반적인 함수는, 함수 실행이 끝나고 나면 함수 내부의 변수를 사용할 수 없다. 이와 다르게, 클로저는 외부 함수의 실행이 끝나더라도, 외부 함수 내 변수가 메모리 상에 저장되기에 데이터를 보존할 수 있다. (어휘적 환경을 메모리에 저장하기 때문에 가능하다)       const adder = function(x) {     let result = 0;   return funtion(y) {         result = x + y;         return result;   } }  const add5 = adder(5);   add5(7);  // 12 add5(10);  // 15 \t   const add7 = adder(7); // 여러개의 add를 만드는 것이 가능하다. 재활용이 가능한 adder 함수   add7(8);  / 15                  클로저 함수 내부의 선언된 변수들은 외부에서 접근할 수 없으므로 정보의 접근이 제한이 된다. 이를 캡슐화라 한다. 해당 캡슐화를 통해서 불필요한 전역 변수 사용을 줄일수 있게되며, 스코프를 이용해서 값을 보다 안전하게 다룰 수 있는 강점이 생긴다.            위와 같이 재활용 또한 가능하게 된다. (add5, add7 등 adder() 함수를 재활용하여 여러개의 add 변수를 만드는것이 가능하다.) 이와 같이 함수 재사용성을 극대화하여, 함수 하나를 완전히 독립적인 부품 형태로 분리하는 것을 모듈화라고 한다.       3-2. 클로저 함수의 활용 예시  // const tagMaker = tag =&gt; content =&gt; `&lt;${tag}&gt;%{content}&lt;/${tag}&gt;`  // 위의 코드와 동일하게 작동되는 코드. const tagMaker = function(tag) { \treturn function(content){  // 내부 함수값의 리턴값이 외부 함수의 tag를 활용하는 익명의 클로저 함수 \t\treturn `&lt;${tag}&gt;%{content}&lt;/${tag}&gt;`; \t} }  const divMaker = tagMaker('div'); divMaker('hello'); // tagMaker('div')('hello') 와 같은 구조이다.  // 'div'는 위 함수 `tag 매개변수`의 전달인자가 되며, `hello'는 위 함수 `content 매개변수`의 전달인자가 된다.  const anchorMaker = tagMaker('a'); // 모듈화 되어 재사용에 용이하다. anchorMaker('world');   // &lt;div&gt;hello&lt;/div&gt; // &lt;a&gt;world&lt;/a&gt;      클로저 함수는 내부 함수의 리턴값이 외부 함수의 지역변수를 참조하여 값을 바꾸거나 활용 하는 함수이다.  이렇게 사용시 전달인자로 전달된 tag값이나 content의 값이 새로운 할당이나 선언없이 전달인자로만 전달되어도 함수의 기능을 모두 활용하며 재사용에 용이한 구조로 코드를 구성할 수 있다.         오늘 느낀 점          스코프까지는 그럭저럭 쉽게 개념에 대해 학습하고 이해가되었으나 클로저 함수는 난관이다.   우선 어떻게 활용되는지 감이 안잡힌다. 모듈화를 함으로써 얻어지는 편리함등은 머릿속으로는 이해가 가는데,  이걸 기존의 코드에 활용하여 클로저 함수를 정의하며 해당 코드를 재활용하는 영역까진 오늘 모두 이뤄긴 당연히 힘들거라 생각된다.  와이어프레임을 짠 뒤, 중복되는 분야를 모듈화를 통하여 최대한 걷어낼 수 있게끔 처음부터 설계가 진행되야 깔끔한 코딩이 이뤄진다 예상된다.            클로저 함수 복습하니 9~10시… 후..  기존 블로그 포스트  이사 완료하니 자정이다^^…. ㅃ2 velog   그나저나 어제 git repository 정리를 마치니, github 초기화면도 뭔가 바꿔보고 싶다는 생각이 든다… 우선 이런 잡다한거는 나중에 주말에 몰아서 한번 진행해보도록 해야겠다.             내일 할 일          내일 커리큘럼은 이번주 학습한 내용을 pair와 함께 다양한 실습 코딩 test를 pass해야한다. 좋은 기회라 생각되므로 오늘중 다시한번 이번주 학습 내용을 다잡아야겠다.            DOM에 대한 유튜브 강의는 적은듯하다.. 생활코딩님 게시글도 8년전 흠… 드림코딩님은 우선 DOM키워드 글은 없는듯 하고.. 개념에 대한 글들을 우선 정독해보는정도로 마무리하고 React 클론 코딩등은 게시글들이 많으니 그쪽을 먼저 학습하도록 해야겠다.      ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.04-TIL/",
        "teaser": null
      },{
        "title": "[Problem] JavaScript 깊은 복사, 얕은 복사 (작성중)",
        "excerpt":"   [걸림돌] JavaScript 깊은 복사, 얕은 복사  1. 구체적인 문제     객체를 함수의 전달인자로 넘겨줄 경우, 레퍼런스가 전달되는 예제 코드 실습중. 이해가 안간 부분을 우선 포스팅두었다.        참조 자료형은 원시자료형과 다르게 변수명에는 주소값이 할당되며, 변수 내부의 값들은 heap 공간에 저장된다 학습하였다.  아래 코드가 문제가 발생된 요인이다.         const obj = {       mastermind: 'Joker',       henchwoman: 'Harley',       relations: ['Anarky', 'Duela Dent', 'Lucy'],       twins: {        'Jared Leto': 'Suicide Squad',        'Joaquin Phoenix': 'Joker',        'Heath Ledger': 'The Dark Knight',        'Jack Nicholson': 'Tim Burton Batman',       },   };                해당 내용으로 정의된 객체에       const copiedObj = Object.assign({}, obj); \t delete obj.twins['Jared Leto'];           copiedObj 변수를 새로 선언하여, Object.assign() 메소드를 이용하여 obj 객체 값을 복사하였다.        그 후 obj 객체의 twins 키 중 'Jared Leto' 값을 삭제하였다.            내가 예상한 각각 변수의 그림은 아래와 같다.         obj = {  // obj 변수는 copiedObj 변수와 다른 주소를 갖고있다.       mastermind: 'Joker',       henchwoman: 'Harley',       relations: ['Anarky', 'Duela Dent', 'Lucy'],       twins: {         // 'Jared Leto' 키 삭제됨.        'Joaquin Phoenix': 'Joker',        'Heath Ledger': 'The Dark Knight',        'Jack Nicholson': 'Tim Burton Batman',       },   };    copiedObj = {       mastermind: 'Joker',       henchwoman: 'Harley',       relations: ['Anarky', 'Duela Dent', 'Lucy'],       twins: {        'Jared Leto': 'Suicide Squad', // 'Jared Leto' 키 존재함.        'Joaquin Phoenix': 'Joker',        'Heath Ledger': 'The Dark Knight',        'Jack Nicholson': 'Tim Burton Batman',       },   };                하지만 예상과는 다른 결과가 나왔다.       'Jared Leto' in copiedObj.twins  // false           2. 해결방안          참고할 사이트들은 많았으며, 겉핧기식 개념은 머릿속으로는 알았다만 개념에 대해 파고 들수록 재귀함수.. Iterable 까지 알아야 완벽한 학습이 되는 구조인걸 알았다. 우선 다음주 정도에 고차함수 일정에서 재귀함수까지 학습 후 다시 한번 깊은복사와 얕은복사에 대해서 짚고 넘어가야겠다.              참고사이트 1  참고사이트 2             3. Solution      21.08.10 ~ 08.15 사이 고차함수 학습 후 해결예정  ","categories": ["Problem"],
        "tags": [],
        "url": "/problem/ploblem/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.05 / 1. Spread&Rest 문법, 2. 구조분해 3. JavaScript 핵심문법(스코프, 클로저..) 문제풀이",
        "excerpt":"    Today I Learnd  1. Spread / Reset 문법   1-1. Spread 문법          주로 배열을 풀어서 인자로 전달하거나, 배열을 풀어서 각각의 요소로 넣을 때에 사용한다.       function sum(x,y,z) {   return x+y+z; }    const numbers = [1, 2, 3];    sum(...numbers); // typeof(sum) = 'number'          1-2. Rest 문법            파라미터(함수의 매개변수)를 배열의 형태로 받아서 사용할 수 있습니다. 파라미터 개수가 가변적일 때 유용합니다.       function sum(...theArgs) {   return theArgs.reduce((previous, current) =&gt; {       return previous + current;     }); }    sum(1,2,3);  // 6 sum(1,2,3,4);  // 10           1-3. 배열에서의 Spread 문법          Spread 문법은 배열에서 강력한 힘을 발휘한다.            배열 합치기         let parts = ['shoulders', 'knees'];   let lyrics = ['head', ...parts, 'and', 'toes'];             let arr1 = [0, 1, 2];   let arr2 = [3, 4, 5];   arr1 = [...arr1, ...arr2]; // spread 문법은 기존 배열을 변경하지 않으므로(immutable), arr1의 값을 바꾸려면 새롭게 할당해야 한다.                배열 복사         let arr = [1, 2, 3];   let arr2 = [...arr]; // arr.slice() 와 유사           1-4. 객체에서 사용하기     let obj1 = { foo: 'bar', x: 42 };   let obj2 = { foo: 'baz', y: 13 };      let clonedObj = { ...obj1 };   let mergedObj = { ...obj1, ...obj2 };  // {foo: \"baz\", x: 42, y: 13}      객체의 key의 이름이 중복될 경우 후속 spread 문법을 따르는듯하다.   1-5. 함수에서 나머지 파라미터 받아오기   function myFun(a,b, ...manyMoreArgs) {   console.log(\"a\", a); \tconsole.log(\"b\", b); \tconsole.log(\"manyMoreArgs\", manyMoreArgs); }  myFun(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\");   2. 구조 분해 (Destructing)     구조 분해 할당은 Spread 문법을 이용하여 값을 해체한 후, 개별 값을 변수에 새로 할당하는 과정을 말한다.   2-1. 분해 후 새 변수에 할당          배열         const [a, b, ...rest] = [10, 20, 30, 40, 50]; \t   a; // 10 | typeof(a)=\"number\"   b; // 20   rest; // (3), [30, 40, 50] | Array.isArray(rest)=true                객체         const {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}; \t   a; // 10   b; // 20   rest; // {c: 30, d: 40}                함수         function whois({displayName: displayName, fullName: {firstName: name}}){     console.log(displayName + \" is \" + name);   } \t   let user = {     id: 32,     displayName: \"KJH\",     fullName: {       firstName: \"JeongHyun\",       lastName: \"KIM\"     }   }; \t   whois(user);  // KJH is JeongHyun           3. JavaScript 문제풀이     풀이 코드는 Github 참조  자바스크립트 핵심문법(클로저,스코프..등등) 문제풀이         오늘 느낀 점          JavaScript 문제풀이중 얕은 복사, 깊은 복사 개념이 머릿속에 들어오지않았다. 우선 해당 개념파악을 하려면 조금더 JS에서 필요한 학습내용이 뒤 따랐다. (Iterable, 재귀함수..등) 이 문제를 가지고 씨름하기보다는 check 해두기 위해 따로 포스팅 카테고리를 만들어두었다. 다음주 중으로 다시한번 필요한 선행 내용 학습후 다시 되짚어보겠다.            Github Repository를 깔끔히 정리하기 위해 CodeStates에서 학습한 내용들은 한 폴더에 묶어 관리하고싶어서 정리를 해두었다. Github 구성이 내 local 영역과 일치하게끔 구성을 한줄 알았다..  그런데 fork 한 repository가 컨트롤이 안되는 문제를 겪었다.       우선 큰 문제점은 fork한 저장소는 원본(원래 Repository 주인)과 연결되어 있다. 라는 전제가 깔려있기 때문인듯 한데, 아직 정확한 내용을 찾지 못하여서 난항중이다.. 폴더를 한폴더에 묶어서 관리하려는건 아직 능숙하지 않기때문에 개별 repository로 다시 fork 하여 구성하였으며, local 영역또한 clone 하여 동일한 환경으로 구성해두었다.  정확히 브런치 부분이 문제인지는 모르겠지만, 브런치 부분을 조금 더 학습 후 다시한번 도전해봐야겠다.            fork 해온 저장소는 나의 작업환경과는 다르기에,  fork -&gt; clone -&gt; npm install 을 거쳐야 동일한 환경에서 결과물을 볼수있다. 이미 학습한 내용인데, 막상 오늘도 fork 하여 clone 하여 local영역에서 작업할 때 package.json 을 활용하지 않는 나의 모습을 보았다. 아직 외부 저장소 파일을 가져와서 작업하는 경우가 적어서 그런듯하니 점차 습관하 하는게 중요할 듯 하다.             내일 할 일     내일의 정규일정은 DOM이다.. 많은 선행학습을 하지 못하여 걱정이다. 우선 한주의 마지막 정규 학습일정이기에, 부족한 부분은 주말통해서 보완할 수 있게끔 노력해야겠다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.05-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.06 / 1. DOM 2. 유효성 검사 실습",
        "excerpt":"    Today I Learnd  1. DOM     DOM( Document Object Model) 은 HTML 요소를 Object(JavaScript Object)처럼 조작(Manipulation)할 수 있는 Model이다. 즉, 자바스크립트를 사용할 수 있으면, DOM으로 HTML을 조작할 수 있다.   1-1. HTML에 JavaScript 적용하기     HTML에 JavaScript를 적용하기 위해서는 &lt;script&gt; 태그를 이용한다. 웹 브라우저가 작성된 코드를 해석하는 과정에서 &lt;script&gt; 요소를 만나면, 웹 브라우저는 HTML 해석을 잠시 추고 &lt;script&gt; 요소를 먼저 실행한다. 즉, &lt;script&gt; 요소는 등장과 함께 실행된다.            &lt;script&gt;요소는 발견즉시 해석되므로 HTML 구문이 모두 해석되기 전 실행될 수도 있다.  정의되지 않은 값이 호출되는 경우 null 이 발생되므로 되도록 HTML 구문이 모두 해석되는 시점인&lt;/body&gt; 앞에 쓰는걸 습관하 하자.           1-2. 부모&amp;자식 엘리먼트 찾기  &lt;html&gt;   &lt;body&gt;     &lt;div id=\"nav\"&gt;       &lt;div class=\"logo\"&gt;&lt;/div&gt;       &lt;div class=\"menu-wrapper\"&gt;         &lt;div class=\"menu\"&gt;&lt;/div&gt;         &lt;div class=\"menu\"&gt;&lt;/div&gt;         &lt;div class=\"menu\"&gt;&lt;/div&gt;         &lt;div class=\"profile-photo\"&gt;&lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;     &lt;div id=\"news-contents\"&gt;       &lt;div class=\"news-content-wrapper\"&gt;         &lt;div class=\"news-picture\"&gt;&lt;/div&gt;         &lt;div class=\"news-title\"&gt;&lt;/div&gt;         &lt;div class=\"news-description\"&gt;&lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;     &lt;div id=\"footer\"&gt;&lt;/div&gt;   &lt;/body&gt; &lt;/html&gt;           위의 HTML 코드를 보고 부모 자식간의 관계를 눈으로 찾는건 그리 어렵지 않은 일이다. 그렇다면 컴퓨터에게 이 사실을 어떻게 전달할까? 자바스크립트에서 DOM은 document 객체에 구현되어 있으므로 브라우저에서 작동되는 자바스크립트 코드에서는, 어디에서나 document 객체를 조회할 수 있다.            DOM 구조를 조회할 때에는 console.dir 이 유용하다.              console.dir 은 console.log 와 달리 DOM을 객체의 모습으로 출력합니다.              객체의 키값쌍 형태로 document.body의 children 키를 확인 가능하다. console.dir(document.body.child)를 이용하여 바로 children 키로 접근 또한 가능하다.            매번 document.body를 통하여 찾아가는 일은 번거로운 일이다. 따로 변수를 선언해서 이 정보를 저장해두는게 편리하다.       let newsContents = document.body.children[1]  // div#news=contents           부모 엘리먼트 또한 변수에 담을수 있다.       let newscontentsParent = newsContents.parentElement;  // body                이렇듯 DOM은 회사의 조직도와 같은 유사한 구조로 구성된다. 이런 자료 구조를 트리구조 라고 하며, 가장 큰 특징은 부모가 자식을 여러개 가질수 있으며, 부모는 하나인 구조가 반복되는 점이다.       2. 유효성 검사 실습.  Github 참조          변수에 querySelector 로 담아온 선택자의 요소를 변경 및 제어하여 동적인 HTML 작성   DOM 구조를 이해하며 javascript로 제어하는 실습. CSS에 시간을 더 할애하였다..         오늘 느낀 점          DOM 을 우선 찍먹정도 하였다. JavaScript &amp; CSS &amp; HTML 이 유기적으로 상호간에 기능/디자인/뼈대 를 담당하여 웹앱(?)을 구성해보았다. 음.. 일단 생각보다 재미있다. 눈으로 보이기때문인가?       아직 부족한 문법(특히 이벤트 핸들러..)은 점차 학습 해나가야겠다.             내일 할 일     주말중 리액트 클론 코딩 완료하기. 이번주 부족했던 클로저, 얕은복사/깊은복사 추가 학습.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.06-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.10 / 1. 고차함수",
        "excerpt":"  Today I Learnd  1. 고차함수  1-1. 일급 객체          자바스크립트에는 특별한 대우를 받는 일급 객체가 있다. 대표적인 일급 객체 중 하나가 함수이다.                       변수에 할당(assignment) 할 수 있다.         다른 함수의 인자(argument)로 전달될 수 있다.         다른 함수의 결과로서 리턴될 수 있다.                       함수를 변수에 할당할 수 있기 때문에, 함수를 배열의 요소나 객체의 속성값으로 저장할 수 있다. 이는 함수를 데이터(string, number, boolean, array, object)를 다루듯이 다룰 수 있다는 걸 의미한다.               변수에 할당(assignment) 할 수 있다.              이미 함수를 변수에 저장하는 방법(함수 표현식)은 학습하였다.         /*   * 자바스크립트에서 함수는 일급 객체이기 때문에 변수에 저장할 수 있다.   * 함수 표현식은 할당 전에 사용할 수 없다.   */ \t   const square = function (num) {     return num * num;   };      // square에는 함수가 저장되어 있으므로 (일급 객체), 함수 호출 연산자 '()'를 사용할 수 있다.   output = square(7);   console.log(output); // --&gt; 49                위의 함수 표현식(function expression)은 함수 선언식(function declaration)과 다르게 호이스팅(Hoisting)이 적용되지 않습니다.            함수 선언식의 호이스팅에 지나치게 의존하면, 코드의 유지 보수가 쉽지 않다. 코드 리뷰나 디버깅을 할 때, 코드를 위아래로 왔다 갔다 하게 될 수 있게되기 때문이다.       반면에 함수 표현식은 함수의 할당과 실행의 위치에 따라 결과가 달라지기 때문에, 코드의 위치를 어느 정도 예측할 수 있기때문에 직관적이다. 호이스팅을 제외하면, 함수 선언식과 함수 표현식은 크게 차이가 없지만, 함수 표현식의 경우는 함수가 변수에 저장될 수 있다는 사실을 보다 분명하게 보여 준다.       1-2. 고차 함수란?          고차 함수(higher order function)는 함수를 인자(argument)로 받을 수 있고, 함수의 형태로 리턴할 수 있는 함수이다       위에서 보았듯이 함수는 변수에 담길 수 있으며 함수는, 함수를 담은 변수를 인자로 또한 전달받을 수 있다. 마찬가지로, 함수 내부에서 변수에 함수를 할당할 수 있으며 이 변수를 리턴함으로써 함수는 함수 자체를 리턴할수 있게 된다.       이때 다른 함수(caller)의 인자(argument)로 전달되는 함수를 콜백 함수(callback function) 라고 한다.              다른 함수를 인자로 받는 경우            function double(num) {     return num * 2;   } \t   function doubleNum(func, num){     return func(num);   } \t   /*   * 함수 doubleNum은 다른 함수를 인자로 받는 고차 함수이다.   * 위 함수 func는 함수 doubleNum의 콜백 함수이다.   * 아래와 같은 경우, 함수 double은 함수 doubleNum의 콜백 함수이다.   */    let output = doubleNum(double, 4);   console.log(output); // 8                  함수를 리턴하는 경우            function adder(added) {     return function (num) {         return num + added;       };   } \t   /*   * 함수 dder는 다른 함수를 리턴하는 고차 함수이다.   * adder는 인자 한 개를 입력받아서 함수(익명 함수)를 리턴한다.   * 리턴되는 익명 함수는 인자 한 개를 받아서 added와 더한 값을 리턴한다.   */    let output = adder(5)(3);   console.log(output); // 8 \t   // adder가 리턴하는 함수를 변수에 저장할 수 있습니다.   const add3 = adder(3);   output = add3(2);   console.log(output); // -&gt; 5                  함수를 인자로 받고, 함수를 리턴하는 경우            function double(num) {     return num * 2;   } \t   function doubleAdder(added, func) {     const doubled = func(added);       return function (num) {         return num + doubled;       };   } \t   /*   * 함수 doubleAdder의 인자 func는 함수 doubleAdder의 콜백 함수이다.   * 함수 double은 함수 doubleAdder의 콜백으로 전달되었다.   */ \t   doubleAdder(5, double)(3); \t   // doubleAdder가 리턴하는 함수를 변수에 저장할 수 있습니다. (일급 객체)   const addTwice3 = doubleAdder(3, double);   addTwice3(2); // 8           1-3. 내장 고차함수     filter : 배열의 filter 메소드는, 모든 배열의 요소 중에서 특정 조건을 만족하는 요소를 걸러내는 메소드이다. 예를 들어 number 타입을 요소로 갖는 배열에서 짝수만을 걸러내거나, 18 보다 작은 수만을 걸러낼 수 있다. string 타입을 요소로 갖는 배열에서, 길이가 10 이하인 문자열만 걸러내거나, ‘korea’만 걸러낼 수도 있다.       여기서 걸러내는 기준이 되는 특정 조건은 filter 메소드의 인자로 전달된다. 이때 전달되는 조건은 함수의 형태 이므로, filter 메소드는, 걸러내기 위한 조건을 명시한 함수를 인자 로 받기 때문에 고차함수이다.      map : 맵은 배열의 각 요소가 특정 논리(함수)에 의해 다른 요소로 지정(map) 되는 내장 함수이다.     let arr = [1,2,3];  let result = arr.map(function(ele) {    return ele * 2; });  result; // [2,4,6]      하나의 데이터를 다른 데이터로 맵핑(mapping) 할 때 사용된다.      reduce : 배열의 각 요소를 특정 방법(함수)에 따라 원하는 형태로 응축하는 메소드이다.    function joinName(resultStr, user){   resultStr = resultStr + user.name + ', ';   return resultStr; }  let users = [   { name : 'Tim', age : 40 },   { name : 'Satya', age : 30 },   { name : 'Sundar', age : 50 } ];  users.reduce(joinName, '');   2. 고차함수 코플릿     함수들을 입력받아 함수들이 입력된 차례대로 결합된 새로운 함수를 리턴해야 한다.    function square(num) {   return num * num; }  function add5(num) {   return num + 5; }  function mul3(num) {   return num * 3; }  output = pipe(square, add5, mul3); console.log(output(4)); // --&gt; 63       수도코드      num을 매개변수로 가지는 함수로 return 해야 한다.   전달 받는 인자(함수)는 ...spread 문법을 통하여 배열 형태로 전달받는다.   각 함수에는 같은 최초 전달된 num값이 필요하다.  (But, 내부 함수에서 num을 그대로 return 한다면 num값이 변질될 수 있다)   그러므로 내부 함수에 let 키워드로 변수를 선언하여, 함수 스코프 내에서 num을 할당 후 값을 보존한다.   for문으로 ...spread 문법을 통하여 전달받은 배열 안의 함수 인자들을 해석하여 return 해준다.   function pipe(...funcs) {  // spread로 인자(함수)들을 배열 형태로 전달받는다.   return function(num){ // 함수를 리턴한다.     let innerNum = num;  // 최초 num 값으로 첫 함수계산을 시작한다.     for(let i=0; i&lt;funcs.length; i++){  // 외부함수의 매개변수(함수 인자) 탐색       innerNum = funcs[i](innerNum) // 내부 함수의 계산 결과 값을 innerNum에 쌓아 나아감     }     return innerNum;          /* i 인덱스마다 innerNum 값 변화       * i = 0 =&gt; innerNum = 16       * i = 1 =&gt; innerNum = 21       * i = 2 =&gt; innerNum = 63     */   } }         오늘 느낀 점     고차함수 ㅎㅎ;;;;  개념은 알겠다. 우선 오늘 풀어본 문제들로 감은 잡았다..  그게 전부이다. 활용할 수 있을까? 란 생각이 든다. 어서 내꺼로 만드는 노력을 해야겠다.   아침에 풀다 막힌 코플릿을 저녁에도 풀어보았는데 또 막힌다(?). 다시 한번 포스팅까지 해서 복기를 하였다. 머리로 수도코드 등 바로바로 그려지는 단계까지 가질 않는다. 광복절 연휴까지 있어서 주말이 길기때문에, 주말까지 반복 학습이 필요할 듯 하다.         내일 할 일     React 실습이다.. 하 클론코딩 등 준비를 못했다. 부딫혀봐야겠다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.10-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.11 / 1. React",
        "excerpt":"  Today I Learnd  1. React     프론트앤드 개발을 위한 JavaScript 오픈소스 라이브러리.   1-1. 리액트의 3가지 특징     선언형 (Declarative)            코드를 면밀히 뜯어보지 않아도, 코드를 유추할 수 있게 된다.                한 페이지를 보여주기 위해 HTML, CSS, JS로 나눠서 적기보다는, 하나의 파일에 명시적으로 작성할 수 있게 JSX 를 활용한 선언형 프로그래밍을 지향한다.                              컴포넌트 기반 (Component-Based)            컴포넌트(Component) 란 독립적인 단위모듈이다.                리액트는 하나의 기능 구현을 위해 여러 종류의 코드를 묶어둔 컴포넌트를 기반으로 개발한다. 컴포넌트로 분리하면 서로 독립적이고 재사용에 용이하기 때문에, 기능 자체에 집중하여 개발이 가능하게 된다.                              범용성            리액트는 JavaScript 프로젝트 어디든 유연하게 적용될 수 있다.       Facebook 에서 관리되어 안정적이고, 가장 유명하며 리액트의 형제격인 리액트 네이티브 로 모바일 플랫폼까지 지원 가능하다.           1-2. JSX          JSX는 JS와는 유사하며 JS를 확장한 문법이지만, 브라우저가 바로 실행할 수 있는 JavaScript 코드는 아니다. “Babel” 을 이용하여 JSX를 브라우저가 이해할 수 있는 JS로 컴파일하게 되며, 컴파일 된 JS를 통하여 브라우저가 읽고 화면에 렌더링 할 수 있다.       React 에서는 DOM 과 다르게 CSS, jsx 문법만 가지고 웹 애플리케이션을 개발할 수 있게된다. 즉, 컴포넌트 하나를 구현하기 위해서 필요한 파일이 줄어들었고, 한눈에 컴포넌트를 확인하기에 더욱 용이하다.              2. React 기본 문법 실습 : Github 참조            오늘 느낀 점     우선 컴포넌트로 구성된 모듈이 모여져서 만들어진 React 의 기본 문법만 학습하였다. 아직 state, props 의 개념까지 확장이 안되어서 웹사이트라 말하긴 아쉽다. 조금 더 다듬어서 이번주 내로는 리액트에 대한 학습내용을 채워갈 예정이다.         내일 할 일     ~08.17 까진 리액트, 돔, 고차함수 집중  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.11TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.12 / 1. React SPA 2. React Router",
        "excerpt":"  Today I Learnd  1. React SPA (Single Page Application)          과거의 브라우저는 웹사이트 페이지 전체를 로딩하였기 때문에 발생하는 리소스 손실이 컸다 . 하지만 SPA는 페이지 전환 전후에 중복되는 부분은 새로 불러오지 않으며 필요한 부분만 갱신하여 웹페이지를 새로 로딩한다.       SPA 란 즉, 서버로부터 완전한 새로운 페이지를 불러오지 않고 페이지 갱신에 필요한 데이터만 받아 그 정보를 기준으로 현재의 페이지를 업데이트함으로써 사용자와 소통하는 웹 어플리케이션이나 웹 사이트를 일컫는다              1-1. SPA 의 장단점  1. 장점     전체 페이지가 아닌 필요한 부분의 데이터만 받아서 화면을 업데이트 하면 되기 때문에 사용자와의 Interaction에 빠르게 반응한다.   서버에서는 요청 받은 데이터만 넘겨주면 되기 때문에 과부화가 적다.   전체 페이지를 렌더링 할 필요가 없기 때문에 더 나은 유저경험을 제공한다.   대표적인 서비스로는 Youtube, facebook, airbnb, Netflix 등이 있다.   2. 단점     SPA 경우 JavaScript 파일의 크기가 크다(HTML 파일은 거의 비어있고 대부분의 코드는 JavaScript 내부에서 작동한다.), 때문에 첫 화면 로딩 시간이 길어질수 밖에 없다.   검색 엔진 최적화(SEO)가 좋지 않다. 구글이나 네이버 같은 검색 엔진들은 HTML 파일에 있는 자료를 분석하는 방식으로 검색 기능이 구동된다. 하지만 SPA 같은 경우 앞서 말했듯이 HTML 파일은 별다른 자료가 없기 때문에 검색 엔진이 적절히 동작하지 못한다.   1-2. React SPA 실습.  참조 : Github    2. React Router          SPA는 하나의 페이지를 가지고 있지만, 한 종류의 화면만 사용하지는 않는다.              위 사진과 같이 하나의 페이지 이지만 화면전환은 계속 이루어진다. 또한 이 화면에 따라 주소 도 달라지게된다.  이렇게 다른 주소에 따라 다른 뷰를 보여주는 과장을 “경로에 따라 변경한다” 라는 의미로 라우팅(Routing)  이라고 한다. React 자체에는 이 기능이 내장되어 있지 않기떄문에 외부 라이브러리를 이용한다.       2. React Router.     React Router의 주요 컴포넌트는 크게 3가지 이다.            router : &lt;BrowserRouter&gt;       route matchers : &lt;Switch&gt;, &lt;Route&gt; 경로를 매칭해준다.       route changers : &lt;Link&gt; 경로를 변경해준다.                  2-1. React Router 실습.  참조 : Github          오늘 느낀 점     라우터를 이용한 부분 페이지 전환 그로인한 SPA 설계 가능화.   내일 리액트의 꽃인 state, props 학습이다.  내일까지 리액트 주요 문법 학습 후 주말중 리액트는 다시 한번 정리해야겠다.         내일 할 일     ~08.17 까진 리액트, 돔, 고차함수 집중  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.12-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.13 / 1. React Props & State",
        "excerpt":"  Today I Learnd  1. React Props &amp; State  1-1. Props vs State     간단하게 언급하고 가자면, props는 외부로 부터 전달받은 값이며, state는 컴포넌트 내부에서 변화하는 값이다.   1-2. Props          컴포넌트의 속성(property)을 뜻한다. props는 변하지 않는 외부로부터 전달받은 값으로, 웹 어플리케이션에서 해당 컴포넌트가 가진 속성에 해당된다.            이 해당 컴포넌트의 속성은 부모 컴포넌트(상위 컴포넌트)로부터 전달받은 값이다.       React 컴포넌트는 JavaScript 함수와 클래스로, props를 함수의 전달인자(arguments)처럼 전달받아 이를 기반으로 화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환한다. 따라서, 컴포넌트가 최초 렌더링될 때에 화면에 출력하고자 하는 데이터를 담은 초기값으로 사용할 수 있다.            props의 자료형은 객체 형태이다. props로 어떤 타입의 값도 넣어 전달할 수 있도록 props는 객체의 형태를 가진다.       또한, props는 외부로부터 전달받아 변하지 않는 값입니다. 그래서 props는 함부로 변경될 수 없는 읽기 전용(read-only) 객체이다. 함부로 변경되지 않아야 하기 때문이다.              읽기 전용 객체가 아니라면 props를 전달받은 하위 컴포넌트 내에서 props 를 직접 수정 시 props를 전달한 상위 컴포넌트의 값에 영향을 미칠 수 있게 된다. 즉, 개발자가 의도하지 않은 side effect 가 생기게 되고 이는 React의 단방향, 하향식 데이터 흐름 원칙(React is all about one-way data flow down the component hierarchy) 에 위배된다.                 props를 사용하는 방법은 아래와 같이 3단계로 구분할 수 있다.              하위 컴포넌트에 전달하고자 하는 값(data)과 속성을 정의한다.       props를 이용하여 정의된 값과 속성을 전달한다.       전달받은 props를 렌더링한다.           function Parent() { {/* 부모 컴퍼넌트 */}   return (     &lt;div className=\"parent\"&gt;       &lt;h1&gt;I'm the parent&lt;/h1&gt;       &lt;Child text={\"I'm the child\"} /&gt;        {/* 1-1. text라는 속성을 선언하고, 이 속성에 문자열 값을 할당하여 Child 하위 컴포넌트에 전달 */}       &lt;Child&gt;I'm the child&lt;/Child&gt;        {/* 1-2. 태그사이에 value 를 넣어 전달할 수도 있다. */}     &lt;/div&gt;   ); }  function Child(props)    {/* 2. 함수에 인자를 전달하듯 props를 자식 컴퍼넌트에게 전달 */}   return (     &lt;div className=\"child\"&gt;       &lt;p&gt;{props.text}&lt;/p&gt;       {/* 3-1. 전달 받은 props를 렌더링. (props는 객체므로 key값 \"text\"를 닷노테이션(dot notation) 방식으로 접근하여 렌더링해준다.) */}       &lt;p&gt;{props.childeren}&lt;/p&gt;       {/* 3-2. 전달 받은 props를 렌더링. (props.children을 이용하면 해당 value에 접근하여 사용할 수 있다.) */}     &lt;/div&gt;   ); }           1-3. State          컴포넌트 내부에서 변할 수 있는 값, 즉 상태는 React State로 다뤄야 한다.            React에서는 state 를 다루는 방법 중 하나로 React에서 제공하는 useState 라는 특별한 함수를 불러와서 사용해야 한다.       import { useState } from \"react\";                체크박스로 컴포넌트 내부에서 상태의 변화를 담아보자.       import React, { useState } from \"react\"; {/* import useState */}  function CheckboxExample() {   const [isChecked, setIsChecked] = useState(false); {/* 새로운 state 변수(isChecked)를 선언 */}   {/* 문법적으로 보면 useState의 리턴값(배열)을 구조 분해 할당한 [isChecked, setIsChecked] 변수 */}    const handleChecked = (event) =&gt; {     setIsChecked(event.target.checked);   };   {/* 핸들러 함수 */}    return (     &lt;div className=\"App\"&gt;       &lt;input type=\"checkbox\" checked={isChecked} onChange={handleChecked} /&gt;         &lt;span&gt;{isChecked ? \"Checked!!\" : \"Unchecked\"}&lt;/span&gt;         {/* isChecked 가 boolean 값을 반환하는 함수기 때문에 삼항연산자를 사용하여 true/false 값을 매칭해준다 */}     &lt;/div&gt;   ); }  export default CheckboxExample;                           위 코드중 useState 함수는 호출시 리턴값은 배열이다. 반환되는 배열의 요소를 살펴보자면, 배열의 0번째 요소는 현재 state 변수이고, 1번째 요소는 이 변수를 갱신할 수 있는 함수이다.             const [state 저장 변수, state 갱신 함수] = useState(상태 초기 값);                                위 코드의 예시대로 React 컴포넌트는 state가 변경되면 새롭게 호출되고, 리렌더링 된다.       이때 React state는 상태 변경 함수(위 예시는 useState함수) 호출로 변경해야 한다. 강제로 변경을 시도하면 , 리렌더링이 되지 않는다거나, state가 제대로 변경되지 않는 side effect 가 발생할 수 있다.       2. React 데이터 흐름          React의 개발 방식의 가장 큰 특징은 페이지 단위가 아닌, 컴포넌트 단위로 시작한다는 점이 가장 큰 특징이다.            데이터의 흐름을 파악할 때에는 부모 컴포넌트에서 props를 이용하여 데이터를 함수의 인자(arguments) 혹은 속성(attributes)처럼 전달 받는 구조로 설계해야한다. 전달하는 주체는 부모이기 때문에 데이터 흐름 방식은 하향식 (top-down)임을 의미한다.       이러한 단방향 데이터 흐름 (One-way data flow) 이라는 키워드가 React를 대표하는 설명 중 하나일 정도이다.            React 에서 데이터를 다룰 때는 컴포넌트들간의 상호 관계와 데이터의 역할, 데이터의 흐름을 고려하여 위치를 설정해야 한다.       3. React Props &amp; States 실습. 참조 : Github         오늘 느낀 점     React props 전달시 부모에서 자식으로 객체로 전달됨.. 조금더 다양한 실습을 해봐야 할듯하다.         내일 할 일          ~08.17 까진 리액트, 돔, 고차함수 집중            HA 이후 포스팅 예정, 부족한 학습에 집중      ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.13-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.23 / 1. 클래스를 이용한 모듈화 2. Prototype",
        "excerpt":"  Today I Learnd  1. 클래스를 이용한 모듈화   1-1. 객체 돌아보기     객체는 자바스크립트의 8가지 자료형중 하나이다, 객체는 원시형(primitive) 자료형과 달리 다양한 데이터를 담을 수 있다. {} 중괄호를 이용하여 객체는 선언되며, 중괄호 안에는 '키(key): 값(value)' 쌍으로 구성된 프로퍼티(property)들이 속해있다.   1-2. 메서드와 this           객체 프로퍼티는 함수를 할당하여 객체에게 행동할 수 있는 능력을 부여해 줄수도 있다.         let user = {     name: \"John\",     age: 30,      sayHi: function() {        console.log(\"안녕하세요!\");     }   }; \t   user.sayHi();  // \"안녕하세요!\"           이처럼 객체 프로퍼티에 할당된 함수를 메서드(method)라고 부른다. 위 예시에선 객체 user에 할당된 메서드는 sayHi이다.              객체를 사용하여 개체를 표한하는 방식을  객체 지향 프로그래밍(object-oriented programming, OOP) 이라 부른다.                 대부분의 메서드는 객체에 저장된 정보에 접근할 수 있어야 제 역할을 하게된다. 메서드 내부에서 this 키워드를 사용하면 메서드를 호출할 때 사용된 객체에 접근할 수 있게된다.         let user = {     name: \"John\",     age: 30,      sayHi: function() {        console.log(console.log(\"안녕하세요! \" + this.age + \"살 \" + this.name + \" 입니다.\");     }   }; \t   user.sayHi();  // \"안녕하세요! 30살 John 입니다.\"           위 처럼 this키워드를 통해 객체의 값에 접근할 수 있으며, 메서드를 보다 유효하게 사용할 수 있게된다.            this의 값은 런타임에 결정된다. 함수를 선언할 때 this를 사용할 수 있지만, 함수가 호출되기 전까지 this (undefined) 엔 값이 할당되지 않는다.              메소드 호출 방식을 이용할 때에는 화살표 함수를 쓰지 않는다.  화살표 함수는 단순히 표현식을 짧게쓸수 있는 함수의 문법적 구조가 아닌 여러 특성을 갖는다.         그중 대표적인 특성중 하나는 “화살표 함수는 일반 함수와 달리 고유한 this를 가지지 않는다.”         그러므로 외부 함수에서 this값을 가져오게 되므로 외부 컨텍스트를 참조하게 되므로 얘기치 않는 상황이 발생될 가능성이 크다.            1-3. 클래스와 인스턴스          위에 잠깐 언급하였던 객체 지향 프로그래밍이란 하나의 모델이 되는 객체를 만들고 그 객체를 이용하여 바탕이 같은 객체를 만드는 프로그래밍 패턴이다.       자동차 생산으로 비유하자면 설계도(클래스)가 있고 해당 설계도로 찍어낸 자동차(인스턴스)들이 있다.            클래스 는 함수로 정의 할 수 있다.       // ES5 문법 function Car(brand, name, color) {   // 인스턴스가 만들어 질 때 실행되는 코드   this.brand = brand;   this.name = name;   this.color = color; }   // ES6 문법 class Car {   // 인스턴스가 만들어 질 때 실행되는 코드   constructor(brand, name, color){     this.brand = brand;     this.name = name;     this.color = color;   } }            여기서 보이는 함수는, 인스턴트를 만들때 실행되는 코드이며 객체지향 프로그래밍에서 생성자(constructor) 라고 부른다.  (참고로 생성자 함수는 return 값을 만들지 않으며 대문자로 시작하며 일반명사로 만들게 된다.)            인스턴스 를 만들 때에는 new 키워드를 사용하게 된다.  즉시 생성자 함수가 실행되며 클래스의 설계를 꼭 닮은 새로운 객체, 즉 인스턴스가 할당된다.         let avante = new Car('huyndai', 'avante', 'black');   let mini = new Car('bmw', 'mini', 'yellow');   let k3 = new Car('kia', 'k3', 'white');                클래스 내부의 속성값들은 위와 같이 정의하며 클래스 내부에 메소드를 정의할 때에는 prototype이라는 키워드를 사용해야 정의할 수 있다.       // ES5 문법 function Car(brand, name, color) { /* 속성정의 생략 */ } Car.prototype.refuel = function() {   // 연료 공급을 구현하는 코드 } Car.prototype.drive = function() {   // 운전을 구현하는 코드 }  // ES6 문법 class Car {   constructor(brand, name, color){ /* 생략 */ }   refuel() {}   drive() {} }            ES5 문법에서는 prototype 키워드를 사용해야 메소드를 정의할 수 있다. ES6에서는 생성자 함수와 함께 class키워드 안쪽에 묶어서 정의한다.       정리하자면,                     실제 코드를 보며 구문을 이해하자.  참조 : 코드스테이츠               2. Prototype  2-1. 객체 지향 프로그래밍          좋은 설계를 위해서는 기본적으로 이 객체 지향을 이해하고 응용하는 것이 매우 중요하다.              캡슐화 (Encapsulation)                    “데이터와 기능을 하나의 단위로 묶는 것”  데이터(속성)과 기능(메소드)를 따로 정의하는 것이 아닌, 하나의 객체 안에 넣어서 묶는 걸 뜻한다.           “은닉(hiding)” 은닉화는 내부 데이터나 내부 구현이 외부로 노출되지 않도록 만드는 것이다.           “느슨한 결합(Loose Coupling)에 유리” 데이터(속성)과 기능(메소드)들이 느슨하게 결합이 되는 것이다. 여기서 느슨한 결합이란 코드 실행 순서에 따라 절차적으로 코드를 작성하는게 아니라, 코드가 상징하는 실제 모습과 닮게 코드를 모아 결합하는것을 의미한다.                       상속 (Inheritance)                    부모 클래스의 특징을 자식 클래스가 물려받는 걸 뜻한다.                       추상화 (Abstraction)                    내부 구현은 아주 복잡하지만, 실제로 노출되는 부분은 단순하게 만든다는 개념이다.  캡슐화와 비교하여 헷갈리는 개념중 하나지만, 단순하게 생각한다면 캡슐화는 코드와 데이터의 “은닉”에 포커스가 맞춰졌다면 추상화는 해당 클래스를 사용하는 사람이 필요하지 않은 메소드 등을 노출시키지않게끔 설계하며 단순한 이름으로 정의하는 것에 포커스가 맞춰져있다.  클래스 정의 시, 메소드와 속성만 정의한 것을 인터페이스라 일컫는다.                       다형성 (Polymorphism)                    같은 메소드라 하더라도 각각마다 다른 방식으로 구현될 수 있다는 개념이다.                           2-2.  클래스와 프로토타입          클래스와 인스턴스 간의 관계는 상속관계가 제일 중요한듯하다,  객체간 상속하기 위해서 JS에서는 프로토타입이라는 방식을 사용한다.                       프로토타입의 객체간 메소드와 속성을 주고받는건  프로토타입 체인(prototype chain)에서 이뤄진다. 이때 상속받는 값들은 프로토타입 체인을 타고 올라가며 접근 할 뿐이지 속성과 메소드가 다른 객체로 이동이나, 복사되는 것이 아님임을 주의해야한다.           프로토타입의 자세한 내용은 아래의 참고문서에서 확인.                          객체 상속에 관련된 이론 및 실습 참조 문서 (MDN Object prototypes)            2-3. 프로토타입 체인          위에서 언급한 내용이지만 다시 말하자면, 객체간 메소드와 속성을 주고받는 “상속”을 JS에서 구현하자면 프로토타입 체인을 사용하여야한다.              JS에서는 extends와 super 키워드를 이용해서 상속을 구현 하고 있다.           프로토타입 체인을 JS에서 구현하기 위한 자세한 내용은 아래의 참고문서에서 확인.              클래스 문법 참조 문서(ECMAScript 2015 클래스)                  오늘 느낀 점          JS에서 객체지향 프로그래밍의 주요 문법등을 학습하였다. 매번 말로만 자바스크립트는…객체 지향프로그래밍이며.. 시도때도 없이 보고 들었는데 처음으로 피부로 와닿으니 굉장히 프로그래머에게 편향된 프로그래밍 방식이란 느낌이 많이 들었다. 이래서 개발언어로써 많이 쓰이는구나라는걸 조금이나마 느꼈다할까나?            아직 잘은 모르겠지만, 기존에 있는 기능을 가져와 확장하는 경우라던지, 실무 개발단계에서 필수적인 개념이라 생각이 든다.             내일 할 일     [자료구조/알고리즘] 기초 - 자료구조  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.23-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.08.26 / 1. 자료구조 2. 자료구조의 종류",
        "excerpt":"  Today I Learnd  1. 자료구조란?     자료구조란 여러 데이터들의 묶음을 저장하고, 사용하는 방법을 정의한 것.  데이터에 편리하게 접근하고 변경하기 위해 데이터를 저장하거나 조직을 효율적으로 해야한다. 그러한 행위로 분류된 데이터를 자료구조라 한다. ( + 알고리즘은 그 저장된 데이터를 처리하는 과정이다.)   2. 자료구조의 종류  2-1. Stack     스택(Stack)은 쌓다, 쌓이다, 포개지다란 뜻을 내포한다. 직역 그대로 데이터(data)를 순차적으로 쌓는 구조이다.   순차적으로 쌓다보니, 가장 먼저 들어간 자료는 가장 나중에 나올 수 있다. 입력과 출력이 하나의 방향으로 이루어지는 제한적 접근에 있다.        이러한 자료구조의 정책을 LIFO(Last In First Out) 혹은 FILO(First In Last Out) 이라 일컫는다              위 사진 처럼 push(), pop()을 쓰는 배열이 대표적인 Stack 자료구조이다.       대표적으로 활용되는 예시는 브라우저의 뒤로 가기, 앞으로 가기 기능 &amp; 엑셀 등 문서작업에서 되돌리기 등의 기능을 구현 할 때 자료구조 Stack의 활용이 필요하다.   2-2. Queue          큐(Queue)는 줄을 서서 기다리다, 대기 행렬 이라는 뜻을 내포한다. Stack과는 반대되는 개념으로, 먼저 들어간 데이터가 먼저 처리되는 FIFO(First In First Out) 혹은 LILO(Last In Last Out) 을 특징으로 가지고 있는다.              위 사진 처럼 자료구조 Queue는 데이터가 입력된 순서대로 처리할 때 주로 사용한다.            대표적으로 활용되는 예시는 프린터가 출력되는 인쇄작업 Queue에 사용된다. 자료구조 Queue를 활용함으로써 프린터는 인쇄작업 Queue에 들어온 문서를 순서대로 인쇄할수있다.       혹은 컴퓨터 장치들 사이에서 데이터를 주고 받을 때, 각 장치 사이에 존재하는 속도의 차이나 시간 차이를 극복하기 위해 임시 기억 장치의 자료구조로 Queue를 사용한다. 이를 버퍼(buffer) 라 일컫는다.       2-3. Graph     그래프는 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조이다. 직접적인 관계가 있는 경우 두 점 사이를 이어주는 선이 있겠으며, 간접적인 관계라면 몇 개의 점과 선에 걸쳐 이어진다.        그래프에서 하나의 점을 정점(vertex)이라고 표현하고, 하나의 선은 간선(edge) 이라고 한다.              정점과 정점사이에 간선이 존재하는데, 이 간선은 정점 사이의 관계를 나타낸다. 정점 사이에 직접적, 간적적으로 간선이 없는 경우를 그래프에선 “관계가 없다” 라고 표현한다.            일상생활에선 매일같이 자료구조 그래프를 사용하고 있다. 포털 사이트의 검색 엔진, SNS,  네비게이션(길찾기) 등 에서 사용되는 자료구조이다.       간단한 예를 들자면,             서울에 사는 A는 부산에 사는 B와 오랜 친구 사이입니다. 이번 주말에 부산에서 열리는 B의 결혼식에 참석하기 위해 A는 차를 몰고 부산으로 가려고 합니다. 대전에 살고 있는 친구 C도 B의 결혼식에 참석을 한다고 하여, A는 서울에서 출발하여 대전에서 C를 태워 부산으로 이동을 하려고 합니다.            위 예시에서는 3개의 정점이 존재한다(A,B,C). 각각 서울,부산,대전을 그래프의 정점으로 삼는다면, 이 3개의 정점은 서로 이어지는 간선(관계)를 가지고 있다.              정점 : 서울(A), 대전(B), 부산(C)         간선 : 서울-대전, 대전-부산, 부산-서울            이를 간단한 JS 객체를 이용하여 비유한다면 아래와 같다.       const isConnected = {   seoul : {     busan : true,     daejeon : true   }   daejeon : {     seoul : true,     busan : true   }   busan : {     seoul : true,     daejeon : true   } }  console.log(isConnected.seoul.busan) // true          현재는 특정 도시가 이어져 있다는 무향그래프라는 노드3개와 간선 3개라는 사실만 알려줄 뿐, 그 외의 정보를 포함하고 있진 않다. 이러한 그래프를 비가중치 그래프라 한다.       그래프를 학습하기에있어, 알아둬야 할 용어들이 있다. 간단하게 살펴보면,            무(방)향그래프(underected graph) : 네비게이션(길찾기)에서 보이는 그래프들은 무향 그래프이다. 서울에서 부산을 갈 수 있듯, 반대로 부산에서 서울로 올 수도 있다. 반대 개념인 단방향 그래프(directed graph) 로 구현 된다면,  한쪽 방향으로만 가능할 것이다. 예를 들면 도로의 일방통행은 단방향 그래프로 길찾기를 구현 할 수 있다.       진입차수(in-degree) / 진출차수(out-degree): 한 정점에 진입(들어오는 간선)하고 진출(나가는 간선)하는 간선이 몇 개인지 나타내는 용어이다.       인접(adjacency): 두 정점간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점이다.       자기 루프(self loop): 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 자기 루프를 가졌다 라고 표현하며, 다른 정점을 거치지 않는다는 것이 특징이다.       사이클(cycle): 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 사이클이 있다고 표현한다.                인접은 위에서 말했듯이 직접 이어져 있는 정점의 관계를 나타낸다. 표현 방식을 수식화 할 땐 아래와 같은 방법으로 표현한다.              인접 행렬 (adjacency matrix) : 그래프에서 정점(vertext)들이 어떻게 연결되었는지 나타내는 행렬이다.                    2차원 배열로 작성하게 되며, 정점들 사이에 간선이 존재하는지 여부를 나타내거나, 가중치가 있는 그래프인 경우에는 정점관의 관계에서 의미 있는 값을 저장한다.                         참조 : http://stoimen.com                인접 리스트 (adjacency list) : 각 정점이 어떤 정점과 인접한지를 리스트의 형태로 표현한다. 각 정점마다 하나의 리스트를 가지고 있으며, 이 리스트는 자신과 인접한 다른 정점을 담는다.                                 인접 행렬은 연결 가능한 모든 경우의 수를 저장하기 때문에 상대적으로 메모리를 많이 차지하므로 메모리의 효율성을 위한 작업이 필요할땐 인접리스트가 효율적이다.                                                      2-4. Tree          자료구조 Tree는 이름 그대로 나무의 형태를 가지고 있다. 엄밀히 말하면 그래프의 여러 구조중 무방향 그래프의 한 구조라 말할수있다.       또한, 데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 뒤에 여러 개의 데이터가 존재할 수 있는 비선형 구조이다. 그리고 루트 노드를 기준으로 아래로만 층층이 뻗어나가기 때문에  계층적으로 표현이 되며 그래프와 달리 사이클은 존재하지 않는다.            트리를 학습하기에있어, 알아둬야 할 용어들이 있다. 간단하게 살펴보면,             노드(Node) : 트리 구조를 이루는 모든 개별 데이터       루트(Root) : 트리 구조의 시작점이 되는 노드       부모 노드(Parent node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드       자식 노드(Child node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드       리프(Leaf) : 트리 구조의 끝지점이고, 자식 노드가 없는 노드                      트리 구조는 루트(Root) 라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결한다. 각 데이터를 정점이 아닌 노드(Node)라고 하며, 두 개의 노드가 상하계층으로 연결되면 부모/자식 관계를 가지게 된다. 위 그림에서 A는 B,C,D의 부모 노드(Parent Node)이면서 루트(Root)이며, E와 F는 B의 자식 노드(Child Node)이다. 자식이 없는 C,D,E,F 노드는 나무의 잎과 같다고 하여 리프 노드(leaf Node)라고 부른다.       자료구조 Tree는 계층으로 구현되기 때문에 깊이와 높이, 레벨 등을 측정할 수 있다.            깊이(depth) : 트리 구조에서는 루트로부터 하위 계층의 특정 노드까지의 깊이(depth)를 표현할 수 있다. 쉽게 생각하면 루트에서 현재노드 사이까지의 간선의 갯수라 생각하면 간단하다. 위 그림에서 루트 A의 depth는 0이고, B,C,D의 깊이는 1이다. 그리고 E와 F의 깊이는 2가 된다.       레벨(level) : 트리 구조에서 같은 깊이를 가지고 있는 노드를 묶어서 레벨(level)로 표현한다다. depth가 0인 루트 A의 level은 1이며, depth가 1인 B,C,D의 level은 2이다. 그리고 E와 F의 레벨은 3이 된다. 또한 같은 레벨에 나란히 있는 노드를 형제 노드(sibling Node) 라 부른다.       높이(height) :  루트부터 가장 경로가 긴 노드까지의 간선의 갯수가 높이가 된다.                마지막으로 트리는 큰 트리 내부에 트리 구조를 갖춘 작은 트리를 내포한다. 이는 서브 트리 라 부르며,  해당 서브 트리는 잘게 쪼개어 하나의 노드를 가지기 전까지는 모두 또 다시 서브 트리를 갖게된다.              즉, 한개 이상의 노드를 가진 트리는 재귀적인 구조를 지닌다.             오늘 느낀 점          자료구조.. 개념은 어렵진 않다. 효율적인 데이터 구조는 효율적인 코드를 완성시키는 첫 걸음이라 생각된다. 지금이야 솔직히 말하면 별로 필요 없는듯 보인다..       지금은 코린이 수준의 코드이기 때문에.. ,장난감 집은 쉽게 짓고 대충 만들어도 완성되지만 고층 아파트는 구조 설계가 필수적이다!            기초학문 느낌이 물씬 난다. 구조적인 개념이 많이 등장되기 때문에, 들으면 생소한 느낌은 없다.  다만, 이를 어떻게 실제 코딩에 접목을 하느냐가 굉장히 난감하다.. 객체로 선입선출되는 자료구조를 어떻게..? 이런 느낌이다.       아직 생소하다보니 겪는 문제라 생각든다. 덩치가 큰 개발이 필요한 경우. 개발진행 전 자료구조를 꼭 생각하고 개발에 진행해야 되겠다는 생각은 든다.       ex ) 탐색기 같은 프로그래밍 설계가 필요하다면 트리구조를 먼저 떠올린다. 등등..             내일 할 일     [JS/Node] 비동기  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.26-TIL/",
        "teaser": null
      },{
        "title": "[TIL] 21.09.01 / 1. 비동기 처리 2. Node.js",
        "excerpt":"  Today I Learnd  1. 비동기 처리 (Asynchronous processing)          자바스크립트의 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 행위를 말한다. 요청에 대한 결과가 동시에 일어나지 않는 특성을 가지고있다.         // #1   console.log('Hello');   // #2   setTimeout(function() {     console.log('Bye');   }, 3000);   // #3   console.log('Hello Again');           비동기 처리에 대한 이해가 없는 상태에서 해당 코드를 본다면, JS는 위에서 부터 아래로 한줄씩 읽히기 때문에  \"Hello\"출력 후 3초 뒤 \"Bye\" \"Hello Again\" 라는 출력이 기대되지만, 실제 결과는 \"Hello\" \"Hello Again\" 출력 후 3초 뒤 \"Bye\"가 출력된다.       setTimeout()이라는 Web API를 이용한다면 코드를 바로 실행하지 않고 지정한 시간만큼 기다렸다가 로직을 실행할 수 있게되는데 비동기 방식으로 실행되기 때문에, 코드 순서대로 실행되는것이 아니라 일단 setTimeout()을 실행 하고 나서 바로 다음 코드인 \"Hello Again\"으로 넘어간 뒤 3초 후 \"Bye\"를 출력하게 된다.   여기서 발생하는 문제는 setTimeout()의 지연시간을 랜덤한 숫자를 준다면 개발자는 위의 코드의 순서를 제어할수 있을까? 비동기 처리는 이처럼 순서 제어가 반드시 필요하다.    1-1. 콜백 함수를 통한 비동기 처리          위의 예시 처럼 비동기 처리는 고유의 처리 방식에 의해 야기될 수 있는 문제들이 존재함을 학습했다. 이러한 문제들을 해결 하는 여러가지 방법들이 명시되어 있는데 가장 기초적인 해결 방식은 콜백(callback) 함수를 이용하는 것이다.         const printString = (string, callback) =&gt; {     setTimeout(         () =&gt; {             console.log(string)               callback()           }, Math.floor(Math.random() * 100) + 1       )   } \t   const printAll = () =&gt; {     printString(\"A\", () =&gt; {         printString(\"B\", () =&gt; {             printString(\"C\", () =&gt; {})           })       })   } \t   printAll(); // \"A\" \"B\" \"C\"           위 코드처럼콜백 함수를 연속하여 사용하여 비동기 처리 로직을 제어 할 수 있다. 특정 로직이 끝났을 때 원하는 동작을 실행하여 순서를 제어 할수 있게 된다.            다만 위 방법이 무수히 많이 연속되는 경우엔 콜백 안에 콜백을 계속 무는 형식으로 코딩이 진행되어야 하는 문제점이 발생한다. 그렇게 된다면 코드 구조는 가독성도 떨어지며 추후 로직을 변경해야 할 필요가 생긴다면 유지보수가 굉장히 어렵다는 단점이 생길 수 있다. 이러한 콜백을 너무 연속해서 사용 하는 코드 구조를 콜백 지옥(Callback Hell) 이라고 부르며 비동기 처리가 많은 코드 구조라면 콜백을 통한 비동기 처리 순서 제어는 알맞지 않다.        1-2. Promise 객체를  이용한 비동기 처리          우선 Promise란 비동기 처리에 사용되는 객체이다.  참조 : MDN        이 Promise 객체는 3가지 상태를 가지고 있다.             Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태       Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태       Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태                대기(Pending) 상태는 new Promise() 메서드를 호출 하면 대기상태가 되며, 콜백 함수를 선언할 수 있다.         new Promise();  // Pending            new Promise() 메서드를 호출할 때 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 resolve, reject이다.        new Promise(function(resolve, reject){       // 콜백 함수의 인자는 resolve, reject 이다.   });           이행(Fulfilled) 상태는 콜백함수의 인자인 resolve를 실행하게 되면 이행상태가 된다.       new Promise(function(resolve, reject) {  // Fulfilled     resolve();   });           그리고 이행 상태가 되면 then()을 이용하여 처리 결과 값을 받을 수 있다. (resolve는 then()과 짝궁)        function getData() {     return new Promise(function(resolve, reject) {         var data = 100;           resolve(data);       });   } \t   // resolve()의 결과 값 data를 resolvedData로 받음   getData().then(function(resolvedData) {     console.log(resolvedData); // 100   });                실패(Rejected) 상태는 콜백 함수 인자로 reject를 호출 하면 실패상태가 된다.         new Promise(function(resolve, reject) {  // Rejected     reject();   });           그리고, 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 catch()로 받을 수 있다.        function getData() {     return new Promise(function(resolve, reject) {         reject(new Error(\"Request is failed\"));       });   } \t   // reject()의 결과 값 Error를 err에 받음   getData().then().catch(function(err) {     console.log(err); // Error: Request is failed   });                위 “1-1. 콜백 함수를 통한 순서 제어” ABC 순차 출력 로직 예제를 Promise로 구현하자면 다음과 같다.         const printString = (string) =&gt; {     return new Promise((resolve, reject) =&gt; {         setTimeout(             () =&gt; {                 console.log(string)                   resolve()               }, Math.floor(Math.random() * 100) + 1           )       })   } \t   const printAll = () =&gt; {     printString(\"A\").then(() =&gt; {         printString(\"B\").then(() =&gt; {             printString(\"C\")           })       })   } \t\t   printAll()  // \"A\" \"B\" \"C\"           콜백 지옥(Callback Hell)과 유사하다는 느낌을 지울수 없다. 위 처럼 여러 개의 Promise를 연결하는 걸 Promise Chaining 이라 일컫는다.       위 예제의 프로미스 체이닝을 보자면, printString함수의 resolve() 메서드가 호출되면 프로미스가 대기 상태에서 이행 상태로 넘어가기 때문에 첫 번째 .then()의 로직으로 넘어간다. 첫 번째 .then()에서는 임의의 시간 뒤 입력받은 문자열을 출력한 뒤, 그다음 .then() 으로 넘겨준다. 두 번째 .then()에서도 마찬가지로 내부 함수 실행 후 그 다음 .then()으로 넘겨준다. 그리고 마지막으로 “C”를 출력 한 뒤 printAll() 호출은 종료된다.              then()을 연결하였는데 왜 Promise를 연결한다라고 표현하나?         then() 메서드를 살펴보면 Promise를 리턴하고 두 개의 콜백 함수를 인수로 받는다. 그러므로 then()으로 연결 되었지만, 실질적인 리턴값을 보면 프로미스 객체들간의 연결고리인 셈이다.         그 외에도 then()의 특징으로 첫번째 인자는 Promise가 이행했을 때, 두번째 인자는 거부했을 때를 위한 콜백 함수이다. 그러므로 reject - catch 구문 대신 then()의 두번째 인자로 대체하여 사용할 수 있으나, 권장되는 사용 방식은 아니다.             1-3. async와 await를 사용한 비동기 처리          비동기 처리를 위한 await 키워드는 ECMAScript2017에 추가되었다. 자바스크립트의 비동기 처리 패턴 중 가장 최근에 나온 문법이기에 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와준다.       우선 기본 문법을 보자면,         async function 함수명() {     await 비동기_처리_메서드_명();   }           먼저 함수의 앞에 async 라는 예약어를 붙이고, 비동기 처리 코드 앞에 await를 붙여준다. 여기서 주의해야 할 점은 비동기 처리 메서드가 반드시 프로미스 객체를 반환해야 await가 의도한 대로 작동한다.            다시 위의 “ABC” 예제를 async와 await로 구현 후 살펴보면.         const printString = (string) =&gt; {     return new Promise((resolve, reject) =&gt; {         setTimeout(             () =&gt; {                 console.log(string)                   resolve()               }, Math.floor(Math.random() * 100) + 1           )       })   } \t   const printAll = async () =&gt; {     await printString(\"A\")     await printString(\"B\")     await printString(\"C\")   } \t\t   printAll()  // \"A\" \"B\" \"C\"           위 처럼 간단히 구현이 가능하다. await를 사용하지 않았다면 데이터를 받아온 시점에 콘솔을 출력할 수 있게 콜백 함수나 .then()등을 사용했었다. 하지만 async await 문법 덕택에 비동기에 대한 사고를 하지 않아도 되는 개발자에게 편리한 코드 구현 환경을 제공해준다.            async &amp; await에서 예외를 처리하는 방법중 문법적으로 또 다른 요소가 등장한다. 바로 try catch이다. 프로미스에서 에러 처리를 위해 .catch()를 사용했던 것처럼 async에서는 catch {} 를 사용하면 돤다. 자세한 내용은 MDN 문서 try…catch를 참조하자.       2. Node.js          Node.js는 “비동기 이벤트 기반 자바스크립트 런타임” 이다.       브라우저에서 사용할 수 있는 비동기 흐름은 타이머 혹은 DOM 이벤트와 관련된 상황으로 다소 한정적이다. 다만, Node.js에는 많은 API가 비동기로 작성되어 있다. 이를 통해 비동기 상황을 연출할 수 있다.            Node.js 에서는 자바스크립트 코드 가장 상단에 require 구문을 이용하여 다른 파일을 불러온다.        const fs = require('fs'); // 파일 시스템 모듈을 불러온다.   const dns = require('dns'); // DNS 모듈을 불러온다 \t   // 이제 fs.readFile 메소드 등을 사용할 수 있다           그 외에도 3rd-party 모듈을 npm install을 통하여 사용할 수 있다.       2-1. Node.js 모듈 실습     Callback, Promise, Async/awiat 비동기 처리 구현 실습 &amp; Node.js 모듈을 이용한 비동기 처리 실습            참조 :  Github                   오늘 느낀 점          비동기 처리 방식의 구현 프로세스 자체는 이해는 갔다. 하지만 실제 코딩은 어떻게해..? 라는 막연함이 많이 들었다. 원리&amp;구조적인 학습이라기 보다는 문법적인 학습내용이 주된 내용이다 보니, 많이 접해봐야 실제로 내께 될 듯 하다.            혼자 학습으로는 부족함을 느꼈다. (자료구조 Hell… Toy Hell…)  팀 과제 도중 대화도 잘 맞고 경험 많은 페어분을 만나 평일 21~22:00 스터디를 참여하게 되었다.       우선 1차 목표는 CodeStates 수업 내용 완벽 이해를 위한 질의응답 시간을 가진 뒤, 알고리즘 코드 풀이가 주가 될듯하다. 솔직히 TOY 알고리즘 생각하기 귀찮아서(!?) 미뤄두는 경향이 컸다. 내 자신에게 반성하며 내일부터 열심히 스터디에 임해야겠다.       알고리즘에 익숙해지면 해외 코테 사이트중  릿코드라는 사이트를 스터디분중 한분이 추천하여, 해당 사이트에서 알고리즘 문제 풀이를 진행 할 예정이다. (죄다 영어네..)             내일 할 일     [HTTP/네트워크]   알고리즘 카테고리 추가, TIL은 매일 작성하기 보다는 학습 한 단락이 마무리지어졌을때 공부한 내용 정리하기 위한 목적 정도로만 유지하고 알고리즘 코드 풀이에 조금더 시간을 할애 해볼 예정이다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.01-TIL/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 8. largestProductOfThree",
        "excerpt":"  TOY 8. largestProductOfThree  문제   정수를 요소로 갖는 배열을 입력받아 3개의 요소를 곱해 나올 수 있는 최대값을 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 임의의 배열   출력      number 타입을 리턴해야 합니다.   주의사항      입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   배열의 요소는 음수와 0을 포함하는 정수입니다.   배열의 길이는 3 이상입니다.   입출력 예시   let output = largestProductOfThree([2, 1, 3, 7]); console.log(output); // --&gt; 42 (= 2 * 3 * 7)  output = largestProductOfThree([-1, 2, -5, 7]); console.log(output); // --&gt; 35 (= -1 * -5 * 7)   TOY 8. Solution  수도코드      길이가 3 이상인 배열을 내림차순으로 정렬하여 arr[0] 인덱스엔 가장 큰값 ~ arr[2]인덱스엔 3번째로 큰 값을 배치한다.   arr[0]이 가장 큰 양수값이고, arr[last-1] arr[last] 값이 가장 작은 음수값 2개라면 가장 큰 곱의 경우의 수가 될 수 있다.   내림차순으로 정렬된 arr[0~2]번 인덱스 요소의 순차적인 곱의 합은 가장 큰 곱의 경우의 수가 될 수 있다.   2번과 3번의 경우의 수로 나온 결과 값을 비교하여 더 큰 경우의 값을 리턴한다   문제풀이   const largestProductOfThree = function (arr) {   arr.sort((a,b)=&gt;(b-a));  // 내림차순 sort()    const case1 = arr[0]*arr[arr.length-2]*arr[arr.length-1];  // 수도코드 2번 경우   const case2 = arr[0]*arr[1]*arr[2]; // 수도코드 3번 경우    return case1&gt;case2 ? case1 : case2;  // 3항 연산자로 결과값 출력 }  Reference Code   const largestProductOfThree = function (arr) {   const sorted = arr.slice().sort((a, b) =&gt; a - b);   const len = arr.length;   const candi1 = sorted[len - 1] * sorted[len - 2] * sorted[len - 3];   const candi2 = sorted[len - 1] * sorted[0] * sorted[1];   return Math.max(candi1, candi2); };  오늘 느낀 점     Reference Code가 확실히 간결하고 코드가 말하고자 하는 바를 명시적으로 표현한듯하다.   slice()로 배열을 복사한건 왜일까..?  물론 하면 좋지만 딱히 중요한 포인트는 아닌듯 하다.   Math.max를 이용하여 최대값을 리턴하는 방법은 신선했다. 조건문이나…삼항조건연산자로만 풀 생각하였었고, 나름 간결한 문장이라 생각했는데 만약 경우의 수가 2개 이상이었다면 내 코드는 더 복잡해졌을꺼다.   내일 할 일     (주말)  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.02.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 21.09.02 / 1. HTTP/네트워크 2. SSR과 CSR",
        "excerpt":"  Today I Learnd  1. HTTP/네트워크  1-1. 클라이언트-서버 아키텍처          클라이언트-서버 아키텍처는 리소스가 존재하는 곳과, 리소스를 사용하는 앱을 분리시킨 네트워크 모델이다. 리소스를 사용하는 앱이 바로 “클라이언트”, 리소스가 제공(serve)하는 곳은 “서버” 라고 부른다. 클라이언트와 서버로만 이루어진 모델을 2-Tier 아키텍처라고 부르기도 한다.              일반적으로 서버는 리소스를 전달해주는 역할만 담당한다. 리소스를 저장하는 공간을 별도로 마련해 두는데, 이 공간을 “데이터베이스” 라고 부르며, 이처럼 기존 2티어 아키텍처에 데이터베이스가 추가된 형태를 3티어 아키텍처라고 일컫는다.        1-2. HTTP 프로토콜이란?          HTTP(Hypertext Transfer Protocol)는 웹을 개발하는 사람이라면 누구나 다 알아야 하는 통신 프로토콜이다. 프로토콜이란 상호 간에 정의한 규칙을 의미하며 특정 기기 간에 데이터를 주고받기 위해 정의되어 있다.       웹에서는 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용하고 있다.            HTTP 프로토콜의 특징은 상태가 없는(stateless) 프로토콜이다. 여기서 “상태가 없다”라는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 말이다. 즉, 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없이 독립적이다.       이러한 특징 덕택에 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점이 생긴다.       1-3. URL와 URI          URL은 Uniform Resource Locator의 줄임말로, 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보를 나타낸다.       URI는 Uniform Resource Identifier의 줄임말로, 일반적으로 URL의 기본 요소인 scheme, hosts, url-path에 더해 query, bookmark를 포함합니다.  브라우저의 검색창을 클릭하면 나타나는 주소가 URI이다. URI는 URL을 포함하는 상위개념이므로 'URL은 URI다.' 는 참이고, 'URI는 URL이다.' 는 거짓이다.       http://www.google.com:80/search?q=JavaScript 를 브라우저의 검색창에 입력하면, 구글에서 JavaScript를 검색한 결과가 나타난다. 이를 자세히 살펴 보면 다음과 같은 특징을 갖는다.              1-4. HTTP Request &amp; HTTP Response          HTTP로 데이터를 주고받기 위해서는 아래와 같이 요청(Request)을 보내고 응답(Response)을 받아야 합니다.              이때 서버는 요청을 받은 클라이언트에게 리소스를 잘 활용할 수 있도록 인터페이스(interface)를 제공해줘야 한다. 이것을 API, 애플리케이션 프로그래밍 인터페이스(Application Programming Interface) 라고 한다.            앞에서 살펴본 URL을 이용하면 서버에 특정 데이터를 요청할 수 있다. 여기서 요청하는 데이터에 특정 동작을 수행하고 싶으면 HTTP 요청 메서드(Http Request Methods)를 이용한다. 일반적으로 HTTP 요청 메서드는 HTTP Verbs라고도 불리우며 아래와 같이 주요 메서드를 갖고 있다.              GET : 존재하는 자원에 대한 요청       POST : 새로운 자원을 생성       PUT(PATCH) : 존재하는 자원에 대한 변경       DELETE : 존재하는 자원에 대한 삭제                다양한 요청 메서드는 해당 문서에서 참조하자. 참조 : MDN       1-5. HTTP 메세지 포맷          앞서서 말한 내용을 요약하면, HTTP는 특정 상태를 유지하지 않으며 웹 브라우저와 웹 서버의 소통을 위해 디자인되었으며 (1-2. HTTP 프로토콜이란?) 클라이언트-서버 모델에서 클라이언트가 HTTP messages 양식에 맞춰 요청을 보내면, 서버도 HTTP messages 양식에 맞춰 응답한다 배웠다. (1-4. HTTP Request &amp; HTTP Response).       HTTP messages는 요청(Requests)과 응답(Responses)에서 다음과 같은 구조를 지닌다.                     start line : start line에는 요청이나 응답의 상태를 나타내며, 항상 첫 번째 줄에 위치한다. 응답에서는 status line이라고 부른다.       HTTP headers : 요청을 지정하거나, 메시지에 포함된 본문을 설명하는 헤더의 집합.       empty line : 요청에 대한 모든 메타 정보가 전송되었음을 알리는 빈 줄       body : 요청과 관련된 데이터나 응답과 관련된 데이터 또는 문서를 포함한다. 요청과 응답의 유형에 따라 선택적으로 사용된다.           이 중 start line과 HTTP headers를 묶어 요청이나 응답의 헤드(head)라고 하고, payload는 body라고 이야기합니다.              페이로드(영어: payload)는 사용에 있어서 전송되는 데이터를 뜻한다. 페이로드는 전송의 근본적인 목적이 되는 데이터의 일부분으로 그 데이터와 함께 전송되는 헤더와 메타데이터와 같은 데이터는 제외한다. 참조 : MDN            1-6. HTTP 요청 (Request)          HTTP 요청은 서버가 특정 동작을 취하게끔 만들기 위해 클라이언트에서 전송하는 메시지라는걸  위에서 학습하였다. 이 메세지의 내용은 다음과 같이 이루어져 있다.       시작줄            수행할 작업(GET, PUT, POST 등)이나 방식(HEAD or OPTIONS)을 설명하는 HTTP method를 나타낸다. 예를 들어 GET method는 리소스를 받아야 하고, POST method는 데이터를 서버로 전송한다.       요청 대상(일반적으로 URL이나 URI) 또는 프로토콜, 포트, 도메인의 절대 경로는 요청 컨텍스트에 작성된다. 이 요청 형식은 HTTP method 마다 다르다.       HTTP 버전마다 메시지의 구조가 다르다. 이를 위해 HTTP 버전을 함께 입력한다.                헤더 : 요청의 Headers는 기본 구조를 따른다. 대소문자 구분 없는 문자열과 콜론(:), 값을 입력합니다. 값은 헤더에 따라 다르다. 여러 종류의 헤더가 있으며 참조를 통해 확인하자. 참조 : MDN        바디 : 요청의 본문은 HTTP messages 구조의 마지막에 위치한다. 하지만, 모든 요청에 body가 필요하지는 않는다. GET, HEAD, DELETE, OPTIONS처럼 서버에 리소스를 요청하는 경우에는 본문이 필요하지 않는다. POST나 PUT과 같은 일부 요청은 존재하는 자원에 대한 변경 및 업데이트가 필요하므로 사용된다.   1-7. HTTP 응답(Responses)          전반적인 내용은 요청과 비슷하지만 다른점만 서술해보았다.       시작줄            현재 프로토콜의 버전(HTTP/1.1)       상태 코드 : 요청의 결과를 코드번호로 나타낸다 (200, 302, 404 ETC…)       상태 텍스트 : 상태 코드에 대한 설명                특히 이 상태 코드를 통하여 에러처리를 할 수 있기 때문에 프론트엔드 클라이언트 개발자에겐 가장 중요한 정보이다.       주요 상태 코드는 200번대부터 500번대까지 다양하게 있지만 주요한 상태 코드만 몇 개 살펴보자면,             2xx : 200번대의 상태 코드는 대부분 요청에 대한 응답 성공을 의미한다.       3xx : 300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우이다.                4xx : 400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우이다. 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생한다. 가장 익숙한 상태 코드는 404 코드이다. 요청한 자원이 서버에 없다는 의미이다.                      웹페이지에서 종종 겪는 404 에러 출력 메세지               5xx : 500번대 상태 코드는 서버 쪽에서 오류가 난 경우이다.           2. SSR과 CSR  2-1. SSR(Server Side Rendering)          웹 페이지를 브라우저에서 렌더링하는 대신에, 서버에서 렌더링하는 경우를 일컫는다.              브라우저가 서버의 URI로 GET 요청을 보내면, 서버는 정해진 웹 페이지 파일을 브라우저로 전송한다. 그리고 서버의 웹 페이지가 브라우저에 도착하면 완전히 렌더링하게 된다.       서버에서 웹 페이지를 브라우저로 보내기 전에, 서버에서 완전히 렌더링했기 때문에 Server Side Rendering 이라고 한다.       웹 페이지의 내용에 데이터베이스의 데이터가 필요한 경우, 서버는 데이터베이스의 데이터를 불러온 다음 웹 페이지를 완전히 렌더링 된 페이지로 변환한 후에 브라우저에 응답으로 보낸다. 웹 페이지를 살펴보던 사용자가, 브라우저의 다른 경로로 이동하면 브라우저가 다른 경로로 이동할 때마다 서버는 이 작업을 다시 수행한다.       2-1. CSR(Client Side Rendering)          SSR이 서버 측에서 페이지를 렌더링한다면, CSR은 클라이언트에서 페이지를 렌더링한다.              브라우저의 요청을 서버로 보내면 서버는 웹 페이지를 렌더링하는 대신, 웹 페이지의 골격이 될 단일 페이지를 클라이언트에 보낸다. 이때 서버는 웹 페이지와 함께 JavaScript 파일을 보내어서 클라이언트가 웹 페이지를 받으면, 웹 페이지와 함께 전달된 JavaScript 파일은 브라우저에서 웹 페이지를 완전히 렌더링 된 페이지로 바꾸게된다.       웹 페이지에 필요한 내용이 데이터베이스에 저장된 데이터인 경우에는 브라우저는 데이터베이스에 저장된 데이터를 가져와서 웹 페이지에 렌더링을 해야 한다. 이를 위해 API가 사용된다. 웹 페이지를 렌더링하는 데에 필요한 데이터를 클라이언트는 서버에 API 요청으로 해결할 수 있다.       마지막으로, 브라우저가 다른 경로로 이동하면 SSR과 다르게 서버가 웹 페이지를 다시 보내지 않는다. 브라우저는 브라우저가 요청한 경로에 따라 페이지를 다시 렌더링하며, 이때 보이는 웹 페이지의 파일은 맨 처음 서버로부터 전달받은 웹 페이지 파일과 동일한 파일이다.       2-2. SSR과 CSR의 차이점          우선 속도적인 측면을 보면, 웹 페이지 로딩의 종류는 두 가지로 나눌 수 있다. 하나는 웹 사이트의 가장 첫 페이지를 로딩하는 것 그리고, 다른 하나는 나머지를 로딩하는 것을 꼽을 수 있다.       첫 페이지 로딩시간은 CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다. 반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다. 따라서 평균적으로 SSR이 더 빠르다.       나머지 로딩 시간은 첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자. CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다. 반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.            검색 엔진은 자동화된 프로그램 ‘크롤러’로 웹 사이트들을 읽는다.       CSR은 웹 페이지와 함께 전달 된 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 자바스크립트가 실행 되어야 올바른 리소스가 바뀌게 된다. 하지만 SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.             오늘 느낀 점          HTTP 란, 서버-클라이언트간의 상호간에 협의 된 규칙으로 자원을 주고받는 일련의 과정들을 학습하였다. 약간… 구조적인 내용의 학습이었다. 문법이나 코드기술등이 아닌 원초적이고 근본적인 내용이랄까??       우선 오늘 학습내용을 최대한 요약하자면, 클라이언트는 특정된 \"요청 메서드\"로 서버에 자원을 요구하고, 서버는 해당 요청을 \"응답 코드\"가 포함된 응답으로 답변을 한다. 이때 상호간에 대화(?)는 프로토콜이라는 상호간에 규정된 규칙으로 이뤄진다. 정도로 말할 수 있다.              해당 사진의 흐름으로 “서버-클라이언트 간에 Request &amp; Responses가 이뤄진다.” 라는 내용은 머릿속에 집어넣었다 생각한다.            SSR 과 CSR이 언제 필요하며, 각각의 장단점은 짚고 넘어갔다. SSR이 다시 각광을 받는 듯한 분위기던데.. 조금 더 공부가 필요할 듯 하다.             내일 할 일  -[React] 데이터 흐름의 이해와 비동기 요청 처리  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/til-210902-1-2-3-http/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 10. binarySearch",
        "excerpt":"  TOY 10. binarySearch  문제   오름차순 정렬된 정수의 배열(arr)과 정수(target)를 입력받아 target의 인덱스를 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 임의의 배열   arr[i] 는 정수   인자 2 : target     number 타입의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      이진탐색 알고리즘(O(logN))을 사용해야 합니다.   단순한 배열 순회(O(N))로는 통과할 수 없는 테스트 케이스가 존재합니다.   target이 없는 경우, -1을 리턴해야 합니다.   입출력 예시   let output = binarySearch([0, 1, 2, 3, 4, 5, 6], 2); console.log(output); // --&gt; 2  output = binarySearch([4, 5, 6, 9], 100); console.log(output); // --&gt; -1   TOY 10. Solution  수도코드   target과 node의 값이 작거나,같거나,클 경우의 경우를 조건분기로 나누어 이진탐색트리와 같은 탐색방법을 알고리즘으로 구현한다.      target이 없는 경우 (includes.., indexOf 등으로 target 값이 배열에 존재하는지 탐색). -1을 리턴해주는 조건분기 설정   최초 탐색할 중간 idx 설정. 해당 idx 기준으로 탐색 시작.   arr[중간] 값과 target을 비교 하여 같은 경우 탐색종료 해당 idx 값 반환   arr[중간] 값과 target을 비교 하여 클 경우 중간 idx 우측 남은값(arr[중간+1] ~ arr[length-1])을 바탕으로 재귀 실행,   작을 경우 중간 idx 좌측 남은값 바탕으로 재귀 실행   이진탐색트리의 시간복잡도에 알맞는 계산방식으로 구현   문제풀이   const binarySearch = function (arr, target) {   // 이진탐색 (binary search)은 탐색범위의 절반을 기준으로    // target과 확인한 후 그 절반값보다 큰 곳 또는 작은 곳을 다음 탐색범위로 잡아가는 탐색방법   if(!arr.includes(target)) { return -1; } // target이 arr배열에 없다면 -1 리턴      const idxCenter = Math.floor(arr.length/2); // 중간 인덱스 설정    if(arr[idxCenter]===target) { return idxCenter; } // arr[중간인덱스] === target과 같다면, rootNode 가 타겟인 경우이다.    const recArr = arr[idxCenter] &gt; target ? // arr[중간인덱스] &gt; target이 크다면 root의 좌측으로 탐색이 진행되야함     arr.slice(0,idxCenter) : // recArr = 중간인덱스 기준, 좌측 slice     arr.slice(idxCenter+1); // recArr = 중간인덱스 기준, 우측 slice      return binarySearch(recArr,target);  // 재귀 호출 };  Reference Code   const binarySearch = function (arr, target) {   let left = 0,     right = arr.length - 1;   while (left &lt;= right) {     let middle = parseInt((right + left) / 2);     if (arr[middle] === target) {       return middle;     }     if (target &lt; arr[middle]) {       right = middle - 1;     } else {       left = middle + 1;     }   }   return -1; };  오늘 느낀 점     일단 틀렸다. 시간복잡도에 대한 내용에서 에러가 잡힌다.        우선 빅-오 표기법 중 O(logN) 의 시간복잡도는 연산과정이 절반씩 줄어들 경우인건 확실히 인지하였다.       자세한 내용은 해당 블로그 내용참조 : https://jwoop.tistory.com/9       재귀를 통하여 전달하는 arr의 길이를 절반씩 줄였기 때문에 O(logN)을 만족한다 생각하였는데 시간복잡도를 만족못한다는 에러가 발생한다.            배열을 통한 메서드로 연산 처리시 발생하는 시간복잡도는 숙지해둬야할 듯 하다. (참조 : https://dev.to/lukocastillo/)       배열을 모든 요소를 순회하며, 처리하는 메소드들 (ex. slice(), includes(), indexOf()..등등) 시간복잡도 O(logN) 을 만족할 수 없는 결과를 야기시킨다.       알고리즘은 간단하였다, 애초에 배열을 절반씩 자르면서 접근하려던 의도도 O(logN)을 충족시키려 시도해보았던 과정인데 메소드 자체가 이미 배열을 모두 순회한뒤 -&gt; 해당 인덱스까지 얕은 복사가 이뤄지는 과정이다. 그러므로 접근 시도는 좋았지만 사용된 도구(메소드)가 잘못되었다.   내일 할 일     TOY 11. powerSet  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.06.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 11. powerSet",
        "excerpt":"  TOY 11. powerSet  문제   하나의 집합을 의미하는 문자열을 입력받아 각 문자를 가지고 만들 수 있는 모든 부분집합을 리턴해야 합니다.   입력   인자 1 : str     string 타입의 공백이 없는 알파벳 소문자 문자열   출력      배열(arr)을 리턴해야 합니다.   arr[i]는 각 부분집합의 원소로 구성된 문자열   주의사항      arr[i]는 각 부분집합을 구성하는 원소를 연결한 문자열입니다.   arr[i]는 알파벳 순서로 정렬되어야 합니다.   집합은 중복된 원소를 허용하지 않습니다.   부분집합은 빈 문자열을 포함합니다.   arr은 사전식 순서(lexical order)로 정렬되어야 합니다.   입출력 예시   let output1 = powerSet('abc'); console.log(output1); // ['', 'a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']  let output2 = powerSet('jjump'); console.log(output2); // ['', 'j', 'jm', 'jmp', 'jmpu', 'jmu', 'jp', 'jpu', 'ju', 'm', 'mp', 'mpu', 'mu', 'p', 'pu', 'u']   TOY 11. Solution  수도코드      입력 받은 배열을 배열로 변환, 정렬   집합은 중복된 원소를 허용하지 않으므로, 정렬된 배열을 중복값을 제거해줌 (flilter…등 메소드 활용 필요)   DFS 깊이 알고리즘을 통해 멱집합 알고리즘 구현. (flag 배열을 생성하여 중복값 여부 check)   문제풀이   const powerSet = function (str) {   // TODO: 여기에 코드를 작성합니다.   const sortArr = str.split('').sort(); // sortArr = str-&gt;arr 변환 후 정렬한다.   const uniqueArr = sortArr.filter((el, index) =&gt; sortArr.indexOf(el) === index)    // 중복값 제거, filter 메소드를 이용하여 sortArr.indexOf(el)값이 index와 같은 조건의 uniqe한 값들로 채운 배열을 선언.   let flag = new Array(uniqueArr.length).fill(false); // 플래그 생성.    const subSets = [];    const subSet = function DFS (depth) { // 부분 집합 구하는 재귀 함수, DFS 알고리즘     if (depth === uniqueArr.length) { // 트리의 끝에 다다른 것 ==&gt; 재귀 종료 조건       const subSet = uniqueArr.filter((value, index) =&gt; flag[index]).join('');        // subset = [ flag[index] === true 이면, uniqueArr[index]을 반환하는 배열이 생성된다]       subSets.push(subSet); // 부분집합들을 담는 배열에 push        return; // 이전 depth로 회귀     }      flag[depth] = true; // 해당 depth의 flag true = 트리의 왼쪽     subSet(depth + 1); // 트리의 왼쪽에 대해 재귀호출      flag[depth] = false; // 해당 depth의 flag false = 트리의 오른쪽     subSet(depth + 1); // 트리의 오른쪽에 대해 재귀 호출   }      subSet(0); // depth 0 부터 시작   return subSets.sort(); };   Reference Code   const powerSet = function (str) {   // 정렬   const sorted = str.split('').sort();    // 중복 제거   const deduplicated = sorted.reduce((acc, item) =&gt; {     if (acc[acc.length - 1] === item) {       return acc;     } else {       return acc.concat(item);     }   });    let subSets = [];   const pickOrNot = (idx, subset) =&gt; {     // base case     if (idx === deduplicated.length) {       // 마지막 문자까지 검토한 경우       subSets.push(subset);       return;     }      // recursive case     // idx번째 문자가 포함되지 않는 경우     pickOrNot(idx + 1, subset);      // idx번째 문자가 포함되는 경우     pickOrNot(idx + 1, subset + deduplicated[idx]);   };    pickOrNot(0, '');    return subSets.sort(); };  오늘 느낀 점          멱집합 알고리즘을 참조 하였다. 참조 : https://jun-choi-4928.medium.com 블로그              참고한 사이트 자료가 너무 보기 좋게 정리되어있어서 이해는 어렵지 않았다. (물론 손으로 당연히 쓰면서…)            return ;이 의미하는 바가 무엇인지 정확히 이해하였다. 재귀를 구현하다보면 재귀의 스택이 쌓이기 마련이다. 이럴때 이전 단계로 회귀(?)하는 느낌을 받았다. DFS 알고리즘 경우 트리의 한 줄기의 깊이를 모두 탐색 후, 다른 줄기로 뻗어야 한다. Leaf 노드로 이르렀을때, 이전 노드로 돌아가기 위해 return ;을 사용해야한다는 개념을 확실히 익힌 알고리즘이었다.            외람되지만, 알고리즘 해결 위해 구글링 중 set이라는 자료구조를 접하였다.             Set는 데이터를 비순차적(unordered)으로 저장할 수 있는 순열 자료구조 (collection)입니다. … Array,List와 마찬가지로 Set는 수정이 가능합니다. 중복을 허용하지 않아서 같은값을 삽입하면 되면, 마지막에 삽입한 값 하나만 저장 됩니다.            중복을 허용하지 않은 자료구조 솔깃하다..       const sortArr = str.split('').sort(); const uniqueArr = sortArr.filter((el, index) =&gt; sortArr.indexOf(el) === index)           위 행위를 뭔가 한코드로 줄일수 있을 듯한 느낌이 온다.       내일 할 일     TOY 12. treeBFS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.07.algorithm2/",
        "teaser": null
      },{
        "title": "[TIL] 21.09.07 / 1. React 데이터 흐름 2. Effect Hook",
        "excerpt":"  Today I Learnd  1. CORS   2. Effect Hook  2-1. useEffect()          useEffect는 컴포넌트가 렌더링 될 때마다 특정 작업을 실행할 수 있도록 하는 Hook 이다.       렌더링은 컴포넌트가 mount되었을 때,  update되었을 때 나타난다. 해당 시점에 특정 작업을 처리 할 수 있는 함수이다.       즉, 클래스형 컴포넌트에서 사용할 수 있었던 생명주기 메소드를 함수형 컴포넌트에서 사용할 수 있게 된다.                   useEffect의 기본형은 useEffect( function, deps )이다.       function은 수행하고자 하는 작업이며, deps는 배열형태를 전달받는다. 해당 배열안에는 검사하고자 하는 특정 값 혹은 빈 배열이 들어간다.       deps의 값에 따라 useEffect() 함수의 실행 횟수가 결정된다. []을 넣는 경우 한번만 실행이되며, 특정 값이 업데이트( 특정 props, state가 바뀔 때) 될 때 실행하고 싶을 때는 deps 위치의 배열 안에 검사하고 싶은 값을 넣어준다.       이러한 특성 때문에 deps에 들어간 배열은 종속 배열, 의존성 배열(dependency Arr) 등으로 부르기도 한다.       또한 deps파라미터를 생략한다면, 컴포넌트가 리렌더링 될 때마다 useEffect() 함수가 호출되므로 주의해야 한다.       3. 실습     참조 : GitHub   3-1. State 끌어올리기 (Lifting State Up) 다이어그램           오늘 느낀 점          useEffect().. 아직 감이 안잡힌다. 컴포넌트가 렌더링 될때마다 특정 함수가 작동되는 경우 사용이 되어야 한다 일단 학습하였다.       실습에서도 AJAX로 가져온 데이터 값을 condition.destination 즉, 도착지를 입력하며 새로 렌더링 하였다.       우선 사용목적은 감은 오지만 실제 코드에 적용하기까진 시간이 필요할 듯하다.             내일 할 일     [Web Server] 기초  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.07.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 12. treeBFS",
        "excerpt":"  TOY 12. treeBFS  문제   임의의 tree를 구성하는 노드 중 하나의 Node 객체를 입력받아, 해당 노드를 시작으로 너비 우선 탐색(BFS, Breadth First Search)을 합니다. 이 때, 탐색되는 순서대로 노드의 값이 저장된 배열을 리턴해야 합니다.   입력   인자 1 : node     'value', 'children' 속성을 갖는 객체 (Node)   'node.value'는 number 타입   'node.children'은 Node를 요소로 갖는 배열   출력      배열을 리턴해야 합니다.   주의사항      생성자 함수(Node)와 메소드(addChild)는 변경하지 않아야 합니다.   입출력 예시   let root = new Node(1); let rootChild1 = root.addChild(new Node(2)); let rootChild2 = root.addChild(new Node(3)); let leaf1 = rootChild1.addChild(new Node(4)); let leaf2 = rootChild1.addChild(new Node(5)); let output = bfs(root); console.log(output); // --&gt; [1, 2, 3, 4, 5]  leaf1.addChild(new Node(6)); rootChild2.addChild(new Node(7)); output = bfs(root); console.log(output); // --&gt; [1, 2, 3, 4, 5, 7, 6]   TOY 12. Solution  수도코드              Queue를 사용, 선입 선출이다.              인큐 : 루트 노드 (초기값 할당)       디큐 값을 결과값 배열에 push       인큐 : 루트 노드의 자식 배열들을 반복문을 수행하며 인큐       디큐 값을 결과값 배열에 push       큐가 비워질때 까지 ….반복           문제풀이   let bfs = function (node) {   // TODO: 여기에 코드를 작성합니다.   let queue = [node]; // 초기 root 노드 할당   let values = [];  // 결과값 배열      while (queue.length !== 0) {  // 큐가 비워질때까지 반복     let head = queue[0]; // head는 values로 비워지기전 queue의 정보를 담고있는 변수이다.     queue.shift(); // = slice(1) 선입선출, shift로 queue[0] 삭제     values.push(head.value); // 결과값 배열에 head의 값 push          head.children.forEach((child) =&gt; queue.push(child)); // queue에 head의 children 배열을 넣어준다   }      return values; };  // 이 아래 코드는 변경하지 않아도 됩니다. 자유롭게 참고하세요. let Node = function (value) {   this.value = value;   this.children = []; };  // 위 Node 객체로 구성되는 트리는 매우 단순한 형태의 트리입니다. // membership check(중복 확인)를 따로 하지 않습니다. Node.prototype.addChild = function (child) {   this.children.push(child);   return child; };   Reference Code   let bfs = function (node) {   // TODO: 여기에 코드를 작성합니다.   let queue = [node];   const values = [];   while (queue.length &gt; 0) {     const head = queue[0];     queue = queue.slice(1);      values.push(head.value);      head.children.forEach((child) =&gt; queue.push(child));   }   return values; };  // 이 아래 코드는 변경하지 않아도 됩니다. 자유롭게 참고하세요. let Node = function (value) {   this.value = value;   this.children = []; };  // 위 Node 객체로 구성되는 트리는 매우 단순한 형태의 트리입니다. // membership check(중복 확인)를 따로 하지 않습니다. Node.prototype.addChild = function (child) {   this.children.push(child);   return child; };  오늘 느낀 점     큐의 자료구조를 이용하리라는 생각은 안해보아서, 레퍼런스 코드를 참조하였다.   BFS 가 어떻게 순회되는지 개념은 확실히 알 수 있었던 알고리즘이다.   내일 할 일     TOY 13. insertionSort  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.08.algorithm2/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 13. insertionSort",
        "excerpt":"  TOY 13. insertionSort  문제   정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 배열   arr[i]는 정수   arr.length는 1,000 이하   출력      number 타입을 요소로 갖는 배열을 리턴해야 합니다.   배열의 요소는 오름차순으로 정렬되어야 합니다.   arr[i] &lt;= arr[j] (i &lt; j)   주의사항      삽입 정렬을 구현해야 합니다.   arr.sort 사용은 금지됩니다.   입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   입출력 예시   let output = insertionSort([3, 1, 21]); console.log(output); // --&gt; [1, 3, 21]   Advanced       insertionSort 함수의 두 번째 인자로 callback 함수를 받아서, 그 함수의 리턴값을 기준으로 요소들을 정렬해 보세요.   TOY 13. Solution  수도코드         반복문을 수행하며 arr[1] 부터 정렬 시작   정렬 할 값 기준으로 좌측은 이중 반복문을 순회 하며 자기 자신의 위치를 찾는다   Advance… 문제 이해가 안간다. 콜백?   문제풀이   const insertionSort = function (arr) {   // TODO: 여기에 코드를 작성합니다.   for(let i = 1 ; i &lt; arr.length ; i++){        let temp = arr[i]; // 비교할 대상       let prev = i - 1;  // 비교할 대상 좌측 마지막 index        while( (prev &gt;= 0) &amp;&amp; (arr[prev] &gt; temp) ) {            // 좌측 index 값이 0보다 클때, 그리고 비교 대상보다 이전 인덱스 배열 값이 클때 반복문 수행          arr[prev+1] = arr[prev]; // 현재 temp 자리에 arr[prev]를 넣는다.          prev--; // 증감식       }        arr[prev + 1] = temp; // prev자리에 temp를 넣는다.    }        return arr; };  Reference Code   const insertionSort = function (arr, transform = (item) =&gt; item) {   let sorted = [arr[0]];   for (let i = 1; i &lt; arr.length; i++) {     if (transform(arr[i]) &gt;= transform(sorted[i - 1])) {       sorted.push(arr[i]);     } else {       for (let j = 0; j &lt; i; j++) {         if (transform(arr[i]) &lt;= transform(sorted[j])) {           const left = sorted.slice(0, j);           const right = sorted.slice(j);           sorted = left.concat(arr[i], right);           break;         }       }     }   }    return sorted; };  오늘 느낀 점          Reference Code 를 보니 배열의 기존 값을 해치지 않았다. sorted 변수를 선언하여, slice로 배열 값을 복사하여 썼다.  나는 원 배열을 수정하는 mutable 한 방식을 썼기에 나중에 코드 이식성등을 고려하면 알맞는 코드는 아니다. 다시 풀어봐야 할 듯 하다.       콜백 함수는 아직도 왜 쓴건진 모르겠다… 아직 콜백 함수의 개념을 내가 잘 모르는건가? 주말중 을 이용하여 다시 풀어봐야할 문제중 하나이다.   그다지 .. 많이 쓰일 정렬 알고리즘은 아닌거 같다. 최악의 경우 시간복잡도는 O(n^2) 이며, 배열의 길이가 길수록 최악의 시간복잡도에 가까워 질 수 밖에 없는 구조이다. 배열의 길이가 짧은 경우, 코드의 길이가 길진 않고 쉽게 구현되는 만큼 짧은 길이의 배열에 적합해 보인다.   내일 할 일     TOY 14. rotatedArraySearch  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.09.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 14. rotatedArraySearch(작성중)",
        "excerpt":"  TOY 14. rotatedArraySearch  문제   부분적으로 오름차순 정렬*된 정수의 배열(rotated)과 정수(target)를 입력받아 target의 인덱스를 리턴해야 합니다.     부분적으로 정렬된 배열: 배열을 왼쪽 혹은 오른쪽으로 0칸 이상 순환 이동할 경우 완전히 정렬되는 배열   예시: [4, 5, 6, 0, 1, 2, 3]은 왼쪽으로 3칸 또는 오른쪽으로 4칸 순환 이동할 경우 완전히 정렬됩니다.   입력   인자 1 : rotated     number 타입을 요소로 갖는 배열   rotated[i]는 정수   인자 2 : target     number 타입의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      rotated에 중복된 요소는 없습니다.   target이 없는 경우, -1을 리턴해야 합니다.   입출력 예시   let output = rotatedArraySearch([4, 5, 6, 0, 1, 2, 3], 2); console.log(output); // --&gt; 5  output = rotatedArraySearch([4, 5, 6, 0, 1, 2, 3], 100); console.log(output); // --&gt; -1   Advanced       단순히 처음부터 끝까지 찾아보는 방법(O(N)) 대신 다른 방법(O(logN))을 탐구해 보세요.   힌트       이진 탐색(binary search)을 약간 변형하여 해결합니다.   TOY 14. Solution  수도코드    문제풀이     Reference Code     오늘 느낀 점        내일 할 일     TOY 15. primePassword  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.10.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 21.09.10 / 1. HTTP 트랜잭션 해부 2. Express를 활용한 API 요청 처리(작성중)",
        "excerpt":"  Today I Learnd  1.         오늘 느낀 점              내일 할 일     [React] 컴포넌트 디자인  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.10.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 15. primePassword",
        "excerpt":"  TOY 15. primePassword  문제   다음의 조건을 만족하면서 현재의 비밀번호(‘curPwd’)를 새 비밀번호(newPwd)로 변경하는 데 필요한 최소 동작의 수를 리턴해야 합니다.      한 번에 한 개의 숫자만 변경가능하다.   4자리의 소수(prime)인 비밀번호로만 변경가능하다.   정리하면, 비밀번호가 계속 소수를 유지하도록 숫자 한 개씩을 바꿔갈 때 현재 비밀번호에서 새 비밀번호로 바꾸는 데 최소 몇 개의 숫자를 변경해야 하는지를 리턴해야 합니다.   입력   인자 1 : curPwd     number 타입의 1,000 이상 9,999 이하의 자연수   인자 2 : newPwd     number 타입의 1,000 이상 9,999 이하의 자연수   출력      number 타입을 리턴해야 합니다.   주의사항      4자리인 소수는 1,000 이상의 소수를 말합니다.(0011, 0997 등은 제외)   입출력 예시   let output = primePassword(1033, 1033); console.log(output); // --&gt; 0  output = primePassword(3733, 8779); console.log(output); // --&gt; 3 (3733 -&gt; 3739 -&gt; 3779 -&gt; 8779)   TOY 15. Solution  수도코드   문제해결까지 생각이 닿질않아 레퍼런스 코드를 참고하였다.   우선 필요한 과정을 열거하자면..      DFS 방식으로 광범위한 경우의 수 탐색 (모든 경우의 수를 탐색한다. 경우의 수는 10^4)   중복 탐색을 방지하기 위한 방문여부 check 배열로 중복 탐색 방지 (10000개의 인덱스 default 설정)   첫 시작은 curPwd로 시작 queue에 [step(숫자 바뀐 횟수) 초기값은 0, curPwd] 를 enqueue한다. &gt; queue=[[0,curPwd]]   queue에 담긴 값을 꺼내어 step = queue[...][0], num = queue[...][1]을 할당해준다.   4자리 수의 수를 각 자리수 각 자리수마다 숫자를 0~9까지 하나씩 바꿔가며(현재 자리수와 같은수 제외) 탐색  한다. (탐색에 용이하게 각 자리수를 배열로 나누고, 다시 모든 자리수를 문자열로 합치는 함수 선언하여 사용 ) 코드 간결화를 위해 사용한다   만약 바뀐 Pwd가 newPwd와 같다면 현재의 step+1 을 리턴해주고 탐색은 종료된다   newPwd와 같지않으면서 1,000보다 크고 9999보다 작으며, 소수인 숫자중 방문된 적이 없는 num은 step+1과 함께 enqueue 한다.  &gt; queue=[…queue, [step+1, num]]   4~8번 과정을 큐가 비워질때까지 반복한다   문제풀이   // 수도코드와 Reference Code 주석 참조  Reference Code   const isPrime = (num) =&gt; { // 소수 check   if (num % 2 === 0) return false;    let sqrt = parseInt(Math.sqrt(num)); // 효율적인 계산을 위해 거듭제곤까지 check   for (let divider = 3; divider &lt;= sqrt; divider += 2) {     if (num % divider === 0) {       return false;     }   }   return true; };  // 4자리 수를 받아서 각 자리수의 수들의 배열로 변환하는 함수 //  let output = splitNum(3359); //  console.log(output); // --&gt; [3, 3, 5, 9] const splitNum = (num) =&gt; {   const digits = num.toString().split('');   return digits.map((d) =&gt; Number(d)); };  // 배열을 받아서, 4자리의 수로 변환하는 함수 // let output = splitNum([3, 3, 5, 9]); // console.log(output); // --&gt; 3359 const joinDigits = (digits) =&gt; Number(digits.join(''));  const primePassword = (curPwd, newPwd) =&gt; {   if (curPwd === newPwd) return 0;    // bfs를 위해 queue를 선언   let front = 0;   let rear = 0;   const queue = [];   const isEmpty = (queue) =&gt; front === rear;   const enQueue = (queue, item) =&gt; {     queue.push(item);     rear++;   };   const deQueue = (queue) =&gt; {     return queue[front++];     // const item = queue[front];     // front++;     // return item;   };    // 각 4자리의 방문 여부를 저장하는 배열   // 한 번 방문한 수(가장 최소의 동작으로 만든 수)는 다시 방문할 필요가 없다.   const isVisited = Array(10000).fill(false);      // bfs를 위한 시작점   // 큐에는 [필요한 동작 수, 비밀번호]가 저장된다.   isVisited[curPwd] = true;  // 현재 비밀번호 방문 check   enQueue(queue, [0, curPwd]);  // 현재 비밀번호 부터 시작    while (isEmpty(queue) === false) { // bfs는 큐가 빌(empty) 때까지 탐색한다.     const [step, num] = deQueue(queue);      // 각 자리수 마다 변경이 가능하므로 4번의 반복이 필요하다.     for (let i = 0; i &lt; 4; i++) {       const digits = splitNum(num);              for (let d = 0; d &lt; 10; d++) { // 0부터 9까지 시도한다.         if (d !== digits[i]) { // 각 자리수마다 원래 있던 수(digits[i])는 피해야 한다.           digits[i] = d; // 현재 자리수의 수를 변경하고,           const next = joinDigits(digits); // 변경한 후 4자리 수를 구한다.                      // 만약 이 수가 새 비밀번호와 같다면 리턴한다.           // next는 deQueue된 num으로부터 1단계 다음에 도달한 수이다.           if (next === newPwd) return step + 1;                      // 1,000보다 큰 소수여야 하고, 방문된 적이 없어야 한다.           if (next &gt; 1000 &amp;&amp; isPrime(next) &amp;&amp; isVisited[next] === false) {             // 방문 여부를 표시하고,             isVisited[next] = true;             // 큐에 넣는다.             enQueue(queue, [step + 1, next]);           }         }       }     }   }    // 큐가 빌 때까지, 즉 모든 경우의 수를 탐색할 때까지 리턴되지 않은 경우   // 현재 비밀번호에서 새 비밀번호를 만들 수 없다.   return -1; };  오늘 느낀 점  전혀 감을 못잡았다.. Reference Code를 보고 해석하는 정도도 겨우 소화해낸듯 싶다.   모든 경우의 수 탐색후 조건에 맞는 후보(1000 이상, 소수)들을 숫자를 바꾼 횟수 step과 조건에 부합하는 숫자 num을 큐 자료구조에 enqueue 하여 관리하며, 최종 newPwd 까지 몇회의 숫자바꿈으로 처리되는지 탐색하는 알고리즘이다.  현재보다 작은 패스워드들도 모두 check 하기 때문에 예외 경우도 모두 부합하는 결과를 얻을 수 있었다.   알고리즘도 어려웠기에 인상깊었지만, 함수를 작은 기능별로 쪼개는 모듈화도 인상깊히 학습하였다.   내일 할 일     TOY 16. quickSort  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.13.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 16. quickSort",
        "excerpt":"  TOY 16. primePassword  문제   정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 배열   arr[i]는 정수   arr.length는 100,000 이하     출력            number 타입을 요소로 갖는 배열을 리턴해야 합니다.   배열의 요소는 오름차순으로 정렬되어야 합니다.   arr[i] &lt;= arr[j] (i &lt; j)   주의사항      퀵 정렬을 구현해야 합니다.   arr.sort 사용은 금지됩니다.   입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   입출력 예시   let output = quickSort([3, 1, 21]); console.log(output); // --&gt; [1, 3, 21]   Advanced      quickSort 함수의 두 번째 인자로 callback 함수를 받아서, 그 함수의 리턴값을 기준으로 요소들을 정렬해 보세요.   TOY 16. Solution  수도코드      퀵정렬의 개념은 구글링을 통해 잡았다. 뭔놈의 정렬 알고리즘이 이리 다양한지…      arr[0] 을 최초 기준점으로 left, right 두 배열에 대소 비교하여 arr 요소 push   arr을 순회하며 완성된 left 와 right 배열 기준으로 다시 재귀 호출   arr 이 더이상 정렬할게 없을때 (길이가 2 미만으로 내려갔다면) 재귀 호출 종료   정렬이 완료된 배열을 ... 스프레드 연산자 혹은 concat으로 풀어서 한 배열로 붙여서 리턴하여 함수 종료   메모리 관리가 효율적인 Advanced 알고리즘은 Reference Code 를 참조하였다.  문제풀이   const quickSort = function (arr) {   // TODO: 여기에 코드를 작성합니다.   if(arr.length &lt; 2) return arr; // 재귀함수의 탈출 조건, 길이가 2보다 작다면 더이상 정렬할게 없다.      let pivot = arr[0]; // pivot   let left = []; // pivot 보다 작은 수가 담길 배열   let right = []; // pivot 보다 큰 수가 담길 배열    for(let i = 1; i &lt; arr.length; i++){ //pivot 제외한 arr 요소 조회     if(arr[i] &lt; pivot){ // pivot과 비교하여 left, right로 분류       left.push(arr[i])     } else if(arr[i] &gt; pivot){       right.push(arr[i])     }   }    // 재귀를 통해서 정렬 -&gt; 한 배열로 붙여서 return   return [...quickSort(left), pivot, ...quickSort(right)] };  Reference Code   // naive solution // const quickSort = function (arr) { //   if (arr.length &lt;= 1) return arr;  //   const pivot = arr[0]; //   const left = []; //   const right = [];  //   for (let i = 1; i &lt; arr.length; i++) { //     if (arr[i] &lt;= pivot) left.push(arr[i]); //     else right.push(arr[i]); //   }  //   const lSorted = quickSort(left); //   const rSorted = quickSort(right); //   return [...lSorted, pivot, ...rSorted]; // };  function quickSort(arr, transform = (item) =&gt; item) {   if (arr.length &lt;= 1) return arr;    const pivot = arr[0];   const left = [];   const right = [];    for (let i = 1; i &lt; arr.length; i++) {     if (transform(arr[i]) &lt; transform(pivot)) left.push(arr[i]);     else right.push(arr[i]);   }    const lSorted = quickSort(left, transform);   const rSorted = quickSort(right, transform);   return [...lSorted, pivot, ...rSorted]; }  오늘 느낀 점  효율적인 메모리를 위한 알고리즘에서는 더이상 진전이 없었다… 레퍼런스 코드가 왜 저렇게 구현되는지 잘 와닿지 않는다.   TOY13번에서 개념을 잡지않고 우선 넘어갔는데 같은 유형의 문제가 다시 나왔다… 우선 무조건 공부하고 짚고넘어가야 할 듯해서 찾아본 결과, 꼬리재귀를 공부해야 해당 부분을 깊게 이해 할 수 있다는 점 정도만 감을 잡았다. 재귀 스택이 쌓이는 과정에서의 오버헤드… 를 해결하는 알고리즘인듯하다.      함수를 재귀적으로 호출하여 문제를 해결하는 방식은 코드를 간결하고 의도를 파악하기 쉽게 작성할 수 있는 장점이 있다. 하지만 재귀함수의 콜스택이 깊어 질수록 메모리 오버헤드가 발생하는 단점도 있다. 이 문제를 해결하기 위한 재귀 호출 방식을 꼬리 재귀라고 부른다. 간단하게 정의하자면 재귀함수의 실행 결과가 연산에 사용되지 않고 바로 반환되게 함으로써 이전 함수의 상태를 유지할 필요가 없도록 재귀 함수를 작성하는 것이다.    시간이 늦어 오늘은 sort() 내장 메서드를 사용하지 않는 기본 알고리즘만 해결하고, 주말 추석 연휴중으로 꼬리재귀 에 대해서 학습해 볼 예정이다.   내일 할 일     TOY 17. balancedBracket  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.14.algorithm/",
        "teaser": null
      },{
        "title": "[Problem] 꼬리재귀 (작성중)",
        "excerpt":"   [걸림돌] 꼬리재귀  1. 구체적인 문제   2. 해결방안   3. Solution  ","categories": ["Problem"],
        "tags": [],
        "url": "/problem/21.09.14.problem/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 17. balancedBrackets",
        "excerpt":"  TOY 17. balancedBrackets  문제   문자열을 입력받아 문자열 내의 모든 괄호의 짝이 맞는지 여부를 리턴해야 합니다.      다음 단계에 맞춰 함수를 작성해 보세요            괄호의 종류를 단 한가지로 한정합니다.       괄호의 종류를 늘려 모든 종류의 괄호에도 작동하도록 합니다.       괄호를 제외한 문자열이 포함된 경우에도 작동하도록 합니다.           입력   인자 1 : str     string 타입의 괄호가 포함된 문자열   출력      boolean 타입을 리턴해야 합니다.   주의사항      괄호의 종류는 (, )만 고려합니다.   괄호는 먼저 열리고((), 열린만큼만 닫혀야()) 합니다.   빈 문자열을 입력받은 경우, true를 리턴해야 합니다.   입출력 예시   let output = balancedBrackets('('); console.log(output); // // -&gt; false  output = balancedBrackets('()'); console.log(output); // --&gt; true   Advanced      모든 종류의 괄호((, ), {, }, [, ])가 포함된 문자열을 입력빋아 모든 괄호의 짝이 맞는지 여부를 리턴해 보세요.   let output = balancedBrackets('[](){}'); console.log(output); // --&gt; true  output = balancedBrackets('[({})]'); console.log(output); // --&gt; true  let output3 = balancedBrackets('[(]{)}'); console.log(output); // --&gt; false   TOY 17. Solution  수도코드      스택 자료구조를 이용하여 괄호를 쌓아가며, 쌍이 맞는 괄호가 나오면 위에서 부터 꺼내는 알고리즘을 구현해보았다.      괄호로 구성된 문자열을 배열로 변환하여 반복문으로 해당 배열을 순회한다.   시작부터 닫는 괄호가 나온다면 무조건 괄호 쌍이 일치하지 않으므로 false를 리턴한다.   (, {, [ 여는 괄호가 나올 경우에는 stack 배열에 값을 넣어준다.   닫는 괄호가 나오는 경우 stack 배열의 최상단의 값과 일치하는 괄호가 있는지 검사 -&gt; 일치한다면 기존 stack배열에 쌓인 쌍이 되는 여는 괄호를 빼준다.   반복문이 종료된 후 stack배열이 비어있다면 괄호 쌍이 일치하므로 true를 리턴한다.     문제풀이            1. bare minimum   const balancedBrackets = function (str) {   // TODO: 여기에 코드를 작성합니다.   const strArr = str.split('');   let stack = [];      for(let el of strArr){     if(el === '('){  // 여는 괄호가 나온다면 stack 배열에 값을 넣는다       stack.push(el);     } else {  // 닫는 괄호가 나온다면,       if(stack.length === 0) return false;  // 닫는 괄호 + stack 의 길이가 0. 즉, 첫 시작부터 닫는 괄호가 나온다면 false 리턴        \t\t\tif(stack[stack.length-1] === '('){  // 닫는 괄호 + stack의 마지막 인덱스가 여는 괄호라면 stack의 값을 뺀다.         stack.pop();       }     }   }    return stack.length &gt; 0 ? false : true;  // stack 배열이 비어있다면, 괄호 쌍이 일치하므로 true 리턴. };   2. advanced   const balancedBrackets = function (str) {   // TODO: 여기에 코드를 작성합니다.   const array = str.split('');   let stack = [];    for (let el of array) {     if (el === '{' || el === '[' || el === '(') {  // 여는 괄호가 나온다면 stack 배열에 값을 넣는다       stack.push(el);     } else {  // 닫는 괄호가 나온다면,       if (stack.length === 0) return false;  // 닫는 괄호 + stack 의 길이가 0. 즉, 첫 시작부터 닫는 괄호가 나온다면 false 리턴        // 닫는 괄호 + stack의 마지막 인덱스가 쌍이 맞는 여는 괄호라면 stack의 값을 뺀다.         if (el === '}' &amp;&amp; stack[stack.length - 1] === '{') {           stack.pop();       } else if (el === ']' &amp;&amp; stack[stack.length - 1] === '[') {         stack.pop();       } else if (el === ')' &amp;&amp; stack[stack.length - 1] === '(') {         stack.pop();       }     }   }    return stack.length &gt; 0 ? false : true; // stack 배열이 비어있다면, 괄호 쌍이 일치하므로 true 리턴. };  Reference Code   // naive solution // const balancedBrackets = function (str) { //   const stack = []; //   const opener = '('; //   const closer = ')';  //   for (let i = 0; i &lt; str.length; i++) { //     if (str[i] === opener) { //       stack.push(str[i]); //     } else if (str[i] === closer) { //       const top = stack.pop(); //       if (top !== opener) { //         return false; //       } //     } //   }  //   return stack.length === 0; // };  const balancedBrackets = function (str) {   const stack = [];   const opener = {     '{': '}',     '[': ']',     '(': ')',   };   const closer = '}])';    for (let i = 0; i &lt; str.length; i++) {     if (str[i] in opener) {       stack.push(str[i]);     } else if (closer.includes(str[i])) {       const top = stack.pop();       const pair = opener[top];       if (pair !== str[i]) {         return false;       }     }   }    return stack.length === 0; };  오늘 느낀 점  오늘 TOY 문제는 어렵지않았다. 다만 Reference Code 처럼 간결하진 않지만…   여는 괄호를 opener 객체로 분류하여 키와 값 쌍으로 결과를 도출해내는 과정이 코드가 멋스러웠다…  참조할만한 코드라 생각되어 다시 풀어볼 예정이다.   오늘 스터디중 동기분이 보여주신 코드가 신기해서 가져와보았다. reduce()를 활용해 누산기를 스택으로 활용하는 알고리즘인데 아직 이해가 안간다.. reduce() 아직 생소해…  해당 내용도 알아두면 좋을듯해서 우선 가져와보았다. TOY 문제 다시 풀때 참고해봐야겠다.   const balancedBrackets = function (str) {   // TODO: 여기에 코드를 작성합니다.   let bList = { \"(\" : \")\", \"{\" : \"}\", \"[\" : \"]\" } // 짝에 맞추어 키와 값으로 객체    let stack = str.split('').reduce(function(ac, cv) { // str을 스플릿해 한글자씩 reduce함수를 돌린다     if (cv === bList[ac[ac.length - 1]]) { // ac를 스택으로 사용       ac.pop();     } else {       ac.push(cv);     }     return ac;   }, []);    return stack.length === 0 // 스택에 남아 있는 요소가 없다면 짝이 맞는! };   내일 할 일     TOY 18. getItemFromTwoSortedArrays  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.15.algorith/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 18. getItemFromTwoSortedArrays (작성중)",
        "excerpt":"  TOY 18. getItemFromTwoSortedArrays  문제   길이가 m, n이고 오름차순으로 정렬되어 있는 자연수 배열들을 입력받아 전체 요소 중 k번째 요소를 리턴해야 합니다.   입력   인자 1 : arr1     자연수를 요소로 갖는 배열   arr1.length는 m     인자 2 : arr2       자연수를 요소로 갖는 배열   arr2.length는 n     인자 3 : k       number 타입의 0 이상의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      두 배열의 길이의 합은 1,000,000 이하입니다.   어떤 배열 arr의 k번째 요소는 arr[k-1]을 의미합니다.   입출력 예시   let arr1 = [1, 4, 8, 10]; let arr2 = [2, 3, 5, 9]; let result = getItemFromTwoSortedArrays(arr1, arr2, 6); console.log(result); // --&gt; 8  arr1 = [1, 1, 2, 10]; arr2 = [3, 3]; result = getItemFromTwoSortedArrays(arr1, arr2, 4); console.log(result); // --&gt; 3   Advanced      단순히 처음부터 끝까지 찾아보는 방법(O(K)) 대신 다른 방법(O(logK))을 탐구해 보세요.   힌트      이진 탐색(binary search)을 응용하여 해결합니다.   TOY 18. Solution  수도코드   만약 시간복잡도를 고려하지 않는 문제라면 난이도 0.1 … 이런 걸 의도하진 않겠지…   우선 Advanced 조건인 시간복잡도가 (O(logK)) 되기 위해서는 1번의 검색 수행마다 경우의 수가 절반으로 줄어야 한다.   문제풀이    1. bare minimum   const getItemFromTwoSortedArrays = function (arr1, arr2, k) {   // TODO: 여기에 코드를 작성합니다.      let newArr = arr1.concat(arr2)   let result = newArr.sort(function(a,b) {     return a-b;   })      return result[k-1]; };  시간복잡도를 전혀 고려하지 않았다…  2. advanced     Reference Code   // naive solution // const getItemFromTwoSortedArrays = function (arr1, arr2, k) { //   let cnt = 0, //     left = 0, //     right = 0; //   let target; //   while (cnt &lt; k) { //     if (arr1[left] &lt; arr2[right]) { //       target = arr1[left]; //       left++; //     } else { //       target = arr2[right]; //       right++; //     } //     cnt++; //   } //   return target; // };  // O(logK) solution const getItemFromTwoSortedArrays = function (arr1, arr2, k) {   let leftIdx = 0,     rightIdx = 0;    while (k &gt; 0) {     // 이진 탐색을 위해 각 배열에서 k를 절반으로 쪼개서 카운트 한다.     let cnt = Math.ceil(k / 2);     let leftStep = cnt,       rightStep = cnt;      // 엣지 케이스     // 카운트가 남았음에도 배열의 끝에 도달하면 k를 나머지 배열쪽으로 넘긴다.     if (leftIdx === arr1.length) {       rightIdx = rightIdx + k;       break;     }      if (rightIdx === arr2.length) {       leftIdx = leftIdx + k;       break;     }      // 엣지 케이스     // 현재 카운트가 남아있는 후보 요소들보다 많을 경우, leftStep(현재 할당량)을 남아있는 요소들의 개수로 바꾼다.     if (cnt &gt; arr1.length - leftIdx) leftStep = arr1.length - leftIdx;     if (cnt &gt; arr2.length - rightIdx) rightStep = arr2.length - rightIdx;      // 두 배열의 현재 검사 요소 위치를 비교해서, 그 값이 작은 배열은 비교한 위치 앞에 있는 요소들을 모두 후보군에서 제외시킨다.     if (arr1[leftIdx + leftStep - 1] &lt; arr2[rightIdx + rightStep - 1]) {       leftIdx = leftIdx + leftStep;       // 처리가 끝나면 k값을 절반으로 떨어뜨린다.       k = k - leftStep;     } else {       rightIdx = rightIdx + rightStep;       k = k - rightStep;     }   }    leftMax = arr1[leftIdx - 1] || -1;   rightMax = arr2[rightIdx - 1] || -1;    return Math.max(leftMax, rightMax); };  오늘 느낀 점   내일 할 일     TOY 19. LPS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.17.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 19. LPS (작성중)",
        "excerpt":"  TOY 19. LPS  문제   문자열을 입력받아 다음의 조건을 만족하는 LPS*를 찾아 그 길이를 리턴해야 합니다.      LPS: 주어진 문자열의 가장 긴 접두어이자 접미어(Longest Prefix which is also Suffix)   non-overlapping: 접두어와 접미어는 서로 겹치는 부분이 없어야 합니다. 다시 말해, prefix와 suffix는 문자열의 동일한 인덱스에 위치한 문자를 요소로 가지면 안 됩니다.   입력   인자 1 : str     string 타입의 임의의 알파벳 소문자 문자열   str.length는 60,000 이하   출력      number 타입을 리턴해야 합니다.   주의사항      prefix(접두어)는 문자열의 첫 인덱스부터 시작하는 모든 부분 문자열을 의미합니다.   suffix(접미어)는 문자열의 마지막 인덱스부터 시작하는 모든 부분 문자열을 의미합니다.   입출력 예시   let output = LPS('abbbcc'); console.log(output); // --&gt; 0  output = LPS('aaaa'); console.log(output); // --&gt; 2 // prefix: str.slice(0, 2) // suffix: str.slice(2) // non-overlapping 조건이 없는 경우 정답은 4 입니다.  output = LPS('aaaaa'); console.log(output); // --&gt; 2 // prefix: str.slice(0, 2) // suffix: str.slice(3) // non-overlapping 조건이 없는 경우 정답은 5 입니다.   Advanced      LPS를 계산하는 효율적인 알고리즘(O(N))이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.   정규식(regular expression)을 활용하면 아래처럼 간단하게 구현할 수 있습니다. 정규식에 대해서 학습하시기 바랍니다. (참고사이트)   const LPS = (str) =&gt; {   const result = str.match(/^(\\w*).*\\1$/);   return result[1].length; };   TOY 19. Solution  수도코드   사실 문제가 이해가 잘 안가서 몇번 다시 쳐다보았다.  손으로 써가며 이해한 바로는         문자열을 절반(짝수 경우 5:5로 쪼갤수있고, 홀수인 경우엔 알아서… 비는 문자열 없이 나눠준다.)으로 나눠준다.   쪼개진 prefix와 sufix 안의 내부 문자를 반복문을 통해 순회한다.   prefix는 0번 인덱스는 고정,prefix[prefix.length] 인덱스를 줄여가며 만들어진 새로운 문자열은 LPS 후보가 된다   sufix는 0번 인덱스부터 늘려가며 sufix[sufix.length]인덱스는 고정한 상태에서 만들어진 새로운 문자열은 LPS 후보가 된다.   반복문을 순회하며 새로 만들어진 두 문자열이 같아지면 반복문을 종료하고 현재 중복된 문자열의 길이를 반환한다.     문제풀이           ```javascript  const LPS = function (str) {   // TODO: 여기에 코드를 작성합니다.   let result = ‘’;       for (let i=0; i&lt;= str.length/2; i++) {     let prefix = str.slice(0, i);     let suffix = str.slice(str.length-i);   if (prefix===suffix) {   result=prefix; }   };   return result.length; };  ### Reference Code --- ```javascript // naive solution // const LPS3 = function (str) { //   if (str.length &lt; 2) return 0;  //   // 문자열을 두 부분으로 나누고 //   // 부분 문자열을 쉽게 구하기 위해 //   // 왼쪽 부분의 마지막 인덱스와 오른쪽 부분의 첫 인덱스를 저장  //   let halfSize = Math.floor(str.length / 2); //   // 문자열의 길이가 홀수일 수 있으므로, 올림한다. //   let rightStart = Math.ceil(str.length / 2);  //   // 가장 긴 LPS 후보부터 차례대로 검사한다 //   for (let offset = 0; offset &lt; halfSize; offset++) { //     let matched = true; //     for (let i = 0; i &lt; halfSize - offset; i++) { //       if (str[i] !== str[rightStart + offset + i]) { //         matched = false; //         break; //       } //     } //     if (matched) return halfSize - offset; //   }  //   // LPS가 없는 경우 //   return 0; // };  // naive solution2 // const LPS = function (str) { //   if (str.length &lt; 2) return 0;  //   // 문자열을 두 부분으로 나누고 //   // 각 부분의 첫 인덱스를 저장 //   let leftIdx = 0; //   // 문자열의 길이가 홀수일 수 있으므로, 올림한다. //   let rightIdx = Math.ceil(str.length / 2);  //   while (rightIdx &lt; str.length) { //     if (str[leftIdx] == str[rightIdx]) { //       // LPS 검사를 시작한 위치부터 지금까지 계속 같은 경우 //       // 다음 문자도 같은지 확인하기 위해 인덱스를 이동한다. //       leftIdx++; //       rightIdx++; //     } else { //       // leftIdx가 0인 경우, 단순히 rightIdx를 1 증가 (suffix의 시작점을 뒤로 한 칸 이동) //       // prefix, suffix가 계속 일치하다가 중간에서 일치하지 않는 경우에도, //       // 현재 suffix의 시작점을 뒤로 한 칸 이동한다. //       rightIdx = rightIdx - leftIdx + 1; //       leftIdx = 0; //     } //   }  //   // LPS가 없는 경우 //   return leftIdx; // };  // dynamic solution: O(N) // non-overlapping 조건을 제거하고 lps를 구한다. // lps는 주어진 문자열에서 아래 조건을 만족하는 가장 긴 접두어(prefix)의 길이를 의미한다. //  - 해당 접두어는 주어진 문자열의 접미어(suffix)이기도 하다. // 이때, 문자열 자기 자신은 그 자체로 prefix이자 suffix인데, 이는 고려 대상에서 제외한다. const LPS = function (str) {   // lps[i]는 0부터 i까지의 부분 문자열, 즉 str.slice(0, i + 1)에서 lps의 길이를 저장한다.   const lps = Array(str.length);   // lps[0]은 길이가 1인 문자열의 lps의 길이이므로 항상 0이다. (자기 자신 포함 금지)   lps[0] = 0;   let leftIdx = 0;   let rightIdx = 1;   // lps[i]를 1부터, 즉 문자열의 길이가 2일때부터 차례대로 구한다.   while (rightIdx &lt; str.length) {     if (str[leftIdx] === str[rightIdx] &amp;&amp; rightIdx &gt;= str.length / 2) {       // 가장 단순한 경우를 생각해보면, 쉽게 이해할 수 있다.       // 1) 길이가 2 경우       // 2) 길이가 3 이상인데 전부 같은 문자인 경우       // 0부터 leftIdx까지 매칭이 되었으므로 매칭된 길이는 leftIdx + 1이다.       leftIdx++;       lps[rightIdx] = leftIdx;       rightIdx++;     } else {       // 중간에 매칭이 되지 않은 경우, leftIdx를 조정한다.       // 현재 lps[0]부터 lps[rightIdx - 1]까지 계산이 완료된 상태이다.       // 처음부터 다시 prefix, suffix 매칭을 하는 것이 원칙이지만       // 앞서 계산한 결과인 lps 배열을 통해 처음으로 되돌아갈 필요는 없다.        // 예. aaabaaaa       // 현재 leftIdx는 2, rigthIdx는 3, lps는 [0, 1, 2]인 상태라고 가정해보자.       // leftIdx가 1일 때까지, 즉 현재 leftIdx 직전(leftIdx - 1)까지는 매칭이 되었다.       if (leftIdx !== 0) {         leftIdx = lps[leftIdx - 1];         // Also, note that we do         // not increment i here       } else {         // rightIdx가 1인 경우, 즉 첫 iteration일 경우         // lps[rightIdx]가 0인 것은 명백하다. (예. ab)         // leftIdx가 0이라는 것은 처음부터 prefix, suffix 매칭을 하는 경우이다.         //         // lps가 존재하지 않는 경우이다.         lps[rightIdx] = 0;         rightIdx++;       }     }   }   const res = lps[lps.length - 1];   return res &gt; str.length / 2 ? Math.floor(str.length / 2) : res; };  오늘 느낀 점   내일 할 일     TOY 19. LPS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.17.algorithm2/",
        "teaser": null
      }]
