var store = [{
        "title": "21.07.19 TIL",
        "excerpt":"    오늘 한 일  1. 학습 툴 셋팅     리눅스 환경 (ubuntu os) 에 개발환경 구축.         오늘 느낀 점           코드스테이츠 1일차 앞으로의 강의 일정 및 학습에 대해서 설명을 들었다. 강의라기보다는 줌을 통해서 소통한 느낌.            자기주도적 학습을 강조하였다. 실제로 온라인을 통하여 수업이 진행되며 커리큘럼이 진행되기때문에.. 혼자 학습시간을 지키려 노력하고 이런 노력들 자체도 모두 자기주도적 학습이라 생각한다. 이러한 학습태도는 앞으로 수료시점까지는 당연하며 개발자로써 평생 몸에 지녀야할 기본소양이라 느껴진다. 평생 공부해야지..             내일 할 일      변수, 타입, 함수, 조건문  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.19-TIL/",
        "teaser": null
      },{
        "title": "21.07.20 TIL",
        "excerpt":"    오늘 한 일  1. 변수     변수를 이용하면 데이터를 편리하게 저장하고 꺼내 쓸 수 있게 한다.   변수의 선언과 값의 할당에 대해서 학습하였다.            선언(declaration)을 통하여 변수를 선언할 수 있다.       할당(assignment)을 통하여 변수에 값을 저장하게 된다. 이때 사용되는 ‘=’은 같다라는 뜻이 아닌 ‘할당 연산자(Assignment operator)’이다.       var, let, const 선언방식의 차이점을 학습하였다.                                                                                   var                 let                 const                                                                         중복선언                 O                 X                 X                                               재할당                 O                 O                 X                                                                  변수명은 다음의 규칙에 따라 명명된다. reference. Camel Case     할당이 없는 변수의 경우 undefined 값을 가진다. (값이 없는게 아닌 해당 undefined값을 가진다)   2. 타입     원시 자료형, 참조 자료형 in JS 를 학습하였다.   typeof 연산자를 통하여 특정 갑의 타입을 확인할 수 있다.   3. 함수          함수는 “작은 기능의 단위”이며 키워드(keyword), 이름(name), 매개변수(parameter), 몸통(body)로 구분된다         function muntiPle(num){ // function(키워드), multiPle(이름), num(매개변수)       console.log(num*1);       console.log(num*2);       console.log(num*3);       console.log(num*4);       console.log(num*5);       console.log(num*6);       console.log(num*7);       console.log(num*8);       console.log(num*9); // body 부분   }                구체적인 입력과 출력을 가지고있으며, 호출 후에는 반드시 return 된다.       4. 조건문          조건문은 어떠한 조건을 판별한다. 그렇기에 비교 연산자(comparison operator)가 필요하다.         3 &gt; 5;\t\t// false   3 &lt; 5;\t\t// true   'hi' === 'hello'\t// false   'hi' !== 'hello'\t// true                 비교 연산자의 결과는 늘 Boolean, 즉 true 혹은 false 이다.       주의 해야 할 비교 연산자 ( == , != ) : 값 만을 비교 (data type은 논외) 하기 때문에 엄격한 비교가 불가능하다. 예외가 많기 떄문에 === 와 비교하면 오류가 많다.                두가지 조건이 한번에 적용되는 경우가 필요 할 땐, 논리 연산자(logical operator)를 사용하여 조건문을 작성한다.         isStudent &amp;&amp; isFemale;\t// 학생이면서 여성일때 통과   isStudent || isFemale;\t// 학생이거나 여성이면 통과   !isStudent &amp;&amp; isFemale;\t// 학생이 아니면서 여성일때 통과                truthy와 falsy가 조건문에서 작동하는 방식을 이해할 수 있다.             기억해야 할 6가지 falsy 값, 해당 값들은 false로 반환되므로 if문이 실행되지 않는다.                    false,  null, undefined, 0, NaN, ''                            5. HTML     하이퍼텍스트를 (링크) 가장 중요한 특징으로 하는 마크업이라는 형식을 가진 컴퓨터 프로그래밍 언어.            Markup이란? 그 파일이 프린터로 출력되거나 화면에서 어떻게 보여야할 것인지를 나타내기 위해 또는 그 문서의 논리적인 구조를 묘사하기 위해서, 텍스트나 워드프로세싱 파일의 특정위치에 삽입되는 일련의 문자들이나 기호들을 말한다. 마크업에 사용되는 표지를 흔히 ‘태그’라고 부른다.           태그 설명은 reference. HTML tag         오늘 느낀 점           코드스테이츠 2일차.. 잠을 엄청 설쳤다… 부담감 때문인가? 스트레스 컨트롤도 중요해보인다…            블로그에 학습내용 포스팅은 계속 진행할 예정.       구글은 신이다.            mdn 키워드 mdn 자체가 읽기가 어려워….. 익숙해지자       키워드를 통한 검색 생활화 하기. 영어로 검색하자       Stack Overflow 애용하기 아직은 봐도 잘 모르겠다…                처음으로 둘 이상의 인원이 모여 ZOOM을 통한 협업으로 코드 풀이를 해보았다. 생각보다 ZOOM 을 통한 협업은 불편하지 않았다, 화면쉐어링 등 기본 제공하는 툴들만으로도 의견 전달에는 문제가 없었다. pair 훈련 자체가 오늘 첫 시행이라 난이도가 낮았기에 시간은 제공된 시간 보다는 빠르게 소화할 수 있었다. 앞으로는 거부감 없이 할 수 있을 듯 하다.       생활코딩 수업 html, css, javascript 다시 듣기. 웹애플리케이션만들기 수업정도만 겉핣기식 따라하기 수업은 머릿속에 개념만 넣는 정도였다. 조금더 심화내용 수업을 들으며 개념확장 필요하다 생각된다.         내일 할 일           문자열            생활코딩 html css             html은 너무 기본적인 문법 및 코드스테이츠 커리큘럼과는 맞지 않는 방향이라 개념만 정립 후 css 수업으로 진행 예정.          ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.20-TIL/",
        "teaser": null
      },{
        "title": "21.07.21 TIL",
        "excerpt":"    오늘 한 일  1. 문자열     문자열은 배열처럼 요소 하나씩 접근이 가능하다. index로 접근은 가능하지만 쓸 수는 없다는 (read-only) 특징을 가진다.   문자열은 + 연산자를 쓸 수 있다. string 타입과 다른 타입 사이에 + 연산자를 쓰면, string 형식으로 변환된다. (toString)        문자열의 표현방식중 템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴이다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있다. 이전 버전의 ES2015사양 명세에서는 “template strings” (템플릿 문자열) 라고 불려 왔다.   ES6는 템플릿 리터럴(Template literal) 이라고 불리는 새로운 문자열 표기법을 도입하였다. 템플릿 리터럴은 일반 문자열과 비슷해 보이지만, ‘ 또는 “ 같은 통상적인 따옴표 문자 대신 백틱(backtick) 문자 ` 를 사용한다.        var a = 5; var b = 10; console.log(\"Fifteen is \" + (a + b) + \" and \\n not \" + (2 * a + b) + \".\"); // \"Fifteen is 15 and // not 20.\"  var a = 5; var b = 10; console.log(`Fifteen is ${a + b} and not ${2 * a + b}.`); // \"Fifteen is 15 and // not 20.\"           2. 호이스팅     함수 안에 있는 선언들을 모두 끌어 올려서 해당 함수 유효범위(scope)의 최상단에 선언하는 것을 말한다.   자바스크립트 해석기(parser)는 함수가 실행 되기전 해당 함수를 한 번 훑는다.   함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행시킨다.   이는 실제로 메모리 변화라던지, 코드가 끌어 올라가는 물리적 이동이 아닌, 자바스크립트 해석기 내부적으로 끌어올려서 처리하는것이므로 코드의 물리적 변화는 이뤄지지 않는다.   var 변수 선언과 함수 선언문 에서만 호이스팅이 일어난다.   var 변수 / 함수의 선언만 위로 끌어 올려지며, 할당은 끌어 올려지지 않는다.   코드의 가독성과 유지보수를 위해 호이스팅은 가급적 일어나지 않도록 해야 한다.            호이스팅을 잘 모르더라도 함수와 변수의 선언은 가급적 코드 상단부에서 이뤄지게끔 하자.       var 선언 방식은 불분문한 호이스팅의 주범이다. let/const 선언방식을 써서 불분문한 호이스팅이 이뤄지지 않게끔 통제가 필요하다.           3. 반복문  4. react  찍먹     생활코딩 React 수업을 진행하며 첫 챕터부터 가장 많이 들은 단어는 ‘가독성’, ‘재사용성’, ‘유지보수’ 이다. 세 단어 모두 다르지만 맥락은 비슷하다. Component를 어떻게 분리하며, 재사용 하는지가 이번 수업의 핵심이라 생각이 든다.            jsx (facebook 에서 개발된 유사 js) 를 이용한 효율적인 코딩.       component 를 통한 가독성 향상       build 를 통한 효율적인 네트워크 리소스 관리 이점.                 오늘 느낀 점           ZOOM 협업은 어제보다 익숙하다, 확실히 조건문부터는 코드풀이 난이도가 급 상승하였다. 좀더 간결하게 코드를 짜보자는 pair 와 의견을 나누고나서 코드의 재사용화, 다양한 기존 함수나 메소드를 통하여 간결한 문장 생성을 하려고 pair분과 소통하다보니 주어진시간이 짧게 느껴졌다.            pair에게 배울점이 많았다. 우선 같은 문항을 보았을때 짧은 시간내에 도출해 내는 의견들이 대게로는 비슷하였지만, 풀이과정에서 다른 방식으로 접근할 때가 있었다. 해당 부분은 전혀 생각지 못한 부분들도 있었으며, 생각은 해보았지만 어느 순간 막혀서 포기했던 접근방식들 또한 있었다. 이러한 생각을 공유할 수 있는 경험은 좋은 경험이었다.            2015년 이후 ES6에서 새롭게 추가되었다는 방식의 템플릿 리터럴을 오늘 처음 접하였다. 기존 es5 이전에서는 템플릿 문자열로 불려 왔는데, 이는 문법 정도로 해석하면 될 듯 하다. 기존 쓰는 방식인 표현식 삽입법은 직관적이지 않다는 단점과, 코드 작성 자체의 불편함이 공존하였다, 하지만 ES6 이후 템플릿 리터럴을 사용하게 되면, 이를 더욱 읽기도 쉬우며 코드 작성 또한 직관적이고 편리하게 관리 할 수 있게 되었다.       let name = \"KJH\"; let age = 32; console.log(name + 'is' + age + ' years old.');\t\t// KJH is 32 years old. console.log(`${name} is ${age} years old.`);\t\t// KJH is 32 years old.                그 외 ES6 이후 편리한 점은 호이스팅 (Hoisting) 이라는 개념이다. 자세한 개념은 위 학습한 내용에 기술해두었다. 개념만 말하자면, 변수 및 함수 선언이 작성한 코드의 상단으로 옮겨진다는 개념이다. 물론 실제로는 그렇지는 않지만, 이정도로만 해석하고 넘어가도록 하자.             내일 할 일           문자열            생활코딩 html css      ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.21-TIL/",
        "teaser": null
      },{
        "title": "21.07.22 TIL",
        "excerpt":"    오늘 한 일  1. 반복문 코플릿          오늘 학습한 내용 중 가장 인상 깊었던 코드 풀이를 다시 한번 복습해보겠다. 수를 입력받아 홀수인지 여부를 리턴해야 한다. 반복문(while)문을 사용해야 합니다. 나눗셈(/), 나머지(%) 연산자 사용은 금지됩니다. 0은 짝수로 간주합니다.          /*---입출력 예시---*/ let output = isOdd(17); console.log(output); // --&gt; true output = isOdd(-8); console.log(output); // --&gt; false  /*---함수 작성---*/ function isOdd(num) {   let i = 0;\t\t// while 문의 조건식을 검색할 인자. 변수 i 선언 및 초기값 0 할당.   let evenOdd = 1;\t// 짝수와 홀수를 evenOdd에 담긴 양수(홀수)와 음수(짝수)의 값으로 판단 할 예정이므로 evenOdd 변수 선언 (초기 값은 1을 주어서, 0을 짝수로 간주한다. ex)num = 0일 경우 단 한번의 while문 만 실행되므로, evenOdd = -1(음수=짝수) 로 반복문을 나가게 된다. )    while(i&lt;=Math.abs(num)){\t// num값이 음수로 들어 올경우 Math.abs 메소드를 이용하여 절대값으로 연산한다.     evenOdd *= -1;\t\t// evenOdd 값에 -1을 곱하여 재 할당한다.     i++;\t\t\t// i를 1만큼 증가시킨다.   }\t\t\t\t// Math.abs(num)까지 i 가 while문 안을 수행 후 } 를 빠져나오면 evenOdd는 -1 또는 1의 값 두가지 값중 한가지 값을 내포한다.    if(evenOdd &gt; 0)\t\t// evenOdd의 값이 양수일 경우 true 값을 return 하여 홀수임을 나타낸다     return true;   else \t\t\t\t// evenOdd의 값이 그 외에 경우 false 값을 return 하여 짝수임을 나타낸다     return false; }                 오늘 느낀 점           읭?.. 반복문 개념학습은 1시간 코드풀이는 5시간.., 이중반복문 좀(좀 많이) 애먹었지만 확실히 문제를 풀어가며 pair분과 머리를 맞대며 도출해내는 과정은 희열감이 느껴지기도 했다. 확실히 개념 수업이라 일컫는 TEXT 읽는 것 보단 직접 짜본 내 코드들이 내 학습에는 더욱 도움이 되는 듯 하였다, 실제로 몇시간은 금방금방 지나가는 기적을 겪였다…            기본 수업 외에 오늘은 내 학습을 못한듯하다… 어젠 분명 리액트 수업이 재밌었는데.. 개발환경 구축하고 오늘은 터미널 켜보지도 않았다. 스트레스 컨트롤도 중요하다. 장기전이라 생각하고 임하자.             내일 할 일      다음주 수업은 새로운 pair 와 계산기, 짝수 생성기(?) 간단한 프로그래밍 코딩을 할 예정인듯 보인다. 이번주 수업 내용 복습 및 부족한 부분 check 는 내일 필수적으로 이뤄져야 할 듯 하다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.22-TIL/",
        "teaser": null
      },{
        "title": "21.07.23 TIL",
        "excerpt":"    오늘 한 일  1. CSS          CSS 문법        선택자(selector) 에는 태그이름이나 id 또는 클래스 등이 올수있다. 선택자로 특정 요소를 선택할수 있으며, 선택 후 중괄호 안의 선언 블럭에서 이 선택자에 적용 할 내용들을 작성한다.            id는 한 문서에 단 하나의 id 값을 가질수 있으며 # 기호를 이용하여 선택한다.       class는 동일한 기능을 하는 css를 여러 요소에 적용하기 위해 선택되며 . 기호를 이용하여 선택한다.           속성은 선택자 안에 요소로써 적용할 수 있는 내용이다. 속성과 값의 끝에는 세미콜론 ;을 붙여 속성끼리 구분한다.            다양한 속성 값은 해당링크에서 참조하자 CSS 참고서 -MDN.                박스모델은 레이아웃 설계시 가장 주의하여 구성해야 한다. (줄바꿈이 되는 박스(block), 옆으로 붙는 박스(inline, inline-block)가 있기에 설계시 미리 계획 후 설계해야한다.)                                              block           inline-block           inline                                           줄바꿈 여부           O           X           X                             기본적으로 갖는 너비(width)           100%           글자가 차지하는 만큼           글자가 차지하는 만큼                             width, height 사용 가능여부           O           O           X                                  줄바꿈이 되는 태그 : &lt;h1&gt; &lt;p&gt;, … 그 외 태그 알아보기 : Block-level elements MDN       줄바꿈이 되지 않는 태그 : &lt;span&gt;, … 그 외 태그 알아보기 : Inline elements MDN                박스를 구성하는 요소는 다음 그림안의 요소들을 기억하자.                    오늘 느낀 점           질문의 중요성, 이제껏 모르는 점들을 구글링만으로 검색을 해보았다. 하지만 구글은 너무 다양한 질문들이 존재하였다.  아고라스테이츠  를 보니 나와 비슷한 수준, 비슷한 경험을 가진 사람들이 올린 질문들이 많으니 활용하는게 좋아보인다.            이제껏 CSS는 디자이너(?) 의 영역이라 생각하며 소홀히 해왔는데, 잘못생각했다… 반응형 웹이라던지 소비자들과 맞닿는 영역에서 이뤄지는 CSS도 굉장히 중요하다 생각된다.             예를 들면, 오늘의 집과 집꾸미기 사이트를 보면 CSS의 중요성을 한 눈에 볼 수 있다 생각한다. (오늘의집과 집꾸미기는 필자와는 상관없습니다…) (21.07.23 기준 작성)                                스크롤을 내려도 구매옵션과 구매란이 따라오는 CSS 디자인은 상품상세설명을 쉽게 보면서 구매까지 소비자가 불편함없이 프로세스가 이어진다.                         반면 스크롤을 내리면 구매옵션과 구매란이 따라 오지 않는 고정적인 CSS 디자인은 소비자에게 옵션암기(!?) 라는 불편함을  강요를 한다. (구매색상이 마음에 들어 구매하려고 상단으로 올려서 모든 옵션을 다 고른뒤 구매버튼을 누르면 “아 색상이 뭐였지..?” 라는 생각이 다시 떠올라 웹페이지를 다시 내려본다는 등의 불편함이 야기될수 있음)                 내일 할 일      CSS 실습 필요. 학습보다는 다양한 id, class를 선언해가며 속성값을 주는 실습이 필요로해보인다.   구글의 기술트렌드 리포트를 보니 과거에는 jQuery 가 주요 기술 트렌드였다면 16~18년도 이후  부터는 그 자리를 React에게 내주었다는 리포트를 오늘 학습도중 알게되었다.  그렇기에 React는 꾸준히 학습이 필요로 보인다… 아직 찍먹 수준이라 본수업이 다가오기전 매주 주말 통하여 충분한 학습이 필요로 할 듯 하다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.23-TIL/",
        "teaser": null
      },{
        "title": "21.08.02 TIL",
        "excerpt":"    오늘 한 일  1. 객체 코플릿     객체는 배열과 다르게 순서성을 가지지 않으며, 묶음으로 된 데이터에 이름을 붙혀, 의미를 부여할 수 있다. 배열또한 각 값이 하나의 변수로 묶인 데이터이지만, 각 index가 어떤 정보를 갖고 있는지 알아야지 해당 값에 접근이 용이하다.            객체는 키쌍값(key-value pair)으로 이루어져 있다.            객체의 값을 사용하거나 추가할 땐 Dot notation, Bracket notation 방식을 사용한다   할당된 키와 값을 지울 땐 delete 키워드를 이용해 삭제가 가능하다.        객체 안에 특정한 키가 있는지 확인이 필요할 땐, in 연산자를 이용하여 확인한다.            for ... in : 상속된 열거 가능한 속성들을 포함하여 객체에서 문자열로 키가 지정된 모든 열거 가능한 속성에 대해 반복합니다.           for (variable in object) { ... }                 variable : 매번 반복마다 다른 속성이름(Value name)이 변수(variable)로 지정됩니다.       object :  반복작업을 수행할 객체로 열거형 속성을 가지고 있는 객체.              Note: for…in은 인덱스의 순서가 중요한 Array에서 반복을 위해 사용할 수 없습니다.    2. Github 블로그 이사         블로그를 velog에서 git에서 jekyll 환경으로 세팅하는 블로그로 변경해보았다.     https://honbabzone.com/ 해당 블로그를 통해서 minimal-mistakes 테마를 이용하여 세팅을 해보았다. 우선 불필요한 포스팅을 줄이고 오늘 배운 내용 및 시간을 어떻게 보냈는지, 어떤점을 느끼고 발전했는지에 대한 부분만 짚고 넘어갈 예정이다.            오늘 느낀 점      어렵다… git blog .. 8.1 ~ 8.2, 이틀동안 지금 챕터진행 말고 블로그 셋팅 씨름한 덕에 포스트 commit 하고 푸쉬할 수 있게되었다. 물론 지금 테마 및 셋팅이 맘에 드는건 아니지만, 일단 나중으로 미루고 포스팅이 우선인듯하여 우선 급하게 셋팅을 마무리 지었다.   추후 상단 nav에 위치한 메뉴버튼들을 좌측 사이드바로 옮기고 싶다.  스크롤에 반응하는 author_ profile 목록은 그렇게 유용하진 않는듯하다..   사소한거지만.. html 구조파악에 시간이 너무 오래걸렸다. 셋팅 위한 한글 포스팅도 많이 없는 상황이다 (상단에 올려둔 7271kim 님의 블로그 세팅이 거의 대중화(?)되었다고 보면 될 듯하다. 우선은 천천히 코드및 구조를 뜯어보며 변경해보는거로 미뤄둬야겠다.         내일 할 일     CSS 챕터 학습   남은 기존 posts 이동하기 &amp;&amp; 7월 19일 부터 달려온, 보름정도의 기간 self-check 회고 posting 하기 (blog setting 은 현재 상태로 만족하고 학습에 몰두해야겠다.)   DOM 개념 잡기  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.02-TIL/",
        "teaser": null
      },{
        "title": "21.08.03 TIL",
        "excerpt":"    오늘 한 일  1. 다양한 CSS 셀렉터  h1 {  }  // 셀렉터 div {  }    * {  }  // 전체 셀렉터  section, h1 {  }  // 태그 셀렉터  #only {  }  // ID 셀렉터  .center {  }  // class 셀렉터  a[href] { }  // attribute 셀렉터 p[id=\"only\"] { }  header h1 {}  // 후손 셀렉터  header &gt; p { }  // 자식 셀렉터  section + p { }  // 인접 형제 셀렉터  section ~ p { }  // 형제 셀렉터  a:hover { }  // 가상 셀렉터 a:active { }  input:checked + span { }  // 요소 상태 셀렉터 input:enabled + span { }  p:first-child { }  // 구조 가상 클래스 셀렉터 ul &gt; li:last-child { }  input:not([type=\"password\"]) { } // 부정 셀렉터 div:not(:nth-of-type(2)) { }  input[type=\"text\"]:valid { }  // 정합성 확인 셀렉터 input[type=\"text\"]:invalid { }      새로 학습한 셀렉터          attribute 셀렉터  ,  부정 셀렉터         2-1 . CSS layout (Atomic CSS)     &lt;div id=\"container\"&gt;   &lt;div class=\"col w10\"&gt;      &lt;div class=\"icon\"&gt;아이콘 1&lt;/div&gt;     &lt;div class=\"icon\"&gt;아이콘 2&lt;/div&gt;     &lt;div class=\"icon\"&gt;아이콘 3&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"col w20\"&gt;     &lt;div class=\"row h40\"&gt;영역1&lt;/div&gt;     &lt;div class=\"row h40\"&gt;영역2&lt;/div&gt;     &lt;div class=\"row h20\"&gt;영역3&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"col w70\"&gt;     &lt;div class=\"row h80\"&gt;영역4&lt;/div&gt;     &lt;div class=\"row h20\"&gt;영역5&lt;/div&gt;   &lt;/div&gt; &lt;/div&gt;   .w70 { width: 70%; } .h40 { height: 40%; }  * {  // 기본 스타일 제거 (box-sizing)   box-sizing: border-box; }  body {  // 기본 스타일 제거 (여백 제거)   margin: 0;   padding: 0; }     박스의 시작을 정확히 (0,0)의 위치에서 시작하고 싶은데, &lt;body&gt; 태그가 가진 기본 스타일에 약간의 여백을 포함하지 않아 계산에 어려움이 있다. 위에 언급한 문제를 해결할 몇 줄의 코드를 적용시키면, 기본 스타일링을 제거하여 디자인한 대로 레이아웃을 구현할 수 있습니다.   이렇게 클래스 이름과 구현을 1:1로 일치시켜 아주 작은 단위로 CSS를 작성 기법을 Atomic CSS 방법론이라고 한다.     2-2. CSS layout (flexbox)     flexbox로 레이아웃을 구성한다는 것은, 박스를 유연하게 늘리거나 줄여 레이아웃을 잡는 방법이다.   &lt;div id=\"outer\"&gt;   &lt;div class=\"box\"&gt;box1&lt;/div&gt;   &lt;div class=\"box\"&gt;box2&lt;/div&gt;   &lt;div class=\"box\"&gt;box3&lt;/div&gt; &lt;/div&gt;   #outer {   display: flex;   border: 1px dotted red;   padding: 10px; }  .box {   border: 1px solid green;   padding: 10px; }              부모 박스요소에 display: flex를 적용해, 자식 박스의 방향과 크기를 결정한다. 기본값으로, display: flex가 적용된 부모 박스의 자식 요소는 왼쪽부터 차례대로 이어 배치된다.       반드시 알아두기: grow(팽창 지수), shrink(수축 지수), basis(기본 크기)            자식 박스에 어떠한 속성도 주지 않으면, flex: 0 1 auto; 기본값이 적용됩니다.           grow, shrink 속성은 단위가 없고, 비율에 따라 결과가 달라진다. 부모 박스 안에 n개의 자식 박스가 있다고 가정하고 각 자식 박스가 갖는 grow값의 총 합이 n이라면,  grow 속성의 값을 1로 설정하는 것은 1/n 가로 또는 세로길이를 적용한다는 의미이다.    &lt;div id=\"outer\"&gt;   &lt;div class=\"box target\"&gt;.box.target&lt;/div&gt;   &lt;div class=\"box\"&gt;.box&lt;/div&gt;   &lt;div class=\"box\"&gt;.box&lt;/div&gt; &lt;/div&gt;   .target {   flex: 1 1 auto; }        flex-grow  : 1 이다. box.target은 부모 박스의 가로 길이 중에서 남은 빈 영역만큼 늘어나게 된다. 위 설명대로라면 전체 자식요소가 가진 grow 값의 합은 1+0+0 = 1이므로, box.target의 가로 크기는 1/1 = 100% 이다. 그러나 다른 자식 박스 안에 이미 콘텐츠가 존재하므로, 다른 자식 박스안의 콘텐츠가 담긴 길이를 제외한 나머지 가로 길이가 box.target의 가로 길이가 된다.   .target {   flex: 1 1 auto; }   .box {   flex: 1 1 auto; }     만약 .box의 flex-grow : 1로 설정하면, 모든 박스가 늘어나려고(grow) 합니다. 결과적으로 모든 박스가 동일한 비율로 가로 길이가 늘어납니다. (총 grow 값 1+1+1, 각 박스는 1/3씩 크기를 가짐)              shrink는 grow와 반대로, 설정한 비율만큼 박스 크기가 작아진다. 그러나 flex-grow 속성과 flex-shrink 속성을 함께 사용시 flex-shrink 속성은 width나 이후 설명할 flex-basis 속성에 따른 비율이므로 실제 크기를 예측하기가 어렵게 된다. flex-grow 속성으로 비율을 변경하는 경우, flex-shrink 속성은 기본값인 1로 두어도 무방하다.            basis는 자식박스가 flex-grow나 flex-shrink에 의해 늘어나거나 줄어들기 전에 가지는 기본 크기이다.       2-3. CSS layout (flexbox 콘텐츠 정렬 방법)     Flexbox를 원하는대로 제어하기 위해서는 axis(축)의 개념에 대한 이해가 필요하다.  axis는 main axis 와 cross axis로 구분된다.            main axis는 flex-direction 속성에 의해서 결정된다. flex-direction의 기본 값인 row 인 상태일 때 main axis 는 가로축(가로축이 default)이 된다.       cross axis는 여러 개의 main axis와 수직을 이루는 방향입니다. main axis가 가로일 때 cross axis는 세로가 됩니다.                 오늘 느낀 점         내일 할 일  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.03-TIL/",
        "teaser": null
      }]
