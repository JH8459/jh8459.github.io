var store = [{
        "title": "[TIL] 코드스테이츠 1일차",
        "excerpt":"    Today I Learned  1. 학습 툴 셋팅     리눅스 환경 (ubuntu os) 에 개발환경 구축.         오늘 느낀 점           코드스테이츠 1일차 앞으로의 강의 일정 및 학습에 대해서 설명을 들었다. 강의라기보다는 줌을 통해서 소통한 느낌.            자기주도적 학습을 강조하였다. 실제로 온라인을 통하여 수업이 진행되며 커리큘럼이 진행되기때문에.. 혼자 학습시간을 지키려 노력하고 이런 노력들 자체도 모두 자기주도적 학습이라 생각한다. 이러한 학습태도는 앞으로 수료시점까지는 당연하며 개발자로써 평생 몸에 지녀야할 기본소양이라 느껴진다. 평생 공부해야지..             내일 할 일      변수, 타입, 함수, 조건문  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.19.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 변수 2. 타입 3. 함수 4. 조건문",
        "excerpt":"    Today I Learnd  1. 변수     변수를 이용하면 데이터를 편리하게 저장하고 꺼내 쓸 수 있게 한다.   변수의 선언과 값의 할당에 대해서 학습하였다.            선언(declaration)을 통하여 변수를 선언할 수 있다.       할당(assignment)을 통하여 변수에 값을 저장하게 된다. 이때 사용되는 ‘=’은 같다라는 뜻이 아닌 ‘할당 연산자(Assignment operator)’이다.       var, let, const 선언방식의 차이점을 학습하였다.                                                                                   var                 let                 const                                                                         중복선언                 O                 X                 X                                               재할당                 O                 O                 X                                                                  변수명은 다음의 규칙에 따라 명명된다. reference. Camel Case     할당이 없는 변수의 경우 undefined 값을 가진다. (값이 없는게 아닌 해당 undefined값을 가진다)   2. 타입     원시 자료형, 참조 자료형 in JS 를 학습하였다.   typeof 연산자를 통하여 특정 갑의 타입을 확인할 수 있다.   3. 함수          함수는 “작은 기능의 단위”이며 키워드(keyword), 이름(name), 매개변수(parameter), 몸통(body)로 구분된다         function muntiPle(num){ // function(키워드), multiPle(이름), num(매개변수)       console.log(num*1);       console.log(num*2);       console.log(num*3);       console.log(num*4);       console.log(num*5);       console.log(num*6);       console.log(num*7);       console.log(num*8);       console.log(num*9); // body 부분   }                구체적인 입력과 출력을 가지고있으며, 호출 후에는 반드시 return 된다.       4. 조건문          조건문은 어떠한 조건을 판별한다. 그렇기에 비교 연산자(comparison operator)가 필요하다.         3 &gt; 5;\t\t// false   3 &lt; 5;\t\t// true   'hi' === 'hello'\t// false   'hi' !== 'hello'\t// true                 비교 연산자의 결과는 늘 Boolean, 즉 true 혹은 false 이다.       주의 해야 할 비교 연산자 ( == , != ) : 값 만을 비교 (data type은 논외) 하기 때문에 엄격한 비교가 불가능하다. 예외가 많기 떄문에 === 와 비교하면 오류가 많다.                두가지 조건이 한번에 적용되는 경우가 필요 할 땐, 논리 연산자(logical operator)를 사용하여 조건문을 작성한다.         isStudent &amp;&amp; isFemale;\t// 학생이면서 여성일때 통과   isStudent || isFemale;\t// 학생이거나 여성이면 통과   !isStudent &amp;&amp; isFemale;\t// 학생이 아니면서 여성일때 통과                truthy와 falsy가 조건문에서 작동하는 방식을 이해할 수 있다.             기억해야 할 6가지 falsy 값, 해당 값들은 false로 반환되므로 if문이 실행되지 않는다.                    false,  null, undefined, 0, NaN, ''                            5. HTML     하이퍼텍스트를 (링크) 가장 중요한 특징으로 하는 마크업이라는 형식을 가진 컴퓨터 프로그래밍 언어.            Markup이란? 그 파일이 프린터로 출력되거나 화면에서 어떻게 보여야할 것인지를 나타내기 위해 또는 그 문서의 논리적인 구조를 묘사하기 위해서, 텍스트나 워드프로세싱 파일의 특정위치에 삽입되는 일련의 문자들이나 기호들을 말한다. 마크업에 사용되는 표지를 흔히 ‘태그’라고 부른다.           태그 설명은 reference. HTML tag         오늘 느낀 점           코드스테이츠 2일차.. 잠을 엄청 설쳤다… 부담감 때문인가? 스트레스 컨트롤도 중요해보인다…            블로그에 학습내용 포스팅은 계속 진행할 예정.       구글은 신이다.            mdn 키워드 mdn 자체가 읽기가 어려워….. 익숙해지자       키워드를 통한 검색 생활화 하기. 영어로 검색하자       Stack Overflow 애용하기 아직은 봐도 잘 모르겠다…                처음으로 둘 이상의 인원이 모여 ZOOM을 통한 협업으로 코드 풀이를 해보았다. 생각보다 ZOOM 을 통한 협업은 불편하지 않았다, 화면쉐어링 등 기본 제공하는 툴들만으로도 의견 전달에는 문제가 없었다. pair 훈련 자체가 오늘 첫 시행이라 난이도가 낮았기에 시간은 제공된 시간 보다는 빠르게 소화할 수 있었다. 앞으로는 거부감 없이 할 수 있을 듯 하다.       생활코딩 수업 html, css, javascript 다시 듣기. 웹애플리케이션만들기 수업정도만 겉핣기식 따라하기 수업은 머릿속에 개념만 넣는 정도였다. 조금더 심화내용 수업을 들으며 개념확장 필요하다 생각된다.         내일 할 일           문자열            생활코딩 html css             html은 너무 기본적인 문법 및 코드스테이츠 커리큘럼과는 맞지 않는 방향이라 개념만 정립 후 css 수업으로 진행 예정.          ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.20.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 문자열 2. 반복문 3. 호이스팅 4. React",
        "excerpt":"    Today I Learnd  1. 문자열     문자열은 배열처럼 요소 하나씩 접근이 가능하다. index로 접근은 가능하지만 쓸 수는 없다는 (read-only) 특징을 가진다.   문자열은 + 연산자를 쓸 수 있다. string 타입과 다른 타입 사이에 + 연산자를 쓰면, string 형식으로 변환된다. (toString)        문자열의 표현방식중 템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴이다. 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있다. 이전 버전의 ES2015사양 명세에서는 “template strings” (템플릿 문자열) 라고 불려 왔다.   ES6는 템플릿 리터럴(Template literal) 이라고 불리는 새로운 문자열 표기법을 도입하였다. 템플릿 리터럴은 일반 문자열과 비슷해 보이지만, ‘ 또는 “ 같은 통상적인 따옴표 문자 대신 백틱(backtick) 문자 ` 를 사용한다.        var a = 5; var b = 10; console.log(\"Fifteen is \" + (a + b) + \" and \\n not \" + (2 * a + b) + \".\"); // \"Fifteen is 15 and // not 20.\"  var a = 5; var b = 10; console.log(`Fifteen is ${a + b} and not ${2 * a + b}.`); // \"Fifteen is 15 and // not 20.\"           2. 호이스팅     함수 안에 있는 선언들을 모두 끌어 올려서 해당 함수 유효범위(scope)의 최상단에 선언하는 것을 말한다.   자바스크립트 해석기(parser)는 함수가 실행 되기전 해당 함수를 한 번 훑는다.   함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행시킨다.   이는 실제로 메모리 변화라던지, 코드가 끌어 올라가는 물리적 이동이 아닌, 자바스크립트 해석기 내부적으로 끌어올려서 처리하는것이므로 코드의 물리적 변화는 이뤄지지 않는다.   var 변수 선언과 함수 선언문 에서만 호이스팅이 일어난다.   var 변수 / 함수의 선언만 위로 끌어 올려지며, 할당은 끌어 올려지지 않는다.   코드의 가독성과 유지보수를 위해 호이스팅은 가급적 일어나지 않도록 해야 한다.            호이스팅을 잘 모르더라도 함수와 변수의 선언은 가급적 코드 상단부에서 이뤄지게끔 하자.       var 선언 방식은 불분문한 호이스팅의 주범이다. let/const 선언방식을 써서 불분문한 호이스팅이 이뤄지지 않게끔 통제가 필요하다.           3. 반복문  4. react  찍먹     생활코딩 React 수업을 진행하며 첫 챕터부터 가장 많이 들은 단어는 ‘가독성’, ‘재사용성’, ‘유지보수’ 이다. 세 단어 모두 다르지만 맥락은 비슷하다. Component를 어떻게 분리하며, 재사용 하는지가 이번 수업의 핵심이라 생각이 든다.            jsx (facebook 에서 개발된 유사 js) 를 이용한 효율적인 코딩.       component 를 통한 가독성 향상       build 를 통한 효율적인 네트워크 리소스 관리 이점.                 오늘 느낀 점           ZOOM 협업은 어제보다 익숙하다, 확실히 조건문부터는 코드풀이 난이도가 급 상승하였다. 좀더 간결하게 코드를 짜보자는 pair 와 의견을 나누고나서 코드의 재사용화, 다양한 기존 함수나 메소드를 통하여 간결한 문장 생성을 하려고 pair분과 소통하다보니 주어진시간이 짧게 느껴졌다.            pair에게 배울점이 많았다. 우선 같은 문항을 보았을때 짧은 시간내에 도출해 내는 의견들이 대게로는 비슷하였지만, 풀이과정에서 다른 방식으로 접근할 때가 있었다. 해당 부분은 전혀 생각지 못한 부분들도 있었으며, 생각은 해보았지만 어느 순간 막혀서 포기했던 접근방식들 또한 있었다. 이러한 생각을 공유할 수 있는 경험은 좋은 경험이었다.            2015년 이후 ES6에서 새롭게 추가되었다는 방식의 템플릿 리터럴을 오늘 처음 접하였다. 기존 es5 이전에서는 템플릿 문자열로 불려 왔는데, 이는 문법 정도로 해석하면 될 듯 하다. 기존 쓰는 방식인 표현식 삽입법은 직관적이지 않다는 단점과, 코드 작성 자체의 불편함이 공존하였다, 하지만 ES6 이후 템플릿 리터럴을 사용하게 되면, 이를 더욱 읽기도 쉬우며 코드 작성 또한 직관적이고 편리하게 관리 할 수 있게 되었다.       let name = \"KJH\"; let age = 32; console.log(name + 'is' + age + ' years old.');\t\t// KJH is 32 years old. console.log(`${name} is ${age} years old.`);\t\t// KJH is 32 years old.                그 외 ES6 이후 편리한 점은 호이스팅 (Hoisting) 이라는 개념이다. 자세한 개념은 위 학습한 내용에 기술해두었다. 개념만 말하자면, 변수 및 함수 선언이 작성한 코드의 상단으로 옮겨진다는 개념이다. 물론 실제로는 그렇지는 않지만, 이정도로만 해석하고 넘어가도록 하자.             내일 할 일           문자열            생활코딩 html css      ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.21.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 반복문 코플릿",
        "excerpt":"    Today I Learnd  1. 반복문 코플릿          오늘 학습한 내용 중 가장 인상 깊었던 코드 풀이를 다시 한번 복습해보겠다. 수를 입력받아 홀수인지 여부를 리턴해야 한다. 반복문(while)문을 사용해야 합니다. 나눗셈(/), 나머지(%) 연산자 사용은 금지됩니다. 0은 짝수로 간주합니다.          /*---입출력 예시---*/ let output = isOdd(17); console.log(output); // --&gt; true output = isOdd(-8); console.log(output); // --&gt; false  /*---함수 작성---*/ function isOdd(num) {   let i = 0;\t\t// while 문의 조건식을 검색할 인자. 변수 i 선언 및 초기값 0 할당.   let evenOdd = 1;\t// 짝수와 홀수를 evenOdd에 담긴 양수(홀수)와 음수(짝수)의 값으로 판단 할 예정이므로 evenOdd 변수 선언 (초기 값은 1을 주어서, 0을 짝수로 간주한다. ex)num = 0일 경우 단 한번의 while문 만 실행되므로, evenOdd = -1(음수=짝수) 로 반복문을 나가게 된다. )    while(i&lt;=Math.abs(num)){\t// num값이 음수로 들어 올경우 Math.abs 메소드를 이용하여 절대값으로 연산한다.     evenOdd *= -1;\t\t// evenOdd 값에 -1을 곱하여 재 할당한다.     i++;\t\t\t// i를 1만큼 증가시킨다.   }\t\t\t\t// Math.abs(num)까지 i 가 while문 안을 수행 후 } 를 빠져나오면 evenOdd는 -1 또는 1의 값 두가지 값중 한가지 값을 내포한다.    if(evenOdd &gt; 0)\t\t// evenOdd의 값이 양수일 경우 true 값을 return 하여 홀수임을 나타낸다     return true;   else \t\t\t\t// evenOdd의 값이 그 외에 경우 false 값을 return 하여 짝수임을 나타낸다     return false; }                 오늘 느낀 점           읭?.. 반복문 개념학습은 1시간 코드풀이는 5시간.., 이중반복문 좀(좀 많이) 애먹었지만 확실히 문제를 풀어가며 pair분과 머리를 맞대며 도출해내는 과정은 희열감이 느껴지기도 했다. 확실히 개념 수업이라 일컫는 TEXT 읽는 것 보단 직접 짜본 내 코드들이 내 학습에는 더욱 도움이 되는 듯 하였다, 실제로 몇시간은 금방금방 지나가는 기적을 겪였다…            기본 수업 외에 오늘은 내 학습을 못한듯하다… 어젠 분명 리액트 수업이 재밌었는데.. 개발환경 구축하고 오늘은 터미널 켜보지도 않았다. 스트레스 컨트롤도 중요하다. 장기전이라 생각하고 임하자.             내일 할 일      다음주 수업은 새로운 pair 와 계산기, 짝수 생성기(?) 간단한 프로그래밍 코딩을 할 예정인듯 보인다. 이번주 수업 내용 복습 및 부족한 부분 check 는 내일 필수적으로 이뤄져야 할 듯 하다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.22.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 소비자들과 맞닿는 영역에서의 CSS",
        "excerpt":"    Today I Learnd  1. CSS          CSS 문법        선택자(selector) 에는 태그이름이나 id 또는 클래스 등이 올수있다. 선택자로 특정 요소를 선택할수 있으며, 선택 후 중괄호 안의 선언 블럭에서 이 선택자에 적용 할 내용들을 작성한다.            id는 한 문서에 단 하나의 id 값을 가질수 있으며 # 기호를 이용하여 선택한다.       class는 동일한 기능을 하는 css를 여러 요소에 적용하기 위해 선택되며 . 기호를 이용하여 선택한다.           속성은 선택자 안에 요소로써 적용할 수 있는 내용이다. 속성과 값의 끝에는 세미콜론 ;을 붙여 속성끼리 구분한다.            다양한 속성 값은 해당링크에서 참조하자 CSS 참고서 -MDN.                박스모델은 레이아웃 설계시 가장 주의하여 구성해야 한다. (줄바꿈이 되는 박스(block), 옆으로 붙는 박스(inline, inline-block)가 있기에 설계시 미리 계획 후 설계해야한다.)                                              block           inline-block           inline                                           줄바꿈 여부           O           X           X                             기본적으로 갖는 너비(width)           100%           글자가 차지하는 만큼           글자가 차지하는 만큼                             width, height 사용 가능여부           O           O           X                                  줄바꿈이 되는 태그 : &lt;h1&gt; &lt;p&gt;, … 그 외 태그 알아보기 : Block-level elements MDN       줄바꿈이 되지 않는 태그 : &lt;span&gt;, … 그 외 태그 알아보기 : Inline elements MDN                박스를 구성하는 요소는 다음 그림안의 요소들을 기억하자.                    오늘 느낀 점           질문의 중요성, 이제껏 모르는 점들을 구글링만으로 검색을 해보았다. 하지만 구글은 너무 다양한 질문들이 존재하였다.  아고라스테이츠  를 보니 나와 비슷한 수준, 비슷한 경험을 가진 사람들이 올린 질문들이 많으니 활용하는게 좋아보인다.            이제껏 CSS는 디자이너(?) 의 영역이라 생각하며 소홀히 해왔는데, 잘못생각했다… 반응형 웹이라던지 소비자들과 맞닿는 영역에서 이뤄지는 CSS도 굉장히 중요하다 생각된다.             예를 들면, 오늘의 집과 집꾸미기 사이트를 보면 CSS의 중요성을 한 눈에 볼 수 있다 생각한다. (오늘의집과 집꾸미기는 필자와는 상관없습니다…) (21.07.23 기준 작성)                                스크롤을 내려도 구매옵션과 구매란이 따라오는 CSS 디자인은 상품상세설명을 쉽게 보면서 구매까지 소비자가 불편함없이 프로세스가 이어진다.                         반면 스크롤을 내리면 구매옵션과 구매란이 따라 오지 않는 고정적인 CSS 디자인은 소비자에게 옵션암기(!?) 라는 불편함을  강요를 한다. (구매색상이 마음에 들어 구매하려고 상단으로 올려서 모든 옵션을 다 고른뒤 구매버튼을 누르면 “아 색상이 뭐였지..?” 라는 생각이 다시 떠올라 웹페이지를 다시 내려본다는 등의 불편함이 야기될수 있음)                 내일 할 일      CSS 실습 필요. 학습보다는 다양한 id, class를 선언해가며 속성값을 주는 실습이 필요로해보인다.   구글의 기술트렌드 리포트를 보니 과거에는 jQuery 가 주요 기술 트렌드였다면 16~18년도 이후  부터는 그 자리를 React에게 내주었다는 리포트를 오늘 학습도중 알게되었다.  그렇기에 React는 꾸준히 학습이 필요로 보인다… 아직 찍먹 수준이라 본수업이 다가오기전 매주 주말 통하여 충분한 학습이 필요로 할 듯 하다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.23.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 계산기 실습",
        "excerpt":"    Today I Learnd  1. 계산기 실습 : github repository            오늘 느낀 점     html, css, js 세분화 된 학습이 아닌, 세가지의 모든 기능을 더한 웹페이지 만들기는 생각보다 상호간 작용을 염두해야 원활이 구현된다.         내일 할 일     계산기 실습 level nightmare 까지 구현해보기.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.26.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 계산기 실습(nightmare)",
        "excerpt":"    Today I Learnd  1. 계산기 실습 : Github 참조.            오늘 느낀 점     점점.. 수업에 내가 밀려나간다. 장기전이다, 멘탈 관리. 모르는 부분이있다면 붙잡고 끙끙 앓기보다는 조금더 학습 후 주말중 부족한 부분을 다시 학습하여 멘탈 관리 및 부족한 부분을 메꿔나가야 할 듯 하다.   CSS .. 만만히 볼 분야가 절대 아니다. JS를 통하여 CSS를 조작하거나 제어하는 분야 말고도 특정한 상태나 규칙에 따라 CSS 스스로 동작하는 선택자들 또한 존재하였다. 단순 코드 몇줄 만으로도 코드가 다이나믹해지는 효과를 볼 수 있다.   선택자에는 태그, id, class만 선택되는줄 알았다..복합선택자, 부모/자식 개념 만만하지않다…         내일 할 일     내일 일정은 리눅스 기초 수업이다. React를 맛만 보았을때 node.js 개발 환경은 이미 내 PC에 셋팅을 해두었다. 수업방향에 맞춰서 다시 세팅해보고 React 또한 다시 학습해보는 기회를 가져봐야겠다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.27.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. Linux CLI 2. 패키지와 패키지 매니저 3. Node.js 4. React",
        "excerpt":"    Today I Learnd  1. Linux CLI     명령 줄 인터페이스(CLI, Command line interface) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식을 뜻한다. 즉, 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다.   2. 패키지와 패키지 매니저  2-1. 패키지     리눅스에서 빈번하게 사용하는 ‘패키지’란 커널 및 라이브러리 버전의 배포판 환경에 맞추어 빌드한 실행파일을 압축한 것이다.   우분투 환경에서는 데미안 스타일의 패키지 방식을 이용하기에 해당 방식을 학습하였으며, 해당 환경으로 환경을 구성하였다.   2-2. 패키지 매니저     APT(Advanced Packaging Tool)는 데비안과 우분투를 포함하여 데비안 계열 리눅스 배포판들의 주 패키지 관리 도구이다.   3. Node.js     쉽게 말하면 JavaScript 런타임(Runtime)이다., 여기서 런타임이란 프로그래밍 언어가 구동되는 환경을 뜻한다. Node.js 는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임이다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이다.   3-1. Node.js를 왜 사용하나?          Node.js 라이브러리 내의 API는 모두 비동기식이다. None-Blocking 즉, 멈추지 않는다는 의미이다. API를 실행 하고 완료되기까지 기다리지 않고 바로 다음 API를 실행한다. 그리고 예전에 실행한 API가 값을 반환하면 이벤트 루프가 이를 확인하고 값을 받아온다. 단일 쓰레드 모델을 사용하며, 이벤트 메커니즘을 통하여 서버가 멈추지 않고 반응할 수 있기에 확장성이 좋다.       위와같은 특징때문에 데이터를 실시간을 다루는 애플리케이션이나 싱글페이지 애플리케이션(SPA), 입출력이 잦은 애플리케이션을 개발할 때 뛰어난 효율성을 발휘할 수 있다. 다만, 싱글 쓰레드 모델이기 때문에 하나의 작업 자체가 시간이 많이 걸리면 전체 시스템의 성능이 아주 급격하게 나빠지므로 CPU 사용률이 높은 애플리케이션에선 권장되지 않는다.       3-2. nvm ?          NVM(Node Version Manager)은 Node.js의 버전을 관리하기 위한 도구이다. 개발툴들이 다양해 질수록 경우에 따라서 Node.js의 버전을 달리 사용해야 할 필요성이 생기게되었다.       사용목적은 협업 혹은 다양한 프로젝트를 동시에 진행 할 때 다양한 라이브러리 / 프레임워크 / 개발 툴들의 버전 호환 문제를 피할수있는 가장 편리한 방법중 하나이기 때문이다. 또한 nvm을 통하면 다양한 버전의 Node.js를 설치를 간편하게 할 수 있으며, use 커맨드를 이용하여 필요한 Node.js의 버전으로 스위칭 할수 있게된다. 디폴트 버전 설정, 설치한 버전들의 리스트 확인, 필요 없는 버전 삭제 등 소위 버전 관리가 매우 간편해 진다.       3-3. npm ?     하나의 프로그램은 다양한 모듈이 합쳐져서 만들어진다. 이때 개발자는 이 모듈을 모두 개발할 이유가 없다. 이미 만들어진 검증된 코드(모듈)을 잘 가져와서 효율적인 방법으로 쓰게끔 도와주는게 npm(Node Package Manager)이다.   3-4. package.json     프로젝트 전반에 관한 정보를 정의하고 의존하는 패키지 버전 정보를 명시해주는 파일이다.   package.json 파일과 함께 프로젝트 배포시 이점은 상당하다. 해당 프로젝트가 포함하고 있는 모든 모듈을 모두 전달하지 않아도, package.json 에 필요 모듈이 모두 명시되어 있기 때문에 사용자가 배포자가 모든 모듈을 배포하지 않아도 필요한 모듈은 npm을 통하여 직접 다운받아서 쓰면 되기때문이다.   4. ~ 코딩애플 React 기초 3강         오늘 느낀 점          아직 CLI환경에서의 작업은 익숙하지 않다. 진짜 컴퓨터와 대화하는 느낌이랄까…GUI가 확실히 편리하지만, 개발자는 컴퓨터와 가까운 직업이라 생각하므로 필히 학습하고 넘어가자.            Node.js 에서 npm 을 통하여 사용하는 패키지들은 프로젝트의 배포와 설치의 유연함이 강력했다. package.json 에 명시된 정보만으로 빠르게 프로젝트에 필요한 모듈들을 파악할 수 있었으며, npm install 명령어 한줄로 필요한 모듈들의 모음인 패키지를 받을수 있었다.            React 에서의 변수는 일반적인 변수 선언보다는 state를 쓰는게 웹앱 사이트 제작에 도움이 된다. 갓 state             내일 할 일     생활코딩 리액트 강의는 구 버전임을 깨닫고 유튜브 채널 중 코딩애플 님 클론 코딩을 우선 따라하기 방식으로 학습하기로 결정.            4강 수업전, 블로그 글 리스트 UI 3개 완성하기 (제목 내용은 state 이용)           React 와 DOM 은 필히 선행학습이 수반되어야 할듯하다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.28.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. Git",
        "excerpt":"    Today I Learnd  1. Git     Git이란 분산형 버전 관리 시스템(Version Control System) 의 한 종류이며, 빠른 수행 속도에 중점을 둔다.            “버전 관리 시스템” 이란 파일 변화를 시간에 따라 기록했다가 이후에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다. 동일한 정보에 대한 여러 버전을 관리하게 되며, 버전을 통해 시간적으로 변경 사항과 변경 사항을 작성한 작업자를 추적할 수 있다.           1-1. GitHub     Git을 통하여 버전관리를 한다 이미 언급을하였다. 그렇다면 Github는 무엇일까? Github는 Git Repository를 관리할 수 있는 클라우드 기반 서비스이다. 즉 Git으로 버전을 관리하는 폴더에 대해서 Github을 통해 여러 사람들이 공유하고 접근할 수 있게되기때문에 Git이 분산형 버전 관리 시스템으로 불리울 수 있게된다.   1-2. Git Repository     내가 작업하는 소스 코드 폴더가 버전 관리를 받게 하기 위해서는 내 폴더를 Git의 관리 아래에 두어야 한다. 이때 Git으로 관리되는 폴더를 Git repository 라고 부른다. Git repository 는 Remote Repository와 Local Repository 두 종류의 저장소를 제공한다.            Remote Repository : 원격 온라인 서버 상의 저장소이다. 여러 사람이 함께 공유가 가능하다.       Local Repository : 내 컴퓨터의 저장소이다. 개인 전용 저장소이며 내 컴퓨터 안의 저장소이기 때문에 오프라인 작업또한 가능하다.                  1-3. Git을 통한 작업시 WorkFlow        Remote에 있는 다른 Repository에서 Fork를 해서 Remote에 있는 내 Repository에 가지고 온다.   이 코드를 수정하기 위해서는 내 컴퓨터로 가져오는 작업이 또 필요하다. 내 컴퓨터에서 작업을 하기 위해서 git clone을 한다.   이제 내 컴퓨터의 작업 공간 (work space) 에서 작업에 들어간 파일들을 git의 관리 하에 있는 상태로 변경할 수 있다. 이 영역을 staging area라고 말한다. 즉, staging area에 들어오지 않은 파일은 unstaged 혹은 untracked file이라고 말하며, staging area에 있는 파일들은 staged 된 파일이라고 말할 수 있다. git commit 을 하기 위해서 현재 Local Repository에 변경된 파일들이 어떤것인지 확인하려면 git status를 통하여 staging area와 untracked files 목록에 어떤 것들이 있는지 확인할 수 있다.   staging area에 들어온 파일들은 git commit이 가능하다. commit을 하고 나면 내 remote repository에 git push 해서 commit 기록을 remote 에도 남겨줄 수 있다. 남긴 commit들이 잘 기록되어있는지 확인하려면 git log를 통하여 로그들을 터미널 창에서 확인할 수 있다.   git push를 완료한 후 이제 remote의 원래 레파지토리에 pull request를 보내면 Remote Repository로 내가 수정한 코드를 업로드할 수 있다.   2. 코딩애플 React         오늘 느낀 점     깃깃깃깃깃. 말로만 들었지 왜 협업에 유리하며, 분산관리에 유리하며.. 버전관리에 유리하며.. 많은 기업들이 해당 툴을 모두 사용하는지 짧은 시간이지만 크게 와닿았다. 협업 과정 중 commit을 들여다보면 누가..언제..몇분전에.. 무슨작업을..무슨코드를 뻘짓(?)거리 하였는지 적나라하게 나오는걸 보니 정말 투명하고 실시간으로 코드유지가 된다는 느낌을 받았다.         내일 할 일     이번주 마무리. 배열,객체 수업 후 배열은 코플릿 페어 진행이 예정되어있다. 저번주 반복문 코플릿이후 오랫만의 코플릿이기때문에 걱정된다. 배열은 오늘 자기 전 개념정도만 한번 훑고 자야겠다. 아직도 소수 찾는 이중반복문이 머릿속에 그려진다.   리액트 선행학습 위한 코딩애플…유료다. 유튜브 코딩앙마 님의 수업이 유익해보이며 무료로 시청이 가능해보인다. 이번주~다음주 중 리액트 클론 코딩 및 따라하기는 우선 코딩앙마님의 해당 수업으로 진행해볼 예정이다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.29.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 배열 2. 객체",
        "excerpt":"    Today I Learnd  1. 배열     배열은 순서가 있는 값이다. 순서는 인덱스(index)라고 부르며, 1이 아닌 0부터 매긴다.            배열의 값 접근은 인덱스를 이용하여 값에 접근한다.           [] 대괄호를 이용해서 배열을 만드며, 각각의 원소(element)는 쉼표(comma)로 구분해준다.   let myNumber = [ 73, 98, 86, 61, 96]; myNumber[3]; // 61 myNumber[4] = 200; // 배열의 4번째 인덱스의 값을 200으로 변경 myNumber; // [73, 98, 86, 61, 200];      배열의 속성에 접근하거나 메소드를 추가할때는 .(온점)을 이용하여 접근한다.            myNumber.length;  // 4  : 온점(dot)을 이용해서 변수가 가지고 있는 속성(property)에 접근할 수 있다.       myNumber.push(98);  // myNumber 배열 끝에 96이라는 값을 추가한다 : 온점(dot)을 이용해서 관련된 명령(method)도 실행할 수 있다. 명령을 실행할 때는, 함수를 실행하듯 괄호를 열고 닫는 형태로 실행한다.           1-1. 배열의 기초 메소드          Array.isArray : 배열의 기본 type은 “object”이다. 그래서 특정 값이 배열인지 아닌지 typeof()로 판별할 수 없다. Array.isArray()는 배열인지 아닌지 판별할 수 있는 메소드이다. 반환값은 boolean 이다.       let num = 10; let words = ['피', '땀', '눈물']; typeof num;  // \"number\" typeof words;  // \"object\" Array.isArray(num)  // false Array.isArray(words)  // true                push, pop :  배열의 뒤에서 요소를 추가 및 삭제할 수 있다. (mutable)       let words = ['피', '땀', '눈물']; words.push('BTS');  // 4 (기본 리턴 값은 '.length')   words;  // (4) , ['피', '땀', '눈물', 'BTS') , 원본 값이 바뀐다(mutable). words.pop();  // 'BTS' (기본 리턴 값은 삭제된 값이 리턴된다.)   words;  // (3) [\"피\", \"땀\", \"눈물\"]                 shift, unshift : 배열의 앞에서 요소를 추가 및 삭제할 수 있다. (mutable)       2. 객체     객체란 키(key)와 값(value)으로 구성된 프로퍼티(property)의 정렬되지 않은 집합이다.            중괄호를 이용하여 객체를 만드며 그 내부에 키와 값은 쌍으로 구성되며 (key-value paor), 키-값 쌍은 쉼표(comma)로 구분해준다.              2-1. 객체의 사용     객체의 값을 사용하는 방법은 두 가지가 있다.     let user = { firstName : 'JeongHyun', lastName : 'Kim', email : 'kk_ong2233@naver.com', city : 'Seoul' };                Dot notation : 객체명 뒤에 .을 통하여 key값에 접근한다.       user.firstName;  // 'JeongHyun' user.city;  // 'Seoul'                Bracket notation : 객체명 뒤에 [] 대괄호 안 값이 문자열처럼 '' 안에 들어가야한다.       user['firstName'];  // 'JeongHyun' user['city'];  // 'Seoul'                키 값이 동적일 경우에는 브라켓 노테이션을 반드시 사용한다.         let person = {     name : 'Kim',       age : 20   } \t   function getProperty(obj, propertyName){     return obj[propertyName];   } \t   let output = getProperty(person, 'name');  // 'Kim'   let output = getProperty(person, 'age');  // '20'           2-2 객체의 추가/삭제 및 확인          dot/bracket notation을 이용해 값을 추가할 수 있다.         user.age = '20';  // user 객체에 age = '20' 의 키값쌍 추가   user.['city'] = 'Seoul';                delete 키워드를 이용해 삭제가 가능하다.         delete user.age;  // user 객체에 있는 age 키 제거                in 연산자를 이용해 해당하는 키가 있는지 확인할 수 있다.         'age' in user; // false   'city' in user; // true                 오늘 느낀 점     배열은 문자열과 유사하다. 문자열은 원본을 수정하지 않았기에 문자열을 복사해서 가져온뒤 작업을 많이하였다. 하지만 배열에서는 원본을 바꾸는지 여부가 중요하다 (mutable 여부). 무분별한 원본값을 바꾸는 행위는 예상치 못한 버그(?)를 야기시킬수 있기에 잘 생각한 뒤 사용해야 할것같다.         내일 할 일     주말이며 다음주 부터는 8월이다. 이번달 7월간의 회고 기록도 포스팅으로 남겨봐야겠다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.07.30.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 객체 코플릿",
        "excerpt":"    Today I Learnd  1. 객체 코플릿     객체는 배열과 다르게 순서성을 가지지 않으며, 묶음으로 된 데이터에 이름을 붙혀, 의미를 부여할 수 있다. 배열또한 각 값이 하나의 변수로 묶인 데이터이지만, 각 index가 어떤 정보를 갖고 있는지 알아야지 해당 값에 접근이 용이하다.            객체는 키쌍값(key-value pair)으로 이루어져 있다.            객체의 값을 사용하거나 추가할 땐 Dot notation, Bracket notation 방식을 사용한다   할당된 키와 값을 지울 땐 delete 키워드를 이용해 삭제가 가능하다.        객체 안에 특정한 키가 있는지 확인이 필요할 땐, in 연산자를 이용하여 확인한다.            for ... in : 상속된 열거 가능한 속성들을 포함하여 객체에서 문자열로 키가 지정된 모든 열거 가능한 속성에 대해 반복합니다.           for (variable in object) { ... }                 variable : 매번 반복마다 다른 속성이름(Value name)이 변수(variable)로 지정됩니다.       object :  반복작업을 수행할 객체로 열거형 속성을 가지고 있는 객체.              Note: for…in은 인덱스의 순서가 중요한 Array에서 반복을 위해 사용할 수 없습니다.    2. Github 블로그 이사         블로그를 velog에서 git에서 jekyll 환경으로 세팅하는 블로그로 변경해보았다.     https://honbabzone.com/ 해당 블로그를 통해서 minimal-mistakes 테마를 이용하여 세팅을 해보았다. 우선 불필요한 포스팅을 줄이고 오늘 배운 내용 및 시간을 어떻게 보냈는지, 어떤점을 느끼고 발전했는지에 대한 부분만 짚고 넘어갈 예정이다.            오늘 느낀 점      어렵다… git blog .. 8.1 ~ 8.2, 이틀동안 지금 챕터진행 말고 블로그 셋팅 씨름한 덕에 포스트 commit 하고 푸쉬할 수 있게되었다. 물론 지금 테마 및 셋팅이 맘에 드는건 아니지만, 일단 나중으로 미루고 포스팅이 우선인듯하여 우선 급하게 셋팅을 마무리 지었다.   추후 상단 nav에 위치한 메뉴버튼들을 좌측 사이드바로 옮기고 싶다.  스크롤에 반응하는 author_ profile 목록은 그렇게 유용하진 않는듯하다..   사소한거지만.. html 구조파악에 시간이 너무 오래걸렸다. 셋팅 위한 한글 포스팅도 많이 없는 상황이다 (상단에 올려둔 7271kim 님의 블로그 세팅이 거의 대중화(?)되었다고 보면 될 듯하다. 우선은 천천히 코드및 구조를 뜯어보며 변경해보는거로 미뤄둬야겠다.         내일 할 일     CSS 챕터 학습   남은 기존 posts 이동하기 &amp;&amp; 7월 19일 부터 달려온, 보름정도의 기간 self-check 회고 posting 하기 (blog setting 은 현재 상태로 만족하고 학습에 몰두해야겠다.)   DOM 개념 잡기  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.02.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 다양한 CSS 셀렉터 2 . CSS layout 3. HTML/CSS 목업 와이어프레임 실습",
        "excerpt":"    Today I Learnd  1. 다양한 CSS 셀렉터  h1 {  }  // 셀렉터 div {  }    * {  }  // 전체 셀렉터  section, h1 {  }  // 태그 셀렉터  #only {  }  // ID 셀렉터  .center {  }  // class 셀렉터  a[href] { }  // attribute 셀렉터 p[id=\"only\"] { }  header h1 {}  // 후손 셀렉터  header &gt; p { }  // 자식 셀렉터  section + p { }  // 인접 형제 셀렉터  section ~ p { }  // 형제 셀렉터  a:hover { }  // 가상 셀렉터 a:active { }  input:checked + span { }  // 요소 상태 셀렉터 input:enabled + span { }  p:first-child { }  // 구조 가상 클래스 셀렉터 ul &gt; li:last-child { }  input:not([type=\"password\"]) { } // 부정 셀렉터 div:not(:nth-of-type(2)) { }  input[type=\"text\"]:valid { }  // 정합성 확인 셀렉터 input[type=\"text\"]:invalid { }      새로 학습한 셀렉터          attribute 셀렉터  ,  부정 셀렉터         2-1 . CSS layout     &lt;div id=\"container\"&gt;   &lt;div class=\"col w10\"&gt;      &lt;div class=\"icon\"&gt;아이콘 1&lt;/div&gt;     &lt;div class=\"icon\"&gt;아이콘 2&lt;/div&gt;     &lt;div class=\"icon\"&gt;아이콘 3&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"col w20\"&gt;     &lt;div class=\"row h40\"&gt;영역1&lt;/div&gt;     &lt;div class=\"row h40\"&gt;영역2&lt;/div&gt;     &lt;div class=\"row h20\"&gt;영역3&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"col w70\"&gt;     &lt;div class=\"row h80\"&gt;영역4&lt;/div&gt;     &lt;div class=\"row h20\"&gt;영역5&lt;/div&gt;   &lt;/div&gt; &lt;/div&gt;   .w70 { width: 70%; } .h40 { height: 40%; }  * {  // 기본 스타일 제거 (box-sizing)   box-sizing: border-box; }  body {  // 기본 스타일 제거 (여백 제거)   margin: 0;   padding: 0; }     박스의 시작을 정확히 (0,0)의 위치에서 시작하고 싶은데, &lt;body&gt; 태그가 가진 기본 스타일에 약간의 여백을 포함하지 않아 계산에 어려움이 있다. 위에 언급한 문제를 해결할 몇 줄의 코드를 적용시키면, 기본 스타일링을 제거하여 디자인한 대로 레이아웃을 구현할 수 있습니다.   이렇게 클래스 이름과 구현을 1:1로 일치시켜 아주 작은 단위로 CSS를 작성 기법을 Atomic CSS 방법론이라고 한다.     2-2. CSS layout (flexbox)     flexbox로 레이아웃을 구성한다는 것은, 박스를 유연하게 늘리거나 줄여 레이아웃을 잡는 방법이다.   &lt;div id=\"outer\"&gt;   &lt;div class=\"box\"&gt;box1&lt;/div&gt;   &lt;div class=\"box\"&gt;box2&lt;/div&gt;   &lt;div class=\"box\"&gt;box3&lt;/div&gt; &lt;/div&gt;   #outer {   display: flex;   border: 1px dotted red;   padding: 10px; }  .box {   border: 1px solid green;   padding: 10px; }              부모 박스요소에 display: flex를 적용해, 자식 박스의 방향과 크기를 결정한다. 기본값으로, display: flex가 적용된 부모 박스의 자식 요소는 왼쪽부터 차례대로 이어 배치된다.       반드시 알아두기: grow(팽창 지수), shrink(수축 지수), basis(기본 크기)            자식 박스에 어떠한 속성도 주지 않으면, flex: 0 1 auto; 기본값이 적용됩니다.           grow, shrink 속성은 단위가 없고, 비율에 따라 결과가 달라진다. 부모 박스 안에 n개의 자식 박스가 있다고 가정하고 각 자식 박스가 갖는 grow값의 총 합이 n이라면,  grow 속성의 값을 1로 설정하는 것은 1/n 가로 또는 세로길이를 적용한다는 의미이다.    &lt;div id=\"outer\"&gt;   &lt;div class=\"box target\"&gt;.box.target&lt;/div&gt;   &lt;div class=\"box\"&gt;.box&lt;/div&gt;   &lt;div class=\"box\"&gt;.box&lt;/div&gt; &lt;/div&gt;   .target {   flex: 1 1 auto; }        flex-grow  : 1 이다. box.target은 부모 박스의 가로 길이 중에서 남은 빈 영역만큼 늘어나게 된다. 위 설명대로라면 전체 자식요소가 가진 grow 값의 합은 1+0+0 = 1이므로, box.target의 가로 크기는 1/1 = 100% 이다. 그러나 다른 자식 박스 안에 이미 콘텐츠가 존재하므로, 다른 자식 박스안의 콘텐츠가 담긴 길이를 제외한 나머지 가로 길이가 box.target의 가로 길이가 된다.   .target {   flex: 1 1 auto; }   .box {   flex: 1 1 auto; }     만약 .box의 flex-grow : 1로 설정하면, 모든 박스가 늘어나려고(grow) 합니다. 결과적으로 모든 박스가 동일한 비율로 가로 길이가 늘어납니다. (총 grow 값 1+1+1, 각 박스는 1/3씩 크기를 가짐)              shrink는 grow와 반대로, 설정한 비율만큼 박스 크기가 작아진다. 그러나 flex-grow 속성과 flex-shrink 속성을 함께 사용시 flex-shrink 속성은 width나 이후 설명할 flex-basis 속성에 따른 비율이므로 실제 크기를 예측하기가 어렵게 된다. flex-grow 속성으로 비율을 변경하는 경우, flex-shrink 속성은 기본값인 1로 두어도 무방하다.            basis는 자식박스가 flex-grow나 flex-shrink에 의해 늘어나거나 줄어들기 전에 가지는 기본 크기이다.       2-3. CSS layout (flexbox 콘텐츠 정렬 방법)     Flexbox를 원하는대로 제어하기 위해서는 axis(축)의 개념에 대한 이해가 필요하다.  axis는 main axis 와 cross axis로 구분된다.            main axis는 flex-direction 속성에 의해서 결정된다. flex-direction의 기본 값인 row 인 상태일 때 main axis 는 가로축(가로축이 default)이 된다.       cross axis는 여러 개의 main axis와 수직을 이루는 방향입니다. main axis가 가로일 때 cross axis는 세로가 됩니다.                  그렇다면 위의 layout을 flexbox 방식으로 CSS를 구성해보자   * {     margin: 0;     padding: 0;     font-size: large;     box-sizing: border-box; }  #container {     display: flex;     margin: 0.4rem;     padding: 0.4rem;     min-height: 100vh; }  .col {     display:flex;     flex-direction: column;     margin: 0.4rem;     padding: 0.4rem;     border: 1px solid red; }  .icon {     margin: 0.4rem;     padding: 0.4rem;     border: 1px dashed orange; }  .row {     margin: 0.4rem;     padding: 0.4rem;     border: 1px dashed purple; }  .w10 {     flex: 1 0 0; }  .w20 {     flex: 2 0 0; }  .w70 {     flex: 7 0 0; }  .h20 {     flex: 2 0 0; }  .h40 {     flex: 4 0 0 ; }  .h80 {     flex: 8 0 0; }   3. HTML/CSS 목업 와이어프레임 실습     실습결과 코드는 GitHub 참조.         오늘 느낀 점          ` CSS 진짜로 개어렵다.` 우선 오늘  실습을 해보며 HTML을 이용하여 프레임을짜고, 그 각각의 프레임을 선택자로 구분하여 CSS를 입혀보았다. 우선 답이 없는 영역이다.  HTML로 해당 구성의 프레임을 짜는거까지는 어렵지않았지만 각 선택자에 들어가는 CSS 요소들을 우선 너무 모른다.. 몰라도 너무 몰라서 검색조차 못하는 단계랄까..?? 나아지겠지.. 우선 틀을 짜고 선택자로 해당 요소를 컨택한다는 점에서 만족하고 나중에 다시 CSS는 꾸준히..손에 익혀봐야겠다. (나중엔 라이브러리 쓰겠지…)            git repository와 내 local directory 를 오늘 동기화(?) 시켜보았다. 수업을 들으며 진행하는 예제가 늘어나면서 잡다한(?) repository 및.. 불필요한 fork 된 repository 가 너무 늘었다.  git repository를 뜯어고쳐서 내 작업공간과 유사하게 셋팅을 해놓았다.              내 작업환경과 유사한 git repository 유지가 필요할 듯 하다. 앞으로 점차 늘어갈 프로젝트 및 실습 데이터들을 관리 유지하는것도 자기관리라 생각해야겠다.             내일 할 일     오늘은 생각보다 HTML/CSS 실습에 쫓기고, gitHub 환경셋팅에 쫓겨서 개별학습은 못하였다. 핑계는..   내일 커리큘럼에는 스코프/클로저 개념학습뿐이다. 어려운 개념이라 생각되지만, 오전~오후 시간 중에는 집중해서 빠르게 습득하고, 저녁에는 부족할거라 예상되는 React/DOM 및 blog 이전글 이사도 모두 마쳐볼 예정이다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.03.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 원시 자료형&참조 자료형 2. 스코프 3. 클로저",
        "excerpt":"    Today I Learnd  1. 원시 자료형과 참조 자료형.    1-1. 원시 자료형.     자바스크립트에서 원시 타입의 데이터(primitive data types; 원시 자료형)는 객체가 아니면서 method를 가지지 않는 6 가지의 타입            string, number,bigint, boolean, undefined, symbol, (null)                 null은 원시 타입과 거의 같게 사용된다고 볼 수 있다. 작동 방식 또한 다른 원시 타입과 같으나, 다만 엄밀하게 따지자면 원시 타입이라고 볼 수 없는 자료형이다.                        원시 자료형은 모두 “하나”의 정보, 즉, 데이터를 담고 있다.  원시 자료형은 값 자체에 대한 변경이 불가능(immutable)하지만, 변수에 다른 데이터를 할당할 수는 있다.       \"hello world!\" \"Hi!\" // \"hello world!\" 와 \"Hi!\"는 모두 변경할 수 없는 고정된 값입니다.  let word = \"hello world!\"  word = \"Hi!\"  // 하지만, word라는 변수에 재할당을 하여 변수에 담긴 내용을 변경은 가능합니다.            1-2. 참조 자료형.          자바스크립트에서 원시 자료형이 아닌 모든 것은 참조 자료형이다. 이런 자료형을 자바스크립트에서는 참조 자료형(reference data type; 참조 타입)이라고도 부른다. 대표적인 참조 자료형으로는 배열([])과 객체({}), 함수(function(){})가 있다.       참조 자료형에는 하나의 데이터가 아닌 여러 데이터가 담기게 된다. 그래서 참조 자료형의 데이터 “값” 자체는 지금까지 배웠던 원시 자료형처럼 1:1로 할당되는 것이 아닌 특별한 데이터 보관함(heap)에 저장됩며, 변수에는 데이터 “값이 위치한곳(메모리 상 주소)”을 가리키는 주소가  저장되게 된다.                     heap은 별도로 관리되며 사이즈 또한 참조 자료형 값에 따라 동적으로 변할수 있다. (고정값은 비효율적인 설계)                                                                  데이터 값               주소                                                               저장위치               heap(동적으로 저장됨)               변수에 할당됨(heap을 가르키는 address)                                                        참조 자료형은 변수에는 주소가 담겨져있기떄문에, 각 변수간에 값을 복사할 경우에 주소가 복사되게 되므로 원본값이 바뀌는 경우가 발생할 수 있다.       let a = [10,20];   let b = a;  // b에 a의 값을 복사한게 아닌, a의 주소가 b에 할당됨. \t \t   b[0]=50;   a; // (2) [50,20] 의 값이 나오게된다.            2. 스코프          예제로 우선 스코프에 대해 알아보자.       let greeting = 'Hello'; function greetSomeone() {   let firstName = 'Josh';   return greeting + ' ' + firstName; } console.log(greetSomeone()); // 'Hello Josh' console.log(firstName); // Reference Error                 greeting 변수는 바깥 스코프에 정의되어 있으므로, 함수 안쪽에서 사용할 수 있다. 반면에, firstName 변수는 함수의 안쪽 스코프에 정의되어 있으므로 함수의 바깥쪽에서는 접근이 불가능하다. 따라서 ReferenceError가 출력된다.                이처럼 변수에 접근할 수 있는 범위가 존재한다. 중괄호(블록) 안쪽에 변수가 선언되었는가, 바깥쪽에 변수가 선언되었는가가 중요한 조건이다. 이 범위를 우리는 스코프라고 부른다.        2-1. 스코프 주요 규칙          첫번째 규칙은, “바깥쪽 스코프에서 선언한 변수는 안쪽 스코프에서 사용 가능한 반면에, 안쪽에서 선언한 변수는 바깥쪽 스코프에서는 사용할 수 없다”라는 점이다.  위의 예제를 통하여 확인해보았다.            두번째 규칙은, “스코프는 중첩이 가능하다”는 것이다, 스코프는 마치 중첩된 울타리와 같다.                     특별히 가장 바깥쪽의 스코프는 전역 스코프(Global Scope)라고 부른다. 그 외의 스코프들은 지역(local) 스코프로 부르며, 전역이 아닌 다른 스코프는 전부 지역 스코프(local scope)이다.                세번째 규칙은, “지역 변수는 전역 변수보다 더 높은 우선순위를 가진다” 이다.        2-2. 스코프의 종류          블록 스코프(block scope) : 중괄호를 기준으로 범위가 구분된다.            함수 스코프(function scope) : function 키워드가 등장하는 함수 선언식 및 함수 표현식은 함수 스코프를 만든다.             화살표 함수는 블록 스코프로 취급된다. 함수 스코프 ( X)            2-3. let, const, var 변수 선언에서 주의할 점     var 키워드로 정의한 변수는 블록 스코프를 무시하고, 함수 스코프만 따른다.            그러나, 모든 블록 스코프를 무시하는 건 아니며, 화살표 함수의 블록 스코프는 무시하지 않는다.                var 키워드로 선언된 전역 변수 및 전역 함수는 window 객체에 속하게 된다.             var myName = 'KJH'; \t     console.log(window.myName);  // KJH                           보통 코드를 작성할 때 블록은 들여쓰기가 적용되고, 그 구분이 시각적으로 분명해서 많은 사람들은 블록 스코프를 기준으로 코드를 작성하고, 생각하기 마련이다. 그러나 var는 이 규칙을 무시하므로, 사용이 권장되지 않는다.                          let       const       var                       유효 스코프 범위       블록 스코프 및 함수 스코프       블록 스코프 및 함수 스코프       함수 스코프                 값 재할당       가능       불가능       가능                 재선언       불가능       불가능       가능               전역 변수는 가장 바깥 스코프에 정의한 변수이다. 따라서, 어디서든 접근이 가능하므로 편리하지만, 다른 함수 혹은 로직에 의해 의도되지 않은 변경이 발생할 수 있다. 이를 부수 효과(side effect) 라 부르며 이를 최소화 하는것이 좋은 프로그래밍 설계 방법이다.                     실수를 방지하기 위해 strict mode를 적용하여 사용할 수 있다 . 브라우저가 보다 엄격하게 작동하도록 만들어주도록 도와준다             'use strict';  // js 파일 상단에 선언, 문법적으로 실수할 수 있는 부분들을 에러로 판단해준다. \t     function showAge() {     age = 90;  // 키워드 없이 변수가 선언되었기 때문에 엄격한 판단에 의해 Error가 발생된다.       console.log(age);   }   showAge();                           유효 범위를 나타내는 스코프는 스코프들간의 유효 범위가 연결리스트 형식으로 관리되는데, 이 스코프간의 상하관계를 스코프 체인 이라 일컫는다.   3. 클로저     MDN에서의 클로저 정의에 따르면, 다음과 같다.      “함수와 함수가 선언된 어휘적(lexical) 환경의 조합을 말한다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.”       “함수를 리턴하는 함수중, 내부 함수의 리턴값이 외부 함수의 변수에 영향을 미친다면 이를 클로저 함수라 일컫는다.”   3-1. 클로저 함수의 특징  // const adder = x =&gt; y =&gt; x + y; \t // 위의 코드와 동일하게 작동하는 코드. const adder = function(x) {   let result = 0; \treturn function(y) {  // 익명의 클로저 함수(내부 함수의 리턴값이 외부 함수의 변수에 영향을 미친다) \t  result = x + y; \t  return result; \t} }  adder(5)(7);  // 12 typeof adder(5)  // 'function', 리턴값이 함수의 형태이다.\t              위 사진과 같이 클로저 함수는 “내부 함수는 외부 함수에 선언된 변수에 접근 가능하다” 라는 특징을 갖는다            일반적인 함수는, 함수 실행이 끝나고 나면 함수 내부의 변수를 사용할 수 없다. 이와 다르게, 클로저는 외부 함수의 실행이 끝나더라도, 외부 함수 내 변수가 메모리 상에 저장되기에 데이터를 보존할 수 있다. (어휘적 환경을 메모리에 저장하기 때문에 가능하다)       const adder = function(x) {     let result = 0;   return funtion(y) {         result = x + y;         return result;   } }  const add5 = adder(5);   add5(7);  // 12 add5(10);  // 15 \t   const add7 = adder(7); // 여러개의 add를 만드는 것이 가능하다. 재활용이 가능한 adder 함수   add7(8);  / 15                  클로저 함수 내부의 선언된 변수들은 외부에서 접근할 수 없으므로 정보의 접근이 제한이 된다. 이를 캡슐화라 한다. 해당 캡슐화를 통해서 불필요한 전역 변수 사용을 줄일수 있게되며, 스코프를 이용해서 값을 보다 안전하게 다룰 수 있는 강점이 생긴다.            위와 같이 재활용 또한 가능하게 된다. (add5, add7 등 adder() 함수를 재활용하여 여러개의 add 변수를 만드는것이 가능하다.) 이와 같이 함수 재사용성을 극대화하여, 함수 하나를 완전히 독립적인 부품 형태로 분리하는 것을 모듈화라고 한다.       3-2. 클로저 함수의 활용 예시  // const tagMaker = tag =&gt; content =&gt; `&lt;${tag}&gt;%{content}&lt;/${tag}&gt;`  // 위의 코드와 동일하게 작동되는 코드. const tagMaker = function(tag) { \treturn function(content){  // 내부 함수값의 리턴값이 외부 함수의 tag를 활용하는 익명의 클로저 함수 \t\treturn `&lt;${tag}&gt;%{content}&lt;/${tag}&gt;`; \t} }  const divMaker = tagMaker('div'); divMaker('hello'); // tagMaker('div')('hello') 와 같은 구조이다.  // 'div'는 위 함수 `tag 매개변수`의 전달인자가 되며, `hello'는 위 함수 `content 매개변수`의 전달인자가 된다.  const anchorMaker = tagMaker('a'); // 모듈화 되어 재사용에 용이하다. anchorMaker('world');   // &lt;div&gt;hello&lt;/div&gt; // &lt;a&gt;world&lt;/a&gt;      클로저 함수는 내부 함수의 리턴값이 외부 함수의 지역변수를 참조하여 값을 바꾸거나 활용 하는 함수이다.  이렇게 사용시 전달인자로 전달된 tag값이나 content의 값이 새로운 할당이나 선언없이 전달인자로만 전달되어도 함수의 기능을 모두 활용하며 재사용에 용이한 구조로 코드를 구성할 수 있다.         오늘 느낀 점          스코프까지는 그럭저럭 쉽게 개념에 대해 학습하고 이해가되었으나 클로저 함수는 난관이다.   우선 어떻게 활용되는지 감이 안잡힌다. 모듈화를 함으로써 얻어지는 편리함등은 머릿속으로는 이해가 가는데,  이걸 기존의 코드에 활용하여 클로저 함수를 정의하며 해당 코드를 재활용하는 영역까진 오늘 모두 이뤄긴 당연히 힘들거라 생각된다.  와이어프레임을 짠 뒤, 중복되는 분야를 모듈화를 통하여 최대한 걷어낼 수 있게끔 처음부터 설계가 진행되야 깔끔한 코딩이 이뤄진다 예상된다.            클로저 함수 복습하니 9~10시… 후..  기존 블로그 포스트  이사 완료하니 자정이다^^…. ㅃ2 velog   그나저나 어제 git repository 정리를 마치니, github 초기화면도 뭔가 바꿔보고 싶다는 생각이 든다… 우선 이런 잡다한거는 나중에 주말에 몰아서 한번 진행해보도록 해야겠다.             내일 할 일          내일 커리큘럼은 이번주 학습한 내용을 pair와 함께 다양한 실습 코딩 test를 pass해야한다. 좋은 기회라 생각되므로 오늘중 다시한번 이번주 학습 내용을 다잡아야겠다.            DOM에 대한 유튜브 강의는 적은듯하다.. 생활코딩님 게시글도 8년전 흠… 드림코딩님은 우선 DOM키워드 글은 없는듯 하고.. 개념에 대한 글들을 우선 정독해보는정도로 마무리하고 React 클론 코딩등은 게시글들이 많으니 그쪽을 먼저 학습하도록 해야겠다.      ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.04.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. Spread&Rest 문법 2. 구조분해 3. JavaScript 핵심문법(스코프, 클로저..) 문제풀이",
        "excerpt":"    Today I Learnd  1. Spread / Reset 문법   1-1. Spread 문법          주로 배열을 풀어서 인자로 전달하거나, 배열을 풀어서 각각의 요소로 넣을 때에 사용한다.       function sum(x,y,z) {   return x+y+z; }    const numbers = [1, 2, 3];    sum(...numbers); // typeof(sum) = 'number'          1-2. Rest 문법            파라미터(함수의 매개변수)를 배열의 형태로 받아서 사용할 수 있습니다. 파라미터 개수가 가변적일 때 유용합니다.       function sum(...theArgs) {   return theArgs.reduce((previous, current) =&gt; {       return previous + current;     }); }    sum(1,2,3);  // 6 sum(1,2,3,4);  // 10           1-3. 배열에서의 Spread 문법          Spread 문법은 배열에서 강력한 힘을 발휘한다.            배열 합치기         let parts = ['shoulders', 'knees'];   let lyrics = ['head', ...parts, 'and', 'toes'];             let arr1 = [0, 1, 2];   let arr2 = [3, 4, 5];   arr1 = [...arr1, ...arr2]; // spread 문법은 기존 배열을 변경하지 않으므로(immutable), arr1의 값을 바꾸려면 새롭게 할당해야 한다.                배열 복사         let arr = [1, 2, 3];   let arr2 = [...arr]; // arr.slice() 와 유사           1-4. 객체에서 사용하기     let obj1 = { foo: 'bar', x: 42 };   let obj2 = { foo: 'baz', y: 13 };      let clonedObj = { ...obj1 };   let mergedObj = { ...obj1, ...obj2 };  // {foo: \"baz\", x: 42, y: 13}      객체의 key의 이름이 중복될 경우 후속 spread 문법을 따르는듯하다.   1-5. 함수에서 나머지 파라미터 받아오기   function myFun(a,b, ...manyMoreArgs) {   console.log(\"a\", a); \tconsole.log(\"b\", b); \tconsole.log(\"manyMoreArgs\", manyMoreArgs); }  myFun(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\");   2. 구조 분해 (Destructing)     구조 분해 할당은 Spread 문법을 이용하여 값을 해체한 후, 개별 값을 변수에 새로 할당하는 과정을 말한다.   2-1. 분해 후 새 변수에 할당          배열         const [a, b, ...rest] = [10, 20, 30, 40, 50]; \t   a; // 10 | typeof(a)=\"number\"   b; // 20   rest; // (3), [30, 40, 50] | Array.isArray(rest)=true                객체         const {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}; \t   a; // 10   b; // 20   rest; // {c: 30, d: 40}                함수         function whois({displayName: displayName, fullName: {firstName: name}}){     console.log(displayName + \" is \" + name);   } \t   let user = {     id: 32,     displayName: \"KJH\",     fullName: {       firstName: \"JeongHyun\",       lastName: \"KIM\"     }   }; \t   whois(user);  // KJH is JeongHyun           3. JavaScript 문제풀이     풀이 코드는 Github 참조  자바스크립트 핵심문법(클로저,스코프..등등) 문제풀이         오늘 느낀 점          JavaScript 문제풀이중 얕은 복사, 깊은 복사 개념이 머릿속에 들어오지않았다. 우선 해당 개념파악을 하려면 조금더 JS에서 필요한 학습내용이 뒤 따랐다. (Iterable, 재귀함수..등) 이 문제를 가지고 씨름하기보다는 check 해두기 위해 따로 포스팅 카테고리를 만들어두었다. 다음주 중으로 다시한번 필요한 선행 내용 학습후 다시 되짚어보겠다.            Github Repository를 깔끔히 정리하기 위해 CodeStates에서 학습한 내용들은 한 폴더에 묶어 관리하고싶어서 정리를 해두었다. Github 구성이 내 local 영역과 일치하게끔 구성을 한줄 알았다..  그런데 fork 한 repository가 컨트롤이 안되는 문제를 겪었다.       우선 큰 문제점은 fork한 저장소는 원본(원래 Repository 주인)과 연결되어 있다. 라는 전제가 깔려있기 때문인듯 한데, 아직 정확한 내용을 찾지 못하여서 난항중이다.. 폴더를 한폴더에 묶어서 관리하려는건 아직 능숙하지 않기때문에 개별 repository로 다시 fork 하여 구성하였으며, local 영역또한 clone 하여 동일한 환경으로 구성해두었다.  정확히 브런치 부분이 문제인지는 모르겠지만, 브런치 부분을 조금 더 학습 후 다시한번 도전해봐야겠다.            fork 해온 저장소는 나의 작업환경과는 다르기에,  fork -&gt; clone -&gt; npm install 을 거쳐야 동일한 환경에서 결과물을 볼수있다. 이미 학습한 내용인데, 막상 오늘도 fork 하여 clone 하여 local영역에서 작업할 때 package.json 을 활용하지 않는 나의 모습을 보았다. 아직 외부 저장소 파일을 가져와서 작업하는 경우가 적어서 그런듯하니 점차 습관하 하는게 중요할 듯 하다.             내일 할 일     내일의 정규일정은 DOM이다.. 많은 선행학습을 하지 못하여 걱정이다. 우선 한주의 마지막 정규 학습일정이기에, 부족한 부분은 주말통해서 보완할 수 있게끔 노력해야겠다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.05.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. DOM 2. 유효성 검사 실습",
        "excerpt":"    Today I Learnd  1. DOM     DOM( Document Object Model) 은 HTML 요소를 Object(JavaScript Object)처럼 조작(Manipulation)할 수 있는 Model이다. 즉, 자바스크립트를 사용할 수 있으면, DOM으로 HTML을 조작할 수 있다.   1-1. HTML에 JavaScript 적용하기     HTML에 JavaScript를 적용하기 위해서는 &lt;script&gt; 태그를 이용한다. 웹 브라우저가 작성된 코드를 해석하는 과정에서 &lt;script&gt; 요소를 만나면, 웹 브라우저는 HTML 해석을 잠시 추고 &lt;script&gt; 요소를 먼저 실행한다. 즉, &lt;script&gt; 요소는 등장과 함께 실행된다.            &lt;script&gt;요소는 발견즉시 해석되므로 HTML 구문이 모두 해석되기 전 실행될 수도 있다.  정의되지 않은 값이 호출되는 경우 null 이 발생되므로 되도록 HTML 구문이 모두 해석되는 시점인&lt;/body&gt; 앞에 쓰는걸 습관하 하자.           1-2. 부모&amp;자식 엘리먼트 찾기  &lt;html&gt;   &lt;body&gt;     &lt;div id=\"nav\"&gt;       &lt;div class=\"logo\"&gt;&lt;/div&gt;       &lt;div class=\"menu-wrapper\"&gt;         &lt;div class=\"menu\"&gt;&lt;/div&gt;         &lt;div class=\"menu\"&gt;&lt;/div&gt;         &lt;div class=\"menu\"&gt;&lt;/div&gt;         &lt;div class=\"profile-photo\"&gt;&lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;     &lt;div id=\"news-contents\"&gt;       &lt;div class=\"news-content-wrapper\"&gt;         &lt;div class=\"news-picture\"&gt;&lt;/div&gt;         &lt;div class=\"news-title\"&gt;&lt;/div&gt;         &lt;div class=\"news-description\"&gt;&lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;     &lt;div id=\"footer\"&gt;&lt;/div&gt;   &lt;/body&gt; &lt;/html&gt;           위의 HTML 코드를 보고 부모 자식간의 관계를 눈으로 찾는건 그리 어렵지 않은 일이다. 그렇다면 컴퓨터에게 이 사실을 어떻게 전달할까? 자바스크립트에서 DOM은 document 객체에 구현되어 있으므로 브라우저에서 작동되는 자바스크립트 코드에서는, 어디에서나 document 객체를 조회할 수 있다.            DOM 구조를 조회할 때에는 console.dir 이 유용하다.              console.dir 은 console.log 와 달리 DOM을 객체의 모습으로 출력합니다.              객체의 키값쌍 형태로 document.body의 children 키를 확인 가능하다. console.dir(document.body.child)를 이용하여 바로 children 키로 접근 또한 가능하다.            매번 document.body를 통하여 찾아가는 일은 번거로운 일이다. 따로 변수를 선언해서 이 정보를 저장해두는게 편리하다.       let newsContents = document.body.children[1]  // div#news=contents           부모 엘리먼트 또한 변수에 담을수 있다.       let newscontentsParent = newsContents.parentElement;  // body                이렇듯 DOM은 회사의 조직도와 같은 유사한 구조로 구성된다. 이런 자료 구조를 트리구조 라고 하며, 가장 큰 특징은 부모가 자식을 여러개 가질수 있으며, 부모는 하나인 구조가 반복되는 점이다.       2. 유효성 검사 실습.  Github 참조          변수에 querySelector 로 담아온 선택자의 요소를 변경 및 제어하여 동적인 HTML 작성   DOM 구조를 이해하며 javascript로 제어하는 실습. CSS에 시간을 더 할애하였다..         오늘 느낀 점          DOM 을 우선 찍먹정도 하였다. JavaScript &amp; CSS &amp; HTML 이 유기적으로 상호간에 기능/디자인/뼈대 를 담당하여 웹앱(?)을 구성해보았다. 음.. 일단 생각보다 재미있다. 눈으로 보이기때문인가?       아직 부족한 문법(특히 이벤트 핸들러..)은 점차 학습 해나가야겠다.             내일 할 일     주말중 리액트 클론 코딩 완료하기. 이번주 부족했던 클로저, 얕은복사/깊은복사 추가 학습.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.06.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 고차함수",
        "excerpt":"  Today I Learnd  1. 고차함수  1-1. 일급 객체          자바스크립트에는 특별한 대우를 받는 일급 객체가 있다. 대표적인 일급 객체 중 하나가 함수이다.                       변수에 할당(assignment) 할 수 있다.         다른 함수의 인자(argument)로 전달될 수 있다.         다른 함수의 결과로서 리턴될 수 있다.                       함수를 변수에 할당할 수 있기 때문에, 함수를 배열의 요소나 객체의 속성값으로 저장할 수 있다. 이는 함수를 데이터(string, number, boolean, array, object)를 다루듯이 다룰 수 있다는 걸 의미한다.               변수에 할당(assignment) 할 수 있다.              이미 함수를 변수에 저장하는 방법(함수 표현식)은 학습하였다.         /*   * 자바스크립트에서 함수는 일급 객체이기 때문에 변수에 저장할 수 있다.   * 함수 표현식은 할당 전에 사용할 수 없다.   */ \t   const square = function (num) {     return num * num;   };      // square에는 함수가 저장되어 있으므로 (일급 객체), 함수 호출 연산자 '()'를 사용할 수 있다.   output = square(7);   console.log(output); // --&gt; 49                위의 함수 표현식(function expression)은 함수 선언식(function declaration)과 다르게 호이스팅(Hoisting)이 적용되지 않습니다.            함수 선언식의 호이스팅에 지나치게 의존하면, 코드의 유지 보수가 쉽지 않다. 코드 리뷰나 디버깅을 할 때, 코드를 위아래로 왔다 갔다 하게 될 수 있게되기 때문이다.       반면에 함수 표현식은 함수의 할당과 실행의 위치에 따라 결과가 달라지기 때문에, 코드의 위치를 어느 정도 예측할 수 있기때문에 직관적이다. 호이스팅을 제외하면, 함수 선언식과 함수 표현식은 크게 차이가 없지만, 함수 표현식의 경우는 함수가 변수에 저장될 수 있다는 사실을 보다 분명하게 보여 준다.       1-2. 고차 함수란?          고차 함수(higher order function)는 함수를 인자(argument)로 받을 수 있고, 함수의 형태로 리턴할 수 있는 함수이다       위에서 보았듯이 함수는 변수에 담길 수 있으며 함수는, 함수를 담은 변수를 인자로 또한 전달받을 수 있다. 마찬가지로, 함수 내부에서 변수에 함수를 할당할 수 있으며 이 변수를 리턴함으로써 함수는 함수 자체를 리턴할수 있게 된다.       이때 다른 함수(caller)의 인자(argument)로 전달되는 함수를 콜백 함수(callback function) 라고 한다.              다른 함수를 인자로 받는 경우            function double(num) {     return num * 2;   } \t   function doubleNum(func, num){     return func(num);   } \t   /*   * 함수 doubleNum은 다른 함수를 인자로 받는 고차 함수이다.   * 위 함수 func는 함수 doubleNum의 콜백 함수이다.   * 아래와 같은 경우, 함수 double은 함수 doubleNum의 콜백 함수이다.   */    let output = doubleNum(double, 4);   console.log(output); // 8                  함수를 리턴하는 경우            function adder(added) {     return function (num) {         return num + added;       };   } \t   /*   * 함수 dder는 다른 함수를 리턴하는 고차 함수이다.   * adder는 인자 한 개를 입력받아서 함수(익명 함수)를 리턴한다.   * 리턴되는 익명 함수는 인자 한 개를 받아서 added와 더한 값을 리턴한다.   */    let output = adder(5)(3);   console.log(output); // 8 \t   // adder가 리턴하는 함수를 변수에 저장할 수 있습니다.   const add3 = adder(3);   output = add3(2);   console.log(output); // -&gt; 5                  함수를 인자로 받고, 함수를 리턴하는 경우            function double(num) {     return num * 2;   } \t   function doubleAdder(added, func) {     const doubled = func(added);       return function (num) {         return num + doubled;       };   } \t   /*   * 함수 doubleAdder의 인자 func는 함수 doubleAdder의 콜백 함수이다.   * 함수 double은 함수 doubleAdder의 콜백으로 전달되었다.   */ \t   doubleAdder(5, double)(3); \t   // doubleAdder가 리턴하는 함수를 변수에 저장할 수 있습니다. (일급 객체)   const addTwice3 = doubleAdder(3, double);   addTwice3(2); // 8           1-3. 내장 고차함수     filter : 배열의 filter 메소드는, 모든 배열의 요소 중에서 특정 조건을 만족하는 요소를 걸러내는 메소드이다. 예를 들어 number 타입을 요소로 갖는 배열에서 짝수만을 걸러내거나, 18 보다 작은 수만을 걸러낼 수 있다. string 타입을 요소로 갖는 배열에서, 길이가 10 이하인 문자열만 걸러내거나, ‘korea’만 걸러낼 수도 있다.       여기서 걸러내는 기준이 되는 특정 조건은 filter 메소드의 인자로 전달된다. 이때 전달되는 조건은 함수의 형태 이므로, filter 메소드는, 걸러내기 위한 조건을 명시한 함수를 인자 로 받기 때문에 고차함수이다.      map : 맵은 배열의 각 요소가 특정 논리(함수)에 의해 다른 요소로 지정(map) 되는 내장 함수이다.     let arr = [1,2,3];  let result = arr.map(function(ele) {    return ele * 2; });  result; // [2,4,6]      하나의 데이터를 다른 데이터로 맵핑(mapping) 할 때 사용된다.      reduce : 배열의 각 요소를 특정 방법(함수)에 따라 원하는 형태로 응축하는 메소드이다.    function joinName(resultStr, user){   resultStr = resultStr + user.name + ', ';   return resultStr; }  let users = [   { name : 'Tim', age : 40 },   { name : 'Satya', age : 30 },   { name : 'Sundar', age : 50 } ];  users.reduce(joinName, '');   2. 고차함수 코플릿     함수들을 입력받아 함수들이 입력된 차례대로 결합된 새로운 함수를 리턴해야 한다.    function square(num) {   return num * num; }  function add5(num) {   return num + 5; }  function mul3(num) {   return num * 3; }  output = pipe(square, add5, mul3); console.log(output(4)); // --&gt; 63       수도코드      num을 매개변수로 가지는 함수로 return 해야 한다.   전달 받는 인자(함수)는 ...spread 문법을 통하여 배열 형태로 전달받는다.   각 함수에는 같은 최초 전달된 num값이 필요하다.  (But, 내부 함수에서 num을 그대로 return 한다면 num값이 변질될 수 있다)   그러므로 내부 함수에 let 키워드로 변수를 선언하여, 함수 스코프 내에서 num을 할당 후 값을 보존한다.   for문으로 ...spread 문법을 통하여 전달받은 배열 안의 함수 인자들을 해석하여 return 해준다.   function pipe(...funcs) {  // spread로 인자(함수)들을 배열 형태로 전달받는다.   return function(num){ // 함수를 리턴한다.     let innerNum = num;  // 최초 num 값으로 첫 함수계산을 시작한다.     for(let i=0; i&lt;funcs.length; i++){  // 외부함수의 매개변수(함수 인자) 탐색       innerNum = funcs[i](innerNum) // 내부 함수의 계산 결과 값을 innerNum에 쌓아 나아감     }     return innerNum;          /* i 인덱스마다 innerNum 값 변화       * i = 0 =&gt; innerNum = 16       * i = 1 =&gt; innerNum = 21       * i = 2 =&gt; innerNum = 63     */   } }         오늘 느낀 점     고차함수 ㅎㅎ;;;;  개념은 알겠다. 우선 오늘 풀어본 문제들로 감은 잡았다..  그게 전부이다. 활용할 수 있을까? 란 생각이 든다. 어서 내꺼로 만드는 노력을 해야겠다.   아침에 풀다 막힌 코플릿을 저녁에도 풀어보았는데 또 막힌다(?). 다시 한번 포스팅까지 해서 복기를 하였다. 머리로 수도코드 등 바로바로 그려지는 단계까지 가질 않는다. 광복절 연휴까지 있어서 주말이 길기때문에, 주말까지 반복 학습이 필요할 듯 하다.         내일 할 일     React 실습이다.. 하 클론코딩 등 준비를 못했다. 부딫혀봐야겠다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.10.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. React",
        "excerpt":"  Today I Learnd  1. React     프론트앤드 개발을 위한 JavaScript 오픈소스 라이브러리.   1-1. 리액트의 3가지 특징     선언형 (Declarative)            코드를 면밀히 뜯어보지 않아도, 코드를 유추할 수 있게 된다.                한 페이지를 보여주기 위해 HTML, CSS, JS로 나눠서 적기보다는, 하나의 파일에 명시적으로 작성할 수 있게 JSX 를 활용한 선언형 프로그래밍을 지향한다.                              컴포넌트 기반 (Component-Based)            컴포넌트(Component) 란 독립적인 단위모듈이다.                리액트는 하나의 기능 구현을 위해 여러 종류의 코드를 묶어둔 컴포넌트를 기반으로 개발한다. 컴포넌트로 분리하면 서로 독립적이고 재사용에 용이하기 때문에, 기능 자체에 집중하여 개발이 가능하게 된다.                              범용성            리액트는 JavaScript 프로젝트 어디든 유연하게 적용될 수 있다.       Facebook 에서 관리되어 안정적이고, 가장 유명하며 리액트의 형제격인 리액트 네이티브 로 모바일 플랫폼까지 지원 가능하다.           1-2. JSX          JSX는 JS와는 유사하며 JS를 확장한 문법이지만, 브라우저가 바로 실행할 수 있는 JavaScript 코드는 아니다. “Babel” 을 이용하여 JSX를 브라우저가 이해할 수 있는 JS로 컴파일하게 되며, 컴파일 된 JS를 통하여 브라우저가 읽고 화면에 렌더링 할 수 있다.       React 에서는 DOM 과 다르게 CSS, jsx 문법만 가지고 웹 애플리케이션을 개발할 수 있게된다. 즉, 컴포넌트 하나를 구현하기 위해서 필요한 파일이 줄어들었고, 한눈에 컴포넌트를 확인하기에 더욱 용이하다.              2. React 기본 문법 실습 : Github 참조            오늘 느낀 점     우선 컴포넌트로 구성된 모듈이 모여져서 만들어진 React 의 기본 문법만 학습하였다. 아직 state, props 의 개념까지 확장이 안되어서 웹사이트라 말하긴 아쉽다. 조금 더 다듬어서 이번주 내로는 리액트에 대한 학습내용을 채워갈 예정이다.         내일 할 일     ~08.17 까진 리액트, 돔, 고차함수 집중  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.11.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. React SPA 2. React Router",
        "excerpt":"  Today I Learnd  1. React SPA (Single Page Application)          과거의 브라우저는 웹사이트 페이지 전체를 로딩하였기 때문에 발생하는 리소스 손실이 컸다 . 하지만 SPA는 페이지 전환 전후에 중복되는 부분은 새로 불러오지 않으며 필요한 부분만 갱신하여 웹페이지를 새로 로딩한다.       SPA 란 즉, 서버로부터 완전한 새로운 페이지를 불러오지 않고 페이지 갱신에 필요한 데이터만 받아 그 정보를 기준으로 현재의 페이지를 업데이트함으로써 사용자와 소통하는 웹 어플리케이션이나 웹 사이트를 일컫는다              1-1. SPA 의 장단점  1. 장점     전체 페이지가 아닌 필요한 부분의 데이터만 받아서 화면을 업데이트 하면 되기 때문에 사용자와의 Interaction에 빠르게 반응한다.   서버에서는 요청 받은 데이터만 넘겨주면 되기 때문에 과부화가 적다.   전체 페이지를 렌더링 할 필요가 없기 때문에 더 나은 유저경험을 제공한다.   대표적인 서비스로는 Youtube, facebook, airbnb, Netflix 등이 있다.   2. 단점     SPA 경우 JavaScript 파일의 크기가 크다(HTML 파일은 거의 비어있고 대부분의 코드는 JavaScript 내부에서 작동한다.), 때문에 첫 화면 로딩 시간이 길어질수 밖에 없다.   검색 엔진 최적화(SEO)가 좋지 않다. 구글이나 네이버 같은 검색 엔진들은 HTML 파일에 있는 자료를 분석하는 방식으로 검색 기능이 구동된다. 하지만 SPA 같은 경우 앞서 말했듯이 HTML 파일은 별다른 자료가 없기 때문에 검색 엔진이 적절히 동작하지 못한다.   1-2. React SPA 실습.  참조 : Github    2. React Router          SPA는 하나의 페이지를 가지고 있지만, 한 종류의 화면만 사용하지는 않는다.              위 사진과 같이 하나의 페이지 이지만 화면전환은 계속 이루어진다. 또한 이 화면에 따라 주소 도 달라지게된다.  이렇게 다른 주소에 따라 다른 뷰를 보여주는 과장을 “경로에 따라 변경한다” 라는 의미로 라우팅(Routing)  이라고 한다. React 자체에는 이 기능이 내장되어 있지 않기떄문에 외부 라이브러리를 이용한다.       2. React Router.     React Router의 주요 컴포넌트는 크게 3가지 이다.            router : &lt;BrowserRouter&gt;       route matchers : &lt;Switch&gt;, &lt;Route&gt; 경로를 매칭해준다.       route changers : &lt;Link&gt; 경로를 변경해준다.                  2-1. React Router 실습.  참조 : Github          오늘 느낀 점     라우터를 이용한 부분 페이지 전환 그로인한 SPA 설계 가능화.   내일 리액트의 꽃인 state, props 학습이다.  내일까지 리액트 주요 문법 학습 후 주말중 리액트는 다시 한번 정리해야겠다.         내일 할 일     ~08.17 까진 리액트, 돔, 고차함수 집중  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.12.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. React Props & State",
        "excerpt":"  Today I Learnd  1. React Props &amp; State  1-1. Props vs State     간단하게 언급하고 가자면, props는 외부로 부터 전달받은 값이며, state는 컴포넌트 내부에서 변화하는 값이다.   1-2. Props          컴포넌트의 속성(property)을 뜻한다. props는 변하지 않는 외부로부터 전달받은 값으로, 웹 어플리케이션에서 해당 컴포넌트가 가진 속성에 해당된다.            이 해당 컴포넌트의 속성은 부모 컴포넌트(상위 컴포넌트)로부터 전달받은 값이다.       React 컴포넌트는 JavaScript 함수와 클래스로, props를 함수의 전달인자(arguments)처럼 전달받아 이를 기반으로 화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환한다. 따라서, 컴포넌트가 최초 렌더링될 때에 화면에 출력하고자 하는 데이터를 담은 초기값으로 사용할 수 있다.            props의 자료형은 객체 형태이다. props로 어떤 타입의 값도 넣어 전달할 수 있도록 props는 객체의 형태를 가진다.       또한, props는 외부로부터 전달받아 변하지 않는 값입니다. 그래서 props는 함부로 변경될 수 없는 읽기 전용(read-only) 객체이다. 함부로 변경되지 않아야 하기 때문이다.              읽기 전용 객체가 아니라면 props를 전달받은 하위 컴포넌트 내에서 props 를 직접 수정 시 props를 전달한 상위 컴포넌트의 값에 영향을 미칠 수 있게 된다. 즉, 개발자가 의도하지 않은 side effect 가 생기게 되고 이는 React의 단방향, 하향식 데이터 흐름 원칙(React is all about one-way data flow down the component hierarchy) 에 위배된다.                 props를 사용하는 방법은 아래와 같이 3단계로 구분할 수 있다.              하위 컴포넌트에 전달하고자 하는 값(data)과 속성을 정의한다.       props를 이용하여 정의된 값과 속성을 전달한다.       전달받은 props를 렌더링한다.           function Parent() { {/* 부모 컴퍼넌트 */}   return (     &lt;div className=\"parent\"&gt;       &lt;h1&gt;I'm the parent&lt;/h1&gt;       &lt;Child text={\"I'm the child\"} /&gt;        {/* 1-1. text라는 속성을 선언하고, 이 속성에 문자열 값을 할당하여 Child 하위 컴포넌트에 전달 */}       &lt;Child&gt;I'm the child&lt;/Child&gt;        {/* 1-2. 태그사이에 value 를 넣어 전달할 수도 있다. */}     &lt;/div&gt;   ); }  function Child(props)    {/* 2. 함수에 인자를 전달하듯 props를 자식 컴퍼넌트에게 전달 */}   return (     &lt;div className=\"child\"&gt;       &lt;p&gt;{props.text}&lt;/p&gt;       {/* 3-1. 전달 받은 props를 렌더링. (props는 객체므로 key값 \"text\"를 닷노테이션(dot notation) 방식으로 접근하여 렌더링해준다.) */}       &lt;p&gt;{props.childeren}&lt;/p&gt;       {/* 3-2. 전달 받은 props를 렌더링. (props.children을 이용하면 해당 value에 접근하여 사용할 수 있다.) */}     &lt;/div&gt;   ); }           1-3. State          컴포넌트 내부에서 변할 수 있는 값, 즉 상태는 React State로 다뤄야 한다.            React에서는 state 를 다루는 방법 중 하나로 React에서 제공하는 useState 라는 특별한 함수를 불러와서 사용해야 한다.       import { useState } from \"react\";                체크박스로 컴포넌트 내부에서 상태의 변화를 담아보자.       import React, { useState } from \"react\"; {/* import useState */}  function CheckboxExample() {   const [isChecked, setIsChecked] = useState(false); {/* 새로운 state 변수(isChecked)를 선언 */}   {/* 문법적으로 보면 useState의 리턴값(배열)을 구조 분해 할당한 [isChecked, setIsChecked] 변수 */}    const handleChecked = (event) =&gt; {     setIsChecked(event.target.checked);   };   {/* 핸들러 함수 */}    return (     &lt;div className=\"App\"&gt;       &lt;input type=\"checkbox\" checked={isChecked} onChange={handleChecked} /&gt;         &lt;span&gt;{isChecked ? \"Checked!!\" : \"Unchecked\"}&lt;/span&gt;         {/* isChecked 가 boolean 값을 반환하는 함수기 때문에 삼항연산자를 사용하여 true/false 값을 매칭해준다 */}     &lt;/div&gt;   ); }  export default CheckboxExample;                           위 코드중 useState 함수는 호출시 리턴값은 배열이다. 반환되는 배열의 요소를 살펴보자면, 배열의 0번째 요소는 현재 state 변수이고, 1번째 요소는 이 변수를 갱신할 수 있는 함수이다.             const [state 저장 변수, state 갱신 함수] = useState(상태 초기 값);                                위 코드의 예시대로 React 컴포넌트는 state가 변경되면 새롭게 호출되고, 리렌더링 된다.       이때 React state는 상태 변경 함수(위 예시는 useState함수) 호출로 변경해야 한다. 강제로 변경을 시도하면 , 리렌더링이 되지 않는다거나, state가 제대로 변경되지 않는 side effect 가 발생할 수 있다.       2. React 데이터 흐름          React의 개발 방식의 가장 큰 특징은 페이지 단위가 아닌, 컴포넌트 단위로 시작한다는 점이 가장 큰 특징이다.            데이터의 흐름을 파악할 때에는 부모 컴포넌트에서 props를 이용하여 데이터를 함수의 인자(arguments) 혹은 속성(attributes)처럼 전달 받는 구조로 설계해야한다. 전달하는 주체는 부모이기 때문에 데이터 흐름 방식은 하향식 (top-down)임을 의미한다.       이러한 단방향 데이터 흐름 (One-way data flow) 이라는 키워드가 React를 대표하는 설명 중 하나일 정도이다.            React 에서 데이터를 다룰 때는 컴포넌트들간의 상호 관계와 데이터의 역할, 데이터의 흐름을 고려하여 위치를 설정해야 한다.       3. React Props &amp; States 실습. 참조 : Github         오늘 느낀 점     React props 전달시 부모에서 자식으로 객체로 전달됨.. 조금더 다양한 실습을 해봐야 할듯하다.         내일 할 일          ~08.17 까진 리액트, 돔, 고차함수 집중            HA 이후 포스팅 예정, 부족한 학습에 집중      ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.13.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 클래스를 이용한 모듈화 2. Prototype",
        "excerpt":"  Today I Learnd  1. 클래스를 이용한 모듈화   1-1. 객체 돌아보기     객체는 자바스크립트의 8가지 자료형중 하나이다, 객체는 원시형(primitive) 자료형과 달리 다양한 데이터를 담을 수 있다. {} 중괄호를 이용하여 객체는 선언되며, 중괄호 안에는 '키(key): 값(value)' 쌍으로 구성된 프로퍼티(property)들이 속해있다.   1-2. 메서드와 this           객체 프로퍼티는 함수를 할당하여 객체에게 행동할 수 있는 능력을 부여해 줄수도 있다.         let user = {     name: \"John\",     age: 30,      sayHi: function() {        console.log(\"안녕하세요!\");     }   }; \t   user.sayHi();  // \"안녕하세요!\"           이처럼 객체 프로퍼티에 할당된 함수를 메서드(method)라고 부른다. 위 예시에선 객체 user에 할당된 메서드는 sayHi이다.              객체를 사용하여 개체를 표한하는 방식을  객체 지향 프로그래밍(object-oriented programming, OOP) 이라 부른다.                 대부분의 메서드는 객체에 저장된 정보에 접근할 수 있어야 제 역할을 하게된다. 메서드 내부에서 this 키워드를 사용하면 메서드를 호출할 때 사용된 객체에 접근할 수 있게된다.         let user = {     name: \"John\",     age: 30,      sayHi: function() {        console.log(console.log(\"안녕하세요! \" + this.age + \"살 \" + this.name + \" 입니다.\");     }   }; \t   user.sayHi();  // \"안녕하세요! 30살 John 입니다.\"           위 처럼 this키워드를 통해 객체의 값에 접근할 수 있으며, 메서드를 보다 유효하게 사용할 수 있게된다.            this의 값은 런타임에 결정된다. 함수를 선언할 때 this를 사용할 수 있지만, 함수가 호출되기 전까지 this (undefined) 엔 값이 할당되지 않는다.              메소드 호출 방식을 이용할 때에는 화살표 함수를 쓰지 않는다.  화살표 함수는 단순히 표현식을 짧게쓸수 있는 함수의 문법적 구조가 아닌 여러 특성을 갖는다.         그중 대표적인 특성중 하나는 “화살표 함수는 일반 함수와 달리 고유한 this를 가지지 않는다.”         그러므로 외부 함수에서 this값을 가져오게 되므로 외부 컨텍스트를 참조하게 되므로 얘기치 않는 상황이 발생될 가능성이 크다.            1-3. 클래스와 인스턴스          위에 잠깐 언급하였던 객체 지향 프로그래밍이란 하나의 모델이 되는 객체를 만들고 그 객체를 이용하여 바탕이 같은 객체를 만드는 프로그래밍 패턴이다.       자동차 생산으로 비유하자면 설계도(클래스)가 있고 해당 설계도로 찍어낸 자동차(인스턴스)들이 있다.            클래스 는 함수로 정의 할 수 있다.       // ES5 문법 function Car(brand, name, color) {   // 인스턴스가 만들어 질 때 실행되는 코드   this.brand = brand;   this.name = name;   this.color = color; }   // ES6 문법 class Car {   // 인스턴스가 만들어 질 때 실행되는 코드   constructor(brand, name, color){     this.brand = brand;     this.name = name;     this.color = color;   } }            여기서 보이는 함수는, 인스턴트를 만들때 실행되는 코드이며 객체지향 프로그래밍에서 생성자(constructor) 라고 부른다.  (참고로 생성자 함수는 return 값을 만들지 않으며 대문자로 시작하며 일반명사로 만들게 된다.)            인스턴스 를 만들 때에는 new 키워드를 사용하게 된다.  즉시 생성자 함수가 실행되며 클래스의 설계를 꼭 닮은 새로운 객체, 즉 인스턴스가 할당된다.         let avante = new Car('huyndai', 'avante', 'black');   let mini = new Car('bmw', 'mini', 'yellow');   let k3 = new Car('kia', 'k3', 'white');                클래스 내부의 속성값들은 위와 같이 정의하며 클래스 내부에 메소드를 정의할 때에는 prototype이라는 키워드를 사용해야 정의할 수 있다.       // ES5 문법 function Car(brand, name, color) { /* 속성정의 생략 */ } Car.prototype.refuel = function() {   // 연료 공급을 구현하는 코드 } Car.prototype.drive = function() {   // 운전을 구현하는 코드 }  // ES6 문법 class Car {   constructor(brand, name, color){ /* 생략 */ }   refuel() {}   drive() {} }            ES5 문법에서는 prototype 키워드를 사용해야 메소드를 정의할 수 있다. ES6에서는 생성자 함수와 함께 class키워드 안쪽에 묶어서 정의한다.       정리하자면,                     실제 코드를 보며 구문을 이해하자.  참조 : 코드스테이츠               2. Prototype  2-1. 객체 지향 프로그래밍          좋은 설계를 위해서는 기본적으로 이 객체 지향을 이해하고 응용하는 것이 매우 중요하다.              캡슐화 (Encapsulation)                    “데이터와 기능을 하나의 단위로 묶는 것”  데이터(속성)과 기능(메소드)를 따로 정의하는 것이 아닌, 하나의 객체 안에 넣어서 묶는 걸 뜻한다.           “은닉(hiding)” 은닉화는 내부 데이터나 내부 구현이 외부로 노출되지 않도록 만드는 것이다.           “느슨한 결합(Loose Coupling)에 유리” 데이터(속성)과 기능(메소드)들이 느슨하게 결합이 되는 것이다. 여기서 느슨한 결합이란 코드 실행 순서에 따라 절차적으로 코드를 작성하는게 아니라, 코드가 상징하는 실제 모습과 닮게 코드를 모아 결합하는것을 의미한다.                       상속 (Inheritance)                    부모 클래스의 특징을 자식 클래스가 물려받는 걸 뜻한다.                       추상화 (Abstraction)                    내부 구현은 아주 복잡하지만, 실제로 노출되는 부분은 단순하게 만든다는 개념이다.  캡슐화와 비교하여 헷갈리는 개념중 하나지만, 단순하게 생각한다면 캡슐화는 코드와 데이터의 “은닉”에 포커스가 맞춰졌다면 추상화는 해당 클래스를 사용하는 사람이 필요하지 않은 메소드 등을 노출시키지않게끔 설계하며 단순한 이름으로 정의하는 것에 포커스가 맞춰져있다.  클래스 정의 시, 메소드와 속성만 정의한 것을 인터페이스라 일컫는다.                       다형성 (Polymorphism)                    같은 메소드라 하더라도 각각마다 다른 방식으로 구현될 수 있다는 개념이다.                           2-2.  클래스와 프로토타입          클래스와 인스턴스 간의 관계는 상속관계가 제일 중요한듯하다,  객체간 상속하기 위해서 JS에서는 프로토타입이라는 방식을 사용한다.                       프로토타입의 객체간 메소드와 속성을 주고받는건  프로토타입 체인(prototype chain)에서 이뤄진다. 이때 상속받는 값들은 프로토타입 체인을 타고 올라가며 접근 할 뿐이지 속성과 메소드가 다른 객체로 이동이나, 복사되는 것이 아님임을 주의해야한다.           프로토타입의 자세한 내용은 아래의 참고문서에서 확인.                          객체 상속에 관련된 이론 및 실습 참조 문서 (MDN Object prototypes)            2-3. 프로토타입 체인          위에서 언급한 내용이지만 다시 말하자면, 객체간 메소드와 속성을 주고받는 “상속”을 JS에서 구현하자면 프로토타입 체인을 사용하여야한다.              JS에서는 extends와 super 키워드를 이용해서 상속을 구현 하고 있다.           프로토타입 체인을 JS에서 구현하기 위한 자세한 내용은 아래의 참고문서에서 확인.              클래스 문법 참조 문서(ECMAScript 2015 클래스)                  오늘 느낀 점          JS에서 객체지향 프로그래밍의 주요 문법등을 학습하였다. 매번 말로만 자바스크립트는…객체 지향프로그래밍이며.. 시도때도 없이 보고 들었는데 처음으로 피부로 와닿으니 굉장히 프로그래머에게 편향된 프로그래밍 방식이란 느낌이 많이 들었다. 이래서 개발언어로써 많이 쓰이는구나라는걸 조금이나마 느꼈다할까나?            아직 잘은 모르겠지만, 기존에 있는 기능을 가져와 확장하는 경우라던지, 실무 개발단계에서 필수적인 개념이라 생각이 든다.             내일 할 일     [자료구조/알고리즘] 기초 - 자료구조  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.23.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 자료구조 2. 자료구조의 종류",
        "excerpt":"  Today I Learnd  1. 자료구조란?     자료구조란 여러 데이터들의 묶음을 저장하고, 사용하는 방법을 정의한 것.  데이터에 편리하게 접근하고 변경하기 위해 데이터를 저장하거나 조직을 효율적으로 해야한다. 그러한 행위로 분류된 데이터를 자료구조라 한다. ( + 알고리즘은 그 저장된 데이터를 처리하는 과정이다.)   2. 자료구조의 종류  2-1. Stack     스택(Stack)은 쌓다, 쌓이다, 포개지다란 뜻을 내포한다. 직역 그대로 데이터(data)를 순차적으로 쌓는 구조이다.   순차적으로 쌓다보니, 가장 먼저 들어간 자료는 가장 나중에 나올 수 있다. 입력과 출력이 하나의 방향으로 이루어지는 제한적 접근에 있다.        이러한 자료구조의 정책을 LIFO(Last In First Out) 혹은 FILO(First In Last Out) 이라 일컫는다              위 사진 처럼 push(), pop()을 쓰는 배열이 대표적인 Stack 자료구조이다.       대표적으로 활용되는 예시는 브라우저의 뒤로 가기, 앞으로 가기 기능 &amp; 엑셀 등 문서작업에서 되돌리기 등의 기능을 구현 할 때 자료구조 Stack의 활용이 필요하다.   2-2. Queue          큐(Queue)는 줄을 서서 기다리다, 대기 행렬 이라는 뜻을 내포한다. Stack과는 반대되는 개념으로, 먼저 들어간 데이터가 먼저 처리되는 FIFO(First In First Out) 혹은 LILO(Last In Last Out) 을 특징으로 가지고 있는다.              위 사진 처럼 자료구조 Queue는 데이터가 입력된 순서대로 처리할 때 주로 사용한다.            대표적으로 활용되는 예시는 프린터가 출력되는 인쇄작업 Queue에 사용된다. 자료구조 Queue를 활용함으로써 프린터는 인쇄작업 Queue에 들어온 문서를 순서대로 인쇄할수있다.       혹은 컴퓨터 장치들 사이에서 데이터를 주고 받을 때, 각 장치 사이에 존재하는 속도의 차이나 시간 차이를 극복하기 위해 임시 기억 장치의 자료구조로 Queue를 사용한다. 이를 버퍼(buffer) 라 일컫는다.       2-3. Graph     그래프는 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조이다. 직접적인 관계가 있는 경우 두 점 사이를 이어주는 선이 있겠으며, 간접적인 관계라면 몇 개의 점과 선에 걸쳐 이어진다.        그래프에서 하나의 점을 정점(vertex)이라고 표현하고, 하나의 선은 간선(edge) 이라고 한다.              정점과 정점사이에 간선이 존재하는데, 이 간선은 정점 사이의 관계를 나타낸다. 정점 사이에 직접적, 간적적으로 간선이 없는 경우를 그래프에선 “관계가 없다” 라고 표현한다.            일상생활에선 매일같이 자료구조 그래프를 사용하고 있다. 포털 사이트의 검색 엔진, SNS,  네비게이션(길찾기) 등 에서 사용되는 자료구조이다.       간단한 예를 들자면,             서울에 사는 A는 부산에 사는 B와 오랜 친구 사이입니다. 이번 주말에 부산에서 열리는 B의 결혼식에 참석하기 위해 A는 차를 몰고 부산으로 가려고 합니다. 대전에 살고 있는 친구 C도 B의 결혼식에 참석을 한다고 하여, A는 서울에서 출발하여 대전에서 C를 태워 부산으로 이동을 하려고 합니다.            위 예시에서는 3개의 정점이 존재한다(A,B,C). 각각 서울,부산,대전을 그래프의 정점으로 삼는다면, 이 3개의 정점은 서로 이어지는 간선(관계)를 가지고 있다.              정점 : 서울(A), 대전(B), 부산(C)         간선 : 서울-대전, 대전-부산, 부산-서울            이를 간단한 JS 객체를 이용하여 비유한다면 아래와 같다.       const isConnected = {   seoul : {     busan : true,     daejeon : true   }   daejeon : {     seoul : true,     busan : true   }   busan : {     seoul : true,     daejeon : true   } }  console.log(isConnected.seoul.busan) // true          현재는 특정 도시가 이어져 있다는 무향그래프라는 노드3개와 간선 3개라는 사실만 알려줄 뿐, 그 외의 정보를 포함하고 있진 않다. 이러한 그래프를 비가중치 그래프라 한다.       그래프를 학습하기에있어, 알아둬야 할 용어들이 있다. 간단하게 살펴보면,            무(방)향그래프(underected graph) : 네비게이션(길찾기)에서 보이는 그래프들은 무향 그래프이다. 서울에서 부산을 갈 수 있듯, 반대로 부산에서 서울로 올 수도 있다. 반대 개념인 단방향 그래프(directed graph) 로 구현 된다면,  한쪽 방향으로만 가능할 것이다. 예를 들면 도로의 일방통행은 단방향 그래프로 길찾기를 구현 할 수 있다.       진입차수(in-degree) / 진출차수(out-degree): 한 정점에 진입(들어오는 간선)하고 진출(나가는 간선)하는 간선이 몇 개인지 나타내는 용어이다.       인접(adjacency): 두 정점간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점이다.       자기 루프(self loop): 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 자기 루프를 가졌다 라고 표현하며, 다른 정점을 거치지 않는다는 것이 특징이다.       사이클(cycle): 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 사이클이 있다고 표현한다.                인접은 위에서 말했듯이 직접 이어져 있는 정점의 관계를 나타낸다. 표현 방식을 수식화 할 땐 아래와 같은 방법으로 표현한다.              인접 행렬 (adjacency matrix) : 그래프에서 정점(vertext)들이 어떻게 연결되었는지 나타내는 행렬이다.                    2차원 배열로 작성하게 되며, 정점들 사이에 간선이 존재하는지 여부를 나타내거나, 가중치가 있는 그래프인 경우에는 정점관의 관계에서 의미 있는 값을 저장한다.                         참조 : http://stoimen.com                인접 리스트 (adjacency list) : 각 정점이 어떤 정점과 인접한지를 리스트의 형태로 표현한다. 각 정점마다 하나의 리스트를 가지고 있으며, 이 리스트는 자신과 인접한 다른 정점을 담는다.                                 인접 행렬은 연결 가능한 모든 경우의 수를 저장하기 때문에 상대적으로 메모리를 많이 차지하므로 메모리의 효율성을 위한 작업이 필요할땐 인접리스트가 효율적이다.                                                      2-4. Tree          자료구조 Tree는 이름 그대로 나무의 형태를 가지고 있다. 엄밀히 말하면 그래프의 여러 구조중 무방향 그래프의 한 구조라 말할수있다.       또한, 데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 뒤에 여러 개의 데이터가 존재할 수 있는 비선형 구조이다. 그리고 루트 노드를 기준으로 아래로만 층층이 뻗어나가기 때문에  계층적으로 표현이 되며 그래프와 달리 사이클은 존재하지 않는다.            트리를 학습하기에있어, 알아둬야 할 용어들이 있다. 간단하게 살펴보면,             노드(Node) : 트리 구조를 이루는 모든 개별 데이터       루트(Root) : 트리 구조의 시작점이 되는 노드       부모 노드(Parent node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드       자식 노드(Child node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드       리프(Leaf) : 트리 구조의 끝지점이고, 자식 노드가 없는 노드                      트리 구조는 루트(Root) 라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결한다. 각 데이터를 정점이 아닌 노드(Node)라고 하며, 두 개의 노드가 상하계층으로 연결되면 부모/자식 관계를 가지게 된다. 위 그림에서 A는 B,C,D의 부모 노드(Parent Node)이면서 루트(Root)이며, E와 F는 B의 자식 노드(Child Node)이다. 자식이 없는 C,D,E,F 노드는 나무의 잎과 같다고 하여 리프 노드(leaf Node)라고 부른다.       자료구조 Tree는 계층으로 구현되기 때문에 깊이와 높이, 레벨 등을 측정할 수 있다.            깊이(depth) : 트리 구조에서는 루트로부터 하위 계층의 특정 노드까지의 깊이(depth)를 표현할 수 있다. 쉽게 생각하면 루트에서 현재노드 사이까지의 간선의 갯수라 생각하면 간단하다. 위 그림에서 루트 A의 depth는 0이고, B,C,D의 깊이는 1이다. 그리고 E와 F의 깊이는 2가 된다.       레벨(level) : 트리 구조에서 같은 깊이를 가지고 있는 노드를 묶어서 레벨(level)로 표현한다다. depth가 0인 루트 A의 level은 1이며, depth가 1인 B,C,D의 level은 2이다. 그리고 E와 F의 레벨은 3이 된다. 또한 같은 레벨에 나란히 있는 노드를 형제 노드(sibling Node) 라 부른다.       높이(height) :  루트부터 가장 경로가 긴 노드까지의 간선의 갯수가 높이가 된다.                마지막으로 트리는 큰 트리 내부에 트리 구조를 갖춘 작은 트리를 내포한다. 이는 서브 트리 라 부르며,  해당 서브 트리는 잘게 쪼개어 하나의 노드를 가지기 전까지는 모두 또 다시 서브 트리를 갖게된다.              즉, 한개 이상의 노드를 가진 트리는 재귀적인 구조를 지닌다.             오늘 느낀 점          자료구조.. 개념은 어렵진 않다. 효율적인 데이터 구조는 효율적인 코드를 완성시키는 첫 걸음이라 생각된다. 지금이야 솔직히 말하면 별로 필요 없는듯 보인다..       지금은 코린이 수준의 코드이기 때문에.. ,장난감 집은 쉽게 짓고 대충 만들어도 완성되지만 고층 아파트는 구조 설계가 필수적이다!            기초학문 느낌이 물씬 난다. 구조적인 개념이 많이 등장되기 때문에, 들으면 생소한 느낌은 없다.  다만, 이를 어떻게 실제 코딩에 접목을 하느냐가 굉장히 난감하다.. 객체로 선입선출되는 자료구조를 어떻게..? 이런 느낌이다.       아직 생소하다보니 겪는 문제라 생각든다. 덩치가 큰 개발이 필요한 경우. 개발진행 전 자료구조를 꼭 생각하고 개발에 진행해야 되겠다는 생각은 든다.       ex ) 탐색기 같은 프로그래밍 설계가 필요하다면 트리구조를 먼저 떠올린다. 등등..             내일 할 일     [JS/Node] 비동기  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.08.26.til/",
        "teaser": null
      },{
        "title": "[TIL] 1. 비동기 처리 2. Node.js",
        "excerpt":"  Today I Learnd  1. 비동기 처리 (Asynchronous processing)          자바스크립트의 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 행위를 말한다. 요청에 대한 결과가 동시에 일어나지 않는 특성을 가지고있다.         // #1   console.log('Hello');   // #2   setTimeout(function() {     console.log('Bye');   }, 3000);   // #3   console.log('Hello Again');           비동기 처리에 대한 이해가 없는 상태에서 해당 코드를 본다면, JS는 위에서 부터 아래로 한줄씩 읽히기 때문에  \"Hello\"출력 후 3초 뒤 \"Bye\" \"Hello Again\" 라는 출력이 기대되지만, 실제 결과는 \"Hello\" \"Hello Again\" 출력 후 3초 뒤 \"Bye\"가 출력된다.       setTimeout()이라는 Web API를 이용한다면 코드를 바로 실행하지 않고 지정한 시간만큼 기다렸다가 로직을 실행할 수 있게되는데 비동기 방식으로 실행되기 때문에, 코드 순서대로 실행되는것이 아니라 일단 setTimeout()을 실행 하고 나서 바로 다음 코드인 \"Hello Again\"으로 넘어간 뒤 3초 후 \"Bye\"를 출력하게 된다.   여기서 발생하는 문제는 setTimeout()의 지연시간을 랜덤한 숫자를 준다면 개발자는 위의 코드의 순서를 제어할수 있을까? 비동기 처리는 이처럼 순서 제어가 반드시 필요하다.    1-1. 콜백 함수를 통한 비동기 처리          위의 예시 처럼 비동기 처리는 고유의 처리 방식에 의해 야기될 수 있는 문제들이 존재함을 학습했다. 이러한 문제들을 해결 하는 여러가지 방법들이 명시되어 있는데 가장 기초적인 해결 방식은 콜백(callback) 함수를 이용하는 것이다.         const printString = (string, callback) =&gt; {     setTimeout(         () =&gt; {             console.log(string)               callback()           }, Math.floor(Math.random() * 100) + 1       )   } \t   const printAll = () =&gt; {     printString(\"A\", () =&gt; {         printString(\"B\", () =&gt; {             printString(\"C\", () =&gt; {})           })       })   } \t   printAll(); // \"A\" \"B\" \"C\"           위 코드처럼콜백 함수를 연속하여 사용하여 비동기 처리 로직을 제어 할 수 있다. 특정 로직이 끝났을 때 원하는 동작을 실행하여 순서를 제어 할수 있게 된다.            다만 위 방법이 무수히 많이 연속되는 경우엔 콜백 안에 콜백을 계속 무는 형식으로 코딩이 진행되어야 하는 문제점이 발생한다. 그렇게 된다면 코드 구조는 가독성도 떨어지며 추후 로직을 변경해야 할 필요가 생긴다면 유지보수가 굉장히 어렵다는 단점이 생길 수 있다. 이러한 콜백을 너무 연속해서 사용 하는 코드 구조를 콜백 지옥(Callback Hell) 이라고 부르며 비동기 처리가 많은 코드 구조라면 콜백을 통한 비동기 처리 순서 제어는 알맞지 않다.        1-2. Promise 객체를  이용한 비동기 처리          우선 Promise란 비동기 처리에 사용되는 객체이다.  참조 : MDN        이 Promise 객체는 3가지 상태를 가지고 있다.             Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태       Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태       Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태                대기(Pending) 상태는 new Promise() 메서드를 호출 하면 대기상태가 되며, 콜백 함수를 선언할 수 있다.         new Promise();  // Pending            new Promise() 메서드를 호출할 때 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 resolve, reject이다.        new Promise(function(resolve, reject){       // 콜백 함수의 인자는 resolve, reject 이다.   });           이행(Fulfilled) 상태는 콜백함수의 인자인 resolve를 실행하게 되면 이행상태가 된다.       new Promise(function(resolve, reject) {  // Fulfilled     resolve();   });           그리고 이행 상태가 되면 then()을 이용하여 처리 결과 값을 받을 수 있다. (resolve는 then()과 짝궁)        function getData() {     return new Promise(function(resolve, reject) {         var data = 100;           resolve(data);       });   } \t   // resolve()의 결과 값 data를 resolvedData로 받음   getData().then(function(resolvedData) {     console.log(resolvedData); // 100   });                실패(Rejected) 상태는 콜백 함수 인자로 reject를 호출 하면 실패상태가 된다.         new Promise(function(resolve, reject) {  // Rejected     reject();   });           그리고, 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 catch()로 받을 수 있다.        function getData() {     return new Promise(function(resolve, reject) {         reject(new Error(\"Request is failed\"));       });   } \t   // reject()의 결과 값 Error를 err에 받음   getData().then().catch(function(err) {     console.log(err); // Error: Request is failed   });                위 “1-1. 콜백 함수를 통한 순서 제어” ABC 순차 출력 로직 예제를 Promise로 구현하자면 다음과 같다.         const printString = (string) =&gt; {     return new Promise((resolve, reject) =&gt; {         setTimeout(             () =&gt; {                 console.log(string)                   resolve()               }, Math.floor(Math.random() * 100) + 1           )       })   } \t   const printAll = () =&gt; {     printString(\"A\").then(() =&gt; {         printString(\"B\").then(() =&gt; {             printString(\"C\")           })       })   } \t\t   printAll()  // \"A\" \"B\" \"C\"           콜백 지옥(Callback Hell)과 유사하다는 느낌을 지울수 없다. 위 처럼 여러 개의 Promise를 연결하는 걸 Promise Chaining 이라 일컫는다.       위 예제의 프로미스 체이닝을 보자면, printString함수의 resolve() 메서드가 호출되면 프로미스가 대기 상태에서 이행 상태로 넘어가기 때문에 첫 번째 .then()의 로직으로 넘어간다. 첫 번째 .then()에서는 임의의 시간 뒤 입력받은 문자열을 출력한 뒤, 그다음 .then() 으로 넘겨준다. 두 번째 .then()에서도 마찬가지로 내부 함수 실행 후 그 다음 .then()으로 넘겨준다. 그리고 마지막으로 “C”를 출력 한 뒤 printAll() 호출은 종료된다.              then()을 연결하였는데 왜 Promise를 연결한다라고 표현하나?         then() 메서드를 살펴보면 Promise를 리턴하고 두 개의 콜백 함수를 인수로 받는다. 그러므로 then()으로 연결 되었지만, 실질적인 리턴값을 보면 프로미스 객체들간의 연결고리인 셈이다.         그 외에도 then()의 특징으로 첫번째 인자는 Promise가 이행했을 때, 두번째 인자는 거부했을 때를 위한 콜백 함수이다. 그러므로 reject - catch 구문 대신 then()의 두번째 인자로 대체하여 사용할 수 있으나, 권장되는 사용 방식은 아니다.             1-3. async와 await를 사용한 비동기 처리          비동기 처리를 위한 await 키워드는 ECMAScript2017에 추가되었다. 자바스크립트의 비동기 처리 패턴 중 가장 최근에 나온 문법이기에 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와준다.       우선 기본 문법을 보자면,         async function 함수명() {     await 비동기_처리_메서드_명();   }           먼저 함수의 앞에 async 라는 예약어를 붙이고, 비동기 처리 코드 앞에 await를 붙여준다. 여기서 주의해야 할 점은 비동기 처리 메서드가 반드시 프로미스 객체를 반환해야 await가 의도한 대로 작동한다.            다시 위의 “ABC” 예제를 async와 await로 구현 후 살펴보면.         const printString = (string) =&gt; {     return new Promise((resolve, reject) =&gt; {         setTimeout(             () =&gt; {                 console.log(string)                   resolve()               }, Math.floor(Math.random() * 100) + 1           )       })   } \t   const printAll = async () =&gt; {     await printString(\"A\")     await printString(\"B\")     await printString(\"C\")   } \t\t   printAll()  // \"A\" \"B\" \"C\"           위 처럼 간단히 구현이 가능하다. await를 사용하지 않았다면 데이터를 받아온 시점에 콘솔을 출력할 수 있게 콜백 함수나 .then()등을 사용했었다. 하지만 async await 문법 덕택에 비동기에 대한 사고를 하지 않아도 되는 개발자에게 편리한 코드 구현 환경을 제공해준다.            async &amp; await에서 예외를 처리하는 방법중 문법적으로 또 다른 요소가 등장한다. 바로 try catch이다. 프로미스에서 에러 처리를 위해 .catch()를 사용했던 것처럼 async에서는 catch {} 를 사용하면 돤다. 자세한 내용은 MDN 문서 try…catch를 참조하자.       2. Node.js          Node.js는 “비동기 이벤트 기반 자바스크립트 런타임” 이다.       브라우저에서 사용할 수 있는 비동기 흐름은 타이머 혹은 DOM 이벤트와 관련된 상황으로 다소 한정적이다. 다만, Node.js에는 많은 API가 비동기로 작성되어 있다. 이를 통해 비동기 상황을 연출할 수 있다.            Node.js 에서는 자바스크립트 코드 가장 상단에 require 구문을 이용하여 다른 파일을 불러온다.        const fs = require('fs'); // 파일 시스템 모듈을 불러온다.   const dns = require('dns'); // DNS 모듈을 불러온다 \t   // 이제 fs.readFile 메소드 등을 사용할 수 있다           그 외에도 3rd-party 모듈을 npm install을 통하여 사용할 수 있다.       2-1. Node.js 모듈 실습     Callback, Promise, Async/awiat 비동기 처리 구현 실습 &amp; Node.js 모듈을 이용한 비동기 처리 실습            참조 :  Github                   오늘 느낀 점          비동기 처리 방식의 구현 프로세스 자체는 이해는 갔다. 하지만 실제 코딩은 어떻게해..? 라는 막연함이 많이 들었다. 원리&amp;구조적인 학습이라기 보다는 문법적인 학습내용이 주된 내용이다 보니, 많이 접해봐야 실제로 내께 될 듯 하다.            혼자 학습으로는 부족함을 느꼈다. (자료구조 Hell… Toy Hell…)  팀 과제 도중 대화도 잘 맞고 경험 많은 페어분을 만나 평일 21~22:00 스터디를 참여하게 되었다.       우선 1차 목표는 CodeStates 수업 내용 완벽 이해를 위한 질의응답 시간을 가진 뒤, 알고리즘 코드 풀이가 주가 될듯하다. 솔직히 TOY 알고리즘 생각하기 귀찮아서(!?) 미뤄두는 경향이 컸다. 내 자신에게 반성하며 내일부터 열심히 스터디에 임해야겠다.       알고리즘에 익숙해지면 해외 코테 사이트중  릿코드라는 사이트를 스터디분중 한분이 추천하여, 해당 사이트에서 알고리즘 문제 풀이를 진행 할 예정이다. (죄다 영어네..)             내일 할 일     [HTTP/네트워크]   알고리즘 카테고리 추가, TIL은 매일 작성하기 보다는 학습 한 단락이 마무리지어졌을때 공부한 내용 정리하기 위한 목적 정도로만 유지하고 알고리즘 코드 풀이에 조금더 시간을 할애 해볼 예정이다.  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.01.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 8. largestProductOfThree",
        "excerpt":"  TOY 8. largestProductOfThree  문제   정수를 요소로 갖는 배열을 입력받아 3개의 요소를 곱해 나올 수 있는 최대값을 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 임의의 배열   출력      number 타입을 리턴해야 합니다.   주의사항      입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   배열의 요소는 음수와 0을 포함하는 정수입니다.   배열의 길이는 3 이상입니다.   입출력 예시   let output = largestProductOfThree([2, 1, 3, 7]); console.log(output); // --&gt; 42 (= 2 * 3 * 7)  output = largestProductOfThree([-1, 2, -5, 7]); console.log(output); // --&gt; 35 (= -1 * -5 * 7)   TOY 8. Solution  수도코드      길이가 3 이상인 배열을 내림차순으로 정렬하여 arr[0] 인덱스엔 가장 큰값 ~ arr[2]인덱스엔 3번째로 큰 값을 배치한다.   arr[0]이 가장 큰 양수값이고, arr[last-1] arr[last] 값이 가장 작은 음수값 2개라면 가장 큰 곱의 경우의 수가 될 수 있다.   내림차순으로 정렬된 arr[0~2]번 인덱스 요소의 순차적인 곱의 합은 가장 큰 곱의 경우의 수가 될 수 있다.   2번과 3번의 경우의 수로 나온 결과 값을 비교하여 더 큰 경우의 값을 리턴한다   문제풀이   const largestProductOfThree = function (arr) {   arr.sort((a,b)=&gt;(b-a));  // 내림차순 sort()    const case1 = arr[0]*arr[arr.length-2]*arr[arr.length-1];  // 수도코드 2번 경우   const case2 = arr[0]*arr[1]*arr[2]; // 수도코드 3번 경우    return case1&gt;case2 ? case1 : case2;  // 3항 연산자로 결과값 출력 }  Reference Code   const largestProductOfThree = function (arr) {   const sorted = arr.slice().sort((a, b) =&gt; a - b);   const len = arr.length;   const candi1 = sorted[len - 1] * sorted[len - 2] * sorted[len - 3];   const candi2 = sorted[len - 1] * sorted[0] * sorted[1];   return Math.max(candi1, candi2); };  오늘 느낀 점     Reference Code가 확실히 간결하고 코드가 말하고자 하는 바를 명시적으로 표현한듯하다.   slice()로 배열을 복사한건 왜일까..?  물론 하면 좋지만 딱히 중요한 포인트는 아닌듯 하다.   Math.max를 이용하여 최대값을 리턴하는 방법은 신선했다. 조건문이나…삼항조건연산자로만 풀 생각하였었고, 나름 간결한 문장이라 생각했는데 만약 경우의 수가 2개 이상이었다면 내 코드는 더 복잡해졌을꺼다.   내일 할 일     (주말)  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.02.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. HTTP/네트워크 2. SSR과 CSR",
        "excerpt":"  Today I Learnd  1. HTTP/네트워크  1-1. 클라이언트-서버 아키텍처          클라이언트-서버 아키텍처는 리소스가 존재하는 곳과, 리소스를 사용하는 앱을 분리시킨 네트워크 모델이다. 리소스를 사용하는 앱이 바로 “클라이언트”, 리소스가 제공(serve)하는 곳은 “서버” 라고 부른다. 클라이언트와 서버로만 이루어진 모델을 2-Tier 아키텍처라고 부르기도 한다.              일반적으로 서버는 리소스를 전달해주는 역할만 담당한다. 리소스를 저장하는 공간을 별도로 마련해 두는데, 이 공간을 “데이터베이스” 라고 부르며, 이처럼 기존 2티어 아키텍처에 데이터베이스가 추가된 형태를 3티어 아키텍처라고 일컫는다.        1-2. HTTP 프로토콜이란?          HTTP(Hypertext Transfer Protocol)는 웹을 개발하는 사람이라면 누구나 다 알아야 하는 통신 프로토콜이다. 프로토콜이란 상호 간에 정의한 규칙을 의미하며 특정 기기 간에 데이터를 주고받기 위해 정의되어 있다.       웹에서는 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용하고 있다.            HTTP 프로토콜의 특징은 상태가 없는(stateless) 프로토콜이다. 여기서 “상태가 없다”라는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 말이다. 즉, 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없이 독립적이다.       이러한 특징 덕택에 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점이 생긴다.       1-3. URL와 URI          URL은 Uniform Resource Locator의 줄임말로, 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보를 나타낸다.       URI는 Uniform Resource Identifier의 줄임말로, 일반적으로 URL의 기본 요소인 scheme, hosts, url-path에 더해 query, bookmark를 포함합니다.  브라우저의 검색창을 클릭하면 나타나는 주소가 URI이다. URI는 URL을 포함하는 상위개념이므로 'URL은 URI다.' 는 참이고, 'URI는 URL이다.' 는 거짓이다.       http://www.google.com:80/search?q=JavaScript 를 브라우저의 검색창에 입력하면, 구글에서 JavaScript를 검색한 결과가 나타난다. 이를 자세히 살펴 보면 다음과 같은 특징을 갖는다.              1-4. HTTP Request &amp; HTTP Response          HTTP로 데이터를 주고받기 위해서는 아래와 같이 요청(Request)을 보내고 응답(Response)을 받아야 합니다.              이때 서버는 요청을 받은 클라이언트에게 리소스를 잘 활용할 수 있도록 인터페이스(interface)를 제공해줘야 한다. 이것을 API, 애플리케이션 프로그래밍 인터페이스(Application Programming Interface) 라고 한다.            앞에서 살펴본 URL을 이용하면 서버에 특정 데이터를 요청할 수 있다. 여기서 요청하는 데이터에 특정 동작을 수행하고 싶으면 HTTP 요청 메서드(Http Request Methods)를 이용한다. 일반적으로 HTTP 요청 메서드는 HTTP Verbs라고도 불리우며 아래와 같이 주요 메서드를 갖고 있다.              GET : 존재하는 자원에 대한 요청       POST : 새로운 자원을 생성       PUT(PATCH) : 존재하는 자원에 대한 변경       DELETE : 존재하는 자원에 대한 삭제                다양한 요청 메서드는 해당 문서에서 참조하자. 참조 : MDN       1-5. HTTP 메세지 포맷          앞서서 말한 내용을 요약하면, HTTP는 특정 상태를 유지하지 않으며 웹 브라우저와 웹 서버의 소통을 위해 디자인되었으며 (1-2. HTTP 프로토콜이란?) 클라이언트-서버 모델에서 클라이언트가 HTTP messages 양식에 맞춰 요청을 보내면, 서버도 HTTP messages 양식에 맞춰 응답한다 배웠다. (1-4. HTTP Request &amp; HTTP Response).       HTTP messages는 요청(Requests)과 응답(Responses)에서 다음과 같은 구조를 지닌다.                     start line : start line에는 요청이나 응답의 상태를 나타내며, 항상 첫 번째 줄에 위치한다. 응답에서는 status line이라고 부른다.       HTTP headers : 요청을 지정하거나, 메시지에 포함된 본문을 설명하는 헤더의 집합.       empty line : 요청에 대한 모든 메타 정보가 전송되었음을 알리는 빈 줄       body : 요청과 관련된 데이터나 응답과 관련된 데이터 또는 문서를 포함한다. 요청과 응답의 유형에 따라 선택적으로 사용된다.           이 중 start line과 HTTP headers를 묶어 요청이나 응답의 헤드(head)라고 하고, payload는 body라고 이야기합니다.              페이로드(영어: payload)는 사용에 있어서 전송되는 데이터를 뜻한다. 페이로드는 전송의 근본적인 목적이 되는 데이터의 일부분으로 그 데이터와 함께 전송되는 헤더와 메타데이터와 같은 데이터는 제외한다. 참조 : MDN            1-6. HTTP 요청 (Request)          HTTP 요청은 서버가 특정 동작을 취하게끔 만들기 위해 클라이언트에서 전송하는 메시지라는걸  위에서 학습하였다. 이 메세지의 내용은 다음과 같이 이루어져 있다.       시작줄            수행할 작업(GET, PUT, POST 등)이나 방식(HEAD or OPTIONS)을 설명하는 HTTP method를 나타낸다. 예를 들어 GET method는 리소스를 받아야 하고, POST method는 데이터를 서버로 전송한다.       요청 대상(일반적으로 URL이나 URI) 또는 프로토콜, 포트, 도메인의 절대 경로는 요청 컨텍스트에 작성된다. 이 요청 형식은 HTTP method 마다 다르다.       HTTP 버전마다 메시지의 구조가 다르다. 이를 위해 HTTP 버전을 함께 입력한다.                헤더 : 요청의 Headers는 기본 구조를 따른다. 대소문자 구분 없는 문자열과 콜론(:), 값을 입력합니다. 값은 헤더에 따라 다르다. 여러 종류의 헤더가 있으며 참조를 통해 확인하자. 참조 : MDN        바디 : 요청의 본문은 HTTP messages 구조의 마지막에 위치한다. 하지만, 모든 요청에 body가 필요하지는 않는다. GET, HEAD, DELETE, OPTIONS처럼 서버에 리소스를 요청하는 경우에는 본문이 필요하지 않는다. POST나 PUT과 같은 일부 요청은 존재하는 자원에 대한 변경 및 업데이트가 필요하므로 사용된다.   1-7. HTTP 응답(Responses)          전반적인 내용은 요청과 비슷하지만 다른점만 서술해보았다.       시작줄            현재 프로토콜의 버전(HTTP/1.1)       상태 코드 : 요청의 결과를 코드번호로 나타낸다 (200, 302, 404 ETC…)       상태 텍스트 : 상태 코드에 대한 설명                특히 이 상태 코드를 통하여 에러처리를 할 수 있기 때문에 프론트엔드 클라이언트 개발자에겐 가장 중요한 정보이다.       주요 상태 코드는 200번대부터 500번대까지 다양하게 있지만 주요한 상태 코드만 몇 개 살펴보자면,             2xx : 200번대의 상태 코드는 대부분 요청에 대한 응답 성공을 의미한다.       3xx : 300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우이다.                4xx : 400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우이다. 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생한다. 가장 익숙한 상태 코드는 404 코드이다. 요청한 자원이 서버에 없다는 의미이다.                      웹페이지에서 종종 겪는 404 에러 출력 메세지               5xx : 500번대 상태 코드는 서버 쪽에서 오류가 난 경우이다.           2. SSR과 CSR  2-1. SSR(Server Side Rendering)          웹 페이지를 브라우저에서 렌더링하는 대신에, 서버에서 렌더링하는 경우를 일컫는다.              브라우저가 서버의 URI로 GET 요청을 보내면, 서버는 정해진 웹 페이지 파일을 브라우저로 전송한다. 그리고 서버의 웹 페이지가 브라우저에 도착하면 완전히 렌더링하게 된다.       서버에서 웹 페이지를 브라우저로 보내기 전에, 서버에서 완전히 렌더링했기 때문에 Server Side Rendering 이라고 한다.       웹 페이지의 내용에 데이터베이스의 데이터가 필요한 경우, 서버는 데이터베이스의 데이터를 불러온 다음 웹 페이지를 완전히 렌더링 된 페이지로 변환한 후에 브라우저에 응답으로 보낸다. 웹 페이지를 살펴보던 사용자가, 브라우저의 다른 경로로 이동하면 브라우저가 다른 경로로 이동할 때마다 서버는 이 작업을 다시 수행한다.       2-1. CSR(Client Side Rendering)          SSR이 서버 측에서 페이지를 렌더링한다면, CSR은 클라이언트에서 페이지를 렌더링한다.              브라우저의 요청을 서버로 보내면 서버는 웹 페이지를 렌더링하는 대신, 웹 페이지의 골격이 될 단일 페이지를 클라이언트에 보낸다. 이때 서버는 웹 페이지와 함께 JavaScript 파일을 보내어서 클라이언트가 웹 페이지를 받으면, 웹 페이지와 함께 전달된 JavaScript 파일은 브라우저에서 웹 페이지를 완전히 렌더링 된 페이지로 바꾸게된다.       웹 페이지에 필요한 내용이 데이터베이스에 저장된 데이터인 경우에는 브라우저는 데이터베이스에 저장된 데이터를 가져와서 웹 페이지에 렌더링을 해야 한다. 이를 위해 API가 사용된다. 웹 페이지를 렌더링하는 데에 필요한 데이터를 클라이언트는 서버에 API 요청으로 해결할 수 있다.       마지막으로, 브라우저가 다른 경로로 이동하면 SSR과 다르게 서버가 웹 페이지를 다시 보내지 않는다. 브라우저는 브라우저가 요청한 경로에 따라 페이지를 다시 렌더링하며, 이때 보이는 웹 페이지의 파일은 맨 처음 서버로부터 전달받은 웹 페이지 파일과 동일한 파일이다.       2-2. SSR과 CSR의 차이점          우선 속도적인 측면을 보면, 웹 페이지 로딩의 종류는 두 가지로 나눌 수 있다. 하나는 웹 사이트의 가장 첫 페이지를 로딩하는 것 그리고, 다른 하나는 나머지를 로딩하는 것을 꼽을 수 있다.       첫 페이지 로딩시간은 CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다. 반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다. 따라서 평균적으로 SSR이 더 빠르다.       나머지 로딩 시간은 첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자. CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다. 반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.            검색 엔진은 자동화된 프로그램 ‘크롤러’로 웹 사이트들을 읽는다.       CSR은 웹 페이지와 함께 전달 된 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 자바스크립트가 실행 되어야 올바른 리소스가 바뀌게 된다. 하지만 SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.             오늘 느낀 점          HTTP 란, 서버-클라이언트간의 상호간에 협의 된 규칙으로 자원을 주고받는 일련의 과정들을 학습하였다. 약간… 구조적인 내용의 학습이었다. 문법이나 코드기술등이 아닌 원초적이고 근본적인 내용이랄까??       우선 오늘 학습내용을 최대한 요약하자면, 클라이언트는 특정된 \"요청 메서드\"로 서버에 자원을 요구하고, 서버는 해당 요청을 \"응답 코드\"가 포함된 응답으로 답변을 한다. 이때 상호간에 대화(?)는 프로토콜이라는 상호간에 규정된 규칙으로 이뤄진다. 정도로 말할 수 있다.              해당 사진의 흐름으로 “서버-클라이언트 간에 Request &amp; Responses가 이뤄진다.” 라는 내용은 머릿속에 집어넣었다 생각한다.            SSR 과 CSR이 언제 필요하며, 각각의 장단점은 짚고 넘어갔다. SSR이 다시 각광을 받는 듯한 분위기던데.. 조금 더 공부가 필요할 듯 하다.             내일 할 일  -[React] 데이터 흐름의 이해와 비동기 요청 처리  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.02.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 10. binarySearch",
        "excerpt":"  TOY 10. binarySearch  문제   오름차순 정렬된 정수의 배열(arr)과 정수(target)를 입력받아 target의 인덱스를 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 임의의 배열   arr[i] 는 정수   인자 2 : target     number 타입의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      이진탐색 알고리즘(O(logN))을 사용해야 합니다.   단순한 배열 순회(O(N))로는 통과할 수 없는 테스트 케이스가 존재합니다.   target이 없는 경우, -1을 리턴해야 합니다.   입출력 예시   let output = binarySearch([0, 1, 2, 3, 4, 5, 6], 2); console.log(output); // --&gt; 2  output = binarySearch([4, 5, 6, 9], 100); console.log(output); // --&gt; -1   TOY 10. Solution  수도코드   target과 node의 값이 작거나,같거나,클 경우의 경우를 조건분기로 나누어 이진탐색트리와 같은 탐색방법을 알고리즘으로 구현한다.      target이 없는 경우 (includes.., indexOf 등으로 target 값이 배열에 존재하는지 탐색). -1을 리턴해주는 조건분기 설정   최초 탐색할 중간 idx 설정. 해당 idx 기준으로 탐색 시작.   arr[중간] 값과 target을 비교 하여 같은 경우 탐색종료 해당 idx 값 반환   arr[중간] 값과 target을 비교 하여 클 경우 중간 idx 우측 남은값(arr[중간+1] ~ arr[length-1])을 바탕으로 재귀 실행,   작을 경우 중간 idx 좌측 남은값 바탕으로 재귀 실행   이진탐색트리의 시간복잡도에 알맞는 계산방식으로 구현   문제풀이   const binarySearch = function (arr, target) {   // 이진탐색 (binary search)은 탐색범위의 절반을 기준으로    // target과 확인한 후 그 절반값보다 큰 곳 또는 작은 곳을 다음 탐색범위로 잡아가는 탐색방법   if(!arr.includes(target)) { return -1; } // target이 arr배열에 없다면 -1 리턴      const idxCenter = Math.floor(arr.length/2); // 중간 인덱스 설정    if(arr[idxCenter]===target) { return idxCenter; } // arr[중간인덱스] === target과 같다면, rootNode 가 타겟인 경우이다.    const recArr = arr[idxCenter] &gt; target ? // arr[중간인덱스] &gt; target이 크다면 root의 좌측으로 탐색이 진행되야함     arr.slice(0,idxCenter) : // recArr = 중간인덱스 기준, 좌측 slice     arr.slice(idxCenter+1); // recArr = 중간인덱스 기준, 우측 slice      return binarySearch(recArr,target);  // 재귀 호출 };  Reference Code   const binarySearch = function (arr, target) {   let left = 0,     right = arr.length - 1;   while (left &lt;= right) {     let middle = parseInt((right + left) / 2);     if (arr[middle] === target) {       return middle;     }     if (target &lt; arr[middle]) {       right = middle - 1;     } else {       left = middle + 1;     }   }   return -1; };  오늘 느낀 점     일단 틀렸다. 시간복잡도에 대한 내용에서 에러가 잡힌다.        우선 빅-오 표기법 중 O(logN) 의 시간복잡도는 연산과정이 절반씩 줄어들 경우인건 확실히 인지하였다.       자세한 내용은 해당 블로그 내용참조 : https://jwoop.tistory.com/9       재귀를 통하여 전달하는 arr의 길이를 절반씩 줄였기 때문에 O(logN)을 만족한다 생각하였는데 시간복잡도를 만족못한다는 에러가 발생한다.            배열을 통한 메서드로 연산 처리시 발생하는 시간복잡도는 숙지해둬야할 듯 하다. (참조 : https://dev.to/lukocastillo/)       배열을 모든 요소를 순회하며, 처리하는 메소드들 (ex. slice(), includes(), indexOf()..등등) 시간복잡도 O(logN) 을 만족할 수 없는 결과를 야기시킨다.       알고리즘은 간단하였다, 애초에 배열을 절반씩 자르면서 접근하려던 의도도 O(logN)을 충족시키려 시도해보았던 과정인데 메소드 자체가 이미 배열을 모두 순회한뒤 -&gt; 해당 인덱스까지 얕은 복사가 이뤄지는 과정이다. 그러므로 접근 시도는 좋았지만 사용된 도구(메소드)가 잘못되었다.   내일 할 일     TOY 11. powerSet  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.06.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 11. powerSet",
        "excerpt":"  TOY 11. powerSet  문제   하나의 집합을 의미하는 문자열을 입력받아 각 문자를 가지고 만들 수 있는 모든 부분집합을 리턴해야 합니다.   입력   인자 1 : str     string 타입의 공백이 없는 알파벳 소문자 문자열   출력      배열(arr)을 리턴해야 합니다.   arr[i]는 각 부분집합의 원소로 구성된 문자열   주의사항      arr[i]는 각 부분집합을 구성하는 원소를 연결한 문자열입니다.   arr[i]는 알파벳 순서로 정렬되어야 합니다.   집합은 중복된 원소를 허용하지 않습니다.   부분집합은 빈 문자열을 포함합니다.   arr은 사전식 순서(lexical order)로 정렬되어야 합니다.   입출력 예시   let output1 = powerSet('abc'); console.log(output1); // ['', 'a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']  let output2 = powerSet('jjump'); console.log(output2); // ['', 'j', 'jm', 'jmp', 'jmpu', 'jmu', 'jp', 'jpu', 'ju', 'm', 'mp', 'mpu', 'mu', 'p', 'pu', 'u']   TOY 11. Solution  수도코드      입력 받은 배열을 배열로 변환, 정렬   집합은 중복된 원소를 허용하지 않으므로, 정렬된 배열을 중복값을 제거해줌 (flilter…등 메소드 활용 필요)   DFS 깊이 알고리즘을 통해 멱집합 알고리즘 구현. (flag 배열을 생성하여 중복값 여부 check)   문제풀이   const powerSet = function (str) {   // TODO: 여기에 코드를 작성합니다.   const sortArr = str.split('').sort(); // sortArr = str-&gt;arr 변환 후 정렬한다.   const uniqueArr = sortArr.filter((el, index) =&gt; sortArr.indexOf(el) === index)    // 중복값 제거, filter 메소드를 이용하여 sortArr.indexOf(el)값이 index와 같은 조건의 uniqe한 값들로 채운 배열을 선언.   let flag = new Array(uniqueArr.length).fill(false); // 플래그 생성.    const subSets = [];    const subSet = function DFS (depth) { // 부분 집합 구하는 재귀 함수, DFS 알고리즘     if (depth === uniqueArr.length) { // 트리의 끝에 다다른 것 ==&gt; 재귀 종료 조건       const subSet = uniqueArr.filter((value, index) =&gt; flag[index]).join('');        // subset = [ flag[index] === true 이면, uniqueArr[index]을 반환하는 배열이 생성된다]       subSets.push(subSet); // 부분집합들을 담는 배열에 push        return; // 이전 depth로 회귀     }      flag[depth] = true; // 해당 depth의 flag true = 트리의 왼쪽     subSet(depth + 1); // 트리의 왼쪽에 대해 재귀호출      flag[depth] = false; // 해당 depth의 flag false = 트리의 오른쪽     subSet(depth + 1); // 트리의 오른쪽에 대해 재귀 호출   }      subSet(0); // depth 0 부터 시작   return subSets.sort(); };   Reference Code   const powerSet = function (str) {   // 정렬   const sorted = str.split('').sort();    // 중복 제거   const deduplicated = sorted.reduce((acc, item) =&gt; {     if (acc[acc.length - 1] === item) {       return acc;     } else {       return acc.concat(item);     }   });    let subSets = [];   const pickOrNot = (idx, subset) =&gt; {     // base case     if (idx === deduplicated.length) {       // 마지막 문자까지 검토한 경우       subSets.push(subset);       return;     }      // recursive case     // idx번째 문자가 포함되지 않는 경우     pickOrNot(idx + 1, subset);      // idx번째 문자가 포함되는 경우     pickOrNot(idx + 1, subset + deduplicated[idx]);   };    pickOrNot(0, '');    return subSets.sort(); };  오늘 느낀 점          멱집합 알고리즘을 참조 하였다. 참조 : https://jun-choi-4928.medium.com 블로그              참고한 사이트 자료가 너무 보기 좋게 정리되어있어서 이해는 어렵지 않았다. (물론 손으로 당연히 쓰면서…)            return ;이 의미하는 바가 무엇인지 정확히 이해하였다. 재귀를 구현하다보면 재귀의 스택이 쌓이기 마련이다. 이럴때 이전 단계로 회귀(?)하는 느낌을 받았다. DFS 알고리즘 경우 트리의 한 줄기의 깊이를 모두 탐색 후, 다른 줄기로 뻗어야 한다. Leaf 노드로 이르렀을때, 이전 노드로 돌아가기 위해 return ;을 사용해야한다는 개념을 확실히 익힌 알고리즘이었다.            외람되지만, 알고리즘 해결 위해 구글링 중 set이라는 자료구조를 접하였다.             Set는 데이터를 비순차적(unordered)으로 저장할 수 있는 순열 자료구조 (collection)입니다. … Array,List와 마찬가지로 Set는 수정이 가능합니다. 중복을 허용하지 않아서 같은값을 삽입하면 되면, 마지막에 삽입한 값 하나만 저장 됩니다.            중복을 허용하지 않은 자료구조 솔깃하다..       const sortArr = str.split('').sort(); const uniqueArr = sortArr.filter((el, index) =&gt; sortArr.indexOf(el) === index)           위 행위를 뭔가 한코드로 줄일수 있을 듯한 느낌이 온다.       내일 할 일     TOY 12. treeBFS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.07.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. React 데이터 흐름 2. Effect Hook",
        "excerpt":"  Today I Learnd  1. React 데이터 흐름    1-1. 상향식(bottom-up) 개발          React의 개발 방식의 가장 큰 특징은 페이지 단위가 아닌, 컴포넌트 단위로 시작한다는 점이다.       앱을 만들거나 웹페이지를 만들때 페이지를 만들기 이전에 컴포넌트를 만들고 조립을한다. 즉, 상향식(bottom-up)으로 앱을 만드는 것이다. 이러한 구조의 가장 큰 장점은 테스트가 쉽고 확장성이 좋다. 이때 중요한점은 하나의 컴포넌트는 한가지 일만 하는 단일 책임 원칙을 따르는 것이다. 그래야 이후 오류 발생시 오류 컴포넌트를 쉽게 찾고 수정할 수 있습니다.       이러한 흐름을 이해하였다면, 웹페이지나 앱 디자인을 전달 받았을때 React 개발자는 이를 컴포넌트 계층 구조로 나누는 것이 가장 먼저 해야 할 일이다.       1-2. 하향식(top-down) 데이터 흐름          단방향 데이터 흐름(one-way data flow) 이라는 키워드는 React를 대표하는 키워드이다.       컴포넌트는 컴포넌트 바깥에서 props를 이용해 데이터를 마치 인자(arguments) 혹은 속성(attributes)처럼 전달받을 수 있다. 즉, 데이터를 전달하는 주체는 부모 컴포넌트가 되며, 이는 데이터 흐름이 하향식(top-down)임을 의미한다. 또한 컴포넌트는 props를 통해 전달받은 데이터가 어디서 왔는지 전혀 알지 못한다는 특징들이 단방향 데이터 흐름(one-way data flow)이다.       1-3. 데이터 흐름을 고려한 State 배치          앞서 state에 관하여 학습했지만 데이터 흐름에 포커스를 맞춰 다시 언급하자면, App 에서 필요한 데이터는 ‘변하는 값’과 ‘변하지 않는 값’ 두 가지로 나누어볼 수 있다. 예를들어 user 가 입력하는 값은 이벤트에 따라 얼마든 변할 수 있는 값이며, 이 것을 state (상태) 라고 한다.       React 로 개발을 할 때에 모든 데이터를 state 로 둘 필요는 없다. 사실 state 가 많아질 수록 앱이 복잡해지기 때문에 state 는 최소화 될 수록 좋다. 어떤 데이터를 state 로 두어야 하는지 여부는 다음 세 가지의 질문을 통해 판단해볼 수 있습니다.              부모 컴포넌트 props 를 통해 전달되는가?       시간이 지나도 변하지 않는가?       컴포넌트 안의 다른 state 또는 props 를 가지고 계산이 가능한가?           ‘아니오’ 라는 답변이 나온다면 해당 데이터는 state 로 두어야 할 필요가 있다.       그렇다면 state 를 어디에 위치시켜야 데이터 흐름에 알맞은가? 만일 state 가 특정 컴포넌트 안에서만 유의미하다면 그 컴포넌트 에 위치시키면 되지만, 하나의 state 를 기반으로 두 컴포넌트가 영향을 받는다면, 공통 소유 컴포넌트를 찾아 해당 위치에 state 를 위치시켜야 한다.       즉, 두 개의 자식 컴포넌트가 하나의 state 에 접근하고자 할 때에는 하향식(top-down), 단방향 데이터 흐름을 고려하여 두 자식 컴포넌트의 공통된 부모 컴포넌트에 state 를 위치시켜야 한다.       1-4. State 끌어올리기 (Lifting State Up)            지금까지 단방향 데이터 흐름(one-way data flow)이라는 원칙에 따라, 하위 컴포넌트는 상위 컴포넌트로부터 전달만 받을 수 있었다. 또한 전달 받은 값의 형태 혹은 타입이 무엇인지만 알 수 있었다.       그러므로 State 끌어올리기 (Lifting State Up) 가 발생되어 하위 컴포넌트에서의 어떤 이벤트로 인해 상위 컴포넌트의 상태가 바뀌는 것은 마치 “역방향 데이터 흐름”과 같이 조금 이상하게 들릴 수 있다. React가 제시하는 해결책은 다음과 같다.       상위 컴포넌트의 “상태를 변경하는 함수” 그 자체를 하위 컴포넌트로 전달하고, 이 함수를 하위 컴포넌트가 실행한다       함수의 작성은 부모 컴포넌트에서 이뤄지며 props로 사용은 자녀 컴포넌트에서 이루어진다. 여전히 단방향 데이터 흐름에 원칙에 부합하지만, 하위 컴포넌트에서 상위 컴포넌트의 상태를 변경할 수 있게 된다. 바로 이것이 State 끌어올리기 (Lifting State Up)이다.       2. Effect Hook  2-1. useEffect()          useEffect는 컴포넌트가 렌더링 될 때마다 특정 작업을 실행할 수 있도록 하는 Hook 이다.       렌더링은 컴포넌트가 mount되었을 때,  update되었을 때 나타난다. 해당 시점에 특정 작업을 처리 할 수 있는 함수이다.       즉, 클래스형 컴포넌트에서 사용할 수 있었던 생명주기 메소드를 함수형 컴포넌트에서 사용할 수 있게 된다.                   useEffect의 기본형은 useEffect( function, deps )이다.       function은 수행하고자 하는 작업이며, deps는 배열형태를 전달받는다. 해당 배열안에는 검사하고자 하는 특정 값 혹은 빈 배열이 들어간다.       deps의 값에 따라 useEffect() 함수의 실행 횟수가 결정된다. []을 넣는 경우 한번만 실행이되며, 특정 값이 업데이트( 특정 props, state가 바뀔 때) 될 때 실행하고 싶을 때는 deps 위치의 배열 안에 검사하고 싶은 값을 넣어준다.       이러한 특성 때문에 deps에 들어간 배열은 종속 배열, 의존성 배열(dependency Arr) 등으로 부르기도 한다.       또한 deps파라미터를 생략한다면, 컴포넌트가 리렌더링 될 때마다 useEffect() 함수가 호출되므로 주의해야 한다.       3. 실습     참조 : GitHub   3-1. State 끌어올리기 (Lifting State Up) 다이어그램           오늘 느낀 점          useEffect().. 아직 감이 안잡힌다. 컴포넌트가 렌더링 될때마다 특정 함수가 작동되는 경우 사용이 되어야 한다 일단 학습하였다.       실습에서도 AJAX로 가져온 데이터 값을 condition.destination 즉, 도착지를 입력하며 새로 렌더링 하였다.       우선 사용목적은 감은 오지만 실제 코드에 적용하기까진 시간이 필요할 듯하다.             내일 할 일     [Web Server] 기초  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.07.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 12. treeBFS",
        "excerpt":"  TOY 12. treeBFS  문제   임의의 tree를 구성하는 노드 중 하나의 Node 객체를 입력받아, 해당 노드를 시작으로 너비 우선 탐색(BFS, Breadth First Search)을 합니다. 이 때, 탐색되는 순서대로 노드의 값이 저장된 배열을 리턴해야 합니다.   입력   인자 1 : node     'value', 'children' 속성을 갖는 객체 (Node)   'node.value'는 number 타입   'node.children'은 Node를 요소로 갖는 배열   출력      배열을 리턴해야 합니다.   주의사항      생성자 함수(Node)와 메소드(addChild)는 변경하지 않아야 합니다.   입출력 예시   let root = new Node(1); let rootChild1 = root.addChild(new Node(2)); let rootChild2 = root.addChild(new Node(3)); let leaf1 = rootChild1.addChild(new Node(4)); let leaf2 = rootChild1.addChild(new Node(5)); let output = bfs(root); console.log(output); // --&gt; [1, 2, 3, 4, 5]  leaf1.addChild(new Node(6)); rootChild2.addChild(new Node(7)); output = bfs(root); console.log(output); // --&gt; [1, 2, 3, 4, 5, 7, 6]   TOY 12. Solution  수도코드              Queue를 사용, 선입 선출이다.              인큐 : 루트 노드 (초기값 할당)       디큐 값을 결과값 배열에 push       인큐 : 루트 노드의 자식 배열들을 반복문을 수행하며 인큐       디큐 값을 결과값 배열에 push       큐가 비워질때 까지 ….반복           문제풀이   let bfs = function (node) {   // TODO: 여기에 코드를 작성합니다.   let queue = [node]; // 초기 root 노드 할당   let values = [];  // 결과값 배열      while (queue.length !== 0) {  // 큐가 비워질때까지 반복     let head = queue[0]; // head는 values로 비워지기전 queue의 정보를 담고있는 변수이다.     queue.shift(); // = slice(1) 선입선출, shift로 queue[0] 삭제     values.push(head.value); // 결과값 배열에 head의 값 push          head.children.forEach((child) =&gt; queue.push(child)); // queue에 head의 children 배열을 넣어준다   }      return values; };  // 이 아래 코드는 변경하지 않아도 됩니다. 자유롭게 참고하세요. let Node = function (value) {   this.value = value;   this.children = []; };  // 위 Node 객체로 구성되는 트리는 매우 단순한 형태의 트리입니다. // membership check(중복 확인)를 따로 하지 않습니다. Node.prototype.addChild = function (child) {   this.children.push(child);   return child; };   Reference Code   let bfs = function (node) {   // TODO: 여기에 코드를 작성합니다.   let queue = [node];   const values = [];   while (queue.length &gt; 0) {     const head = queue[0];     queue = queue.slice(1);      values.push(head.value);      head.children.forEach((child) =&gt; queue.push(child));   }   return values; };  // 이 아래 코드는 변경하지 않아도 됩니다. 자유롭게 참고하세요. let Node = function (value) {   this.value = value;   this.children = []; };  // 위 Node 객체로 구성되는 트리는 매우 단순한 형태의 트리입니다. // membership check(중복 확인)를 따로 하지 않습니다. Node.prototype.addChild = function (child) {   this.children.push(child);   return child; };  오늘 느낀 점     큐의 자료구조를 이용하리라는 생각은 안해보아서, 레퍼런스 코드를 참조하였다.   BFS 가 어떻게 순회되는지 개념은 확실히 알 수 있었던 알고리즘이다.   내일 할 일     TOY 13. insertionSort  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.08.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 13. insertionSort",
        "excerpt":"  TOY 13. insertionSort  문제   정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 배열   arr[i]는 정수   arr.length는 1,000 이하   출력      number 타입을 요소로 갖는 배열을 리턴해야 합니다.   배열의 요소는 오름차순으로 정렬되어야 합니다.   arr[i] &lt;= arr[j] (i &lt; j)   주의사항      삽입 정렬을 구현해야 합니다.   arr.sort 사용은 금지됩니다.   입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   입출력 예시   let output = insertionSort([3, 1, 21]); console.log(output); // --&gt; [1, 3, 21]   Advanced       insertionSort 함수의 두 번째 인자로 callback 함수를 받아서, 그 함수의 리턴값을 기준으로 요소들을 정렬해 보세요.   TOY 13. Solution  수도코드         반복문을 수행하며 arr[1] 부터 정렬 시작   정렬 할 값 기준으로 좌측은 이중 반복문을 순회 하며 자기 자신의 위치를 찾는다   Advance… 문제 이해가 안간다. 콜백?   문제풀이   const insertionSort = function (arr) {   // TODO: 여기에 코드를 작성합니다.   for(let i = 1 ; i &lt; arr.length ; i++){        let temp = arr[i]; // 비교할 대상       let prev = i - 1;  // 비교할 대상 좌측 마지막 index        while( (prev &gt;= 0) &amp;&amp; (arr[prev] &gt; temp) ) {            // 좌측 index 값이 0보다 클때, 그리고 비교 대상보다 이전 인덱스 배열 값이 클때 반복문 수행          arr[prev+1] = arr[prev]; // 현재 temp 자리에 arr[prev]를 넣는다.          prev--; // 증감식       }        arr[prev + 1] = temp; // prev자리에 temp를 넣는다.    }        return arr; };  Reference Code   const insertionSort = function (arr, transform = (item) =&gt; item) {   let sorted = [arr[0]];   for (let i = 1; i &lt; arr.length; i++) {     if (transform(arr[i]) &gt;= transform(sorted[i - 1])) {       sorted.push(arr[i]);     } else {       for (let j = 0; j &lt; i; j++) {         if (transform(arr[i]) &lt;= transform(sorted[j])) {           const left = sorted.slice(0, j);           const right = sorted.slice(j);           sorted = left.concat(arr[i], right);           break;         }       }     }   }    return sorted; };  오늘 느낀 점          Reference Code 를 보니 배열의 기존 값을 해치지 않았다. sorted 변수를 선언하여, slice로 배열 값을 복사하여 썼다.  나는 원 배열을 수정하는 mutable 한 방식을 썼기에 나중에 코드 이식성등을 고려하면 알맞는 코드는 아니다. 다시 풀어봐야 할 듯 하다.       콜백 함수는 아직도 왜 쓴건진 모르겠다… 아직 콜백 함수의 개념을 내가 잘 모르는건가? 주말중 을 이용하여 다시 풀어봐야할 문제중 하나이다.   그다지 .. 많이 쓰일 정렬 알고리즘은 아닌거 같다. 최악의 경우 시간복잡도는 O(n^2) 이며, 배열의 길이가 길수록 최악의 시간복잡도에 가까워 질 수 밖에 없는 구조이다. 배열의 길이가 짧은 경우, 코드의 길이가 길진 않고 쉽게 구현되는 만큼 짧은 길이의 배열에 적합해 보인다.   내일 할 일     TOY 14. rotatedArraySearch  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.09.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 14. rotatedArraySearch(작성중)",
        "excerpt":"  TOY 14. rotatedArraySearch  문제   부분적으로 오름차순 정렬*된 정수의 배열(rotated)과 정수(target)를 입력받아 target의 인덱스를 리턴해야 합니다.     부분적으로 정렬된 배열: 배열을 왼쪽 혹은 오른쪽으로 0칸 이상 순환 이동할 경우 완전히 정렬되는 배열   예시: [4, 5, 6, 0, 1, 2, 3]은 왼쪽으로 3칸 또는 오른쪽으로 4칸 순환 이동할 경우 완전히 정렬됩니다.   입력   인자 1 : rotated     number 타입을 요소로 갖는 배열   rotated[i]는 정수   인자 2 : target     number 타입의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      rotated에 중복된 요소는 없습니다.   target이 없는 경우, -1을 리턴해야 합니다.   입출력 예시   let output = rotatedArraySearch([4, 5, 6, 0, 1, 2, 3], 2); console.log(output); // --&gt; 5  output = rotatedArraySearch([4, 5, 6, 0, 1, 2, 3], 100); console.log(output); // --&gt; -1   Advanced       단순히 처음부터 끝까지 찾아보는 방법(O(N)) 대신 다른 방법(O(logN))을 탐구해 보세요.   힌트       이진 탐색(binary search)을 약간 변형하여 해결합니다.   TOY 14. Solution  수도코드    문제풀이     Reference Code     오늘 느낀 점        내일 할 일     TOY 15. primePassword  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.10.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. CORS 2. Mini Node Server",
        "excerpt":"  Today I Learnd  1. CORS(Cross-Origin Resource Sharing)          교차 출처 리소스 공유라 불리는 CORS는 브라우저에서 다른 출처의 리소스를 공유하는 방법이다. 출처에 대해서 설명하기 전, URL의 구조에 대해서 짚고 넘어가야한다. 앞서 URL에 대하여 학습한적이 있다. 다시 들여다 보면,              이중 출처(Origin)는 Protocol, Host,  Port(생략가능)를 합친 것을 말한다. Origin은 모든 웹페이지 개발자도구에서 location.origin을 통하여 확인 할 수 있다. 따라서 Protocal, Host, Port 동일한 경우는 출처가 동일하다고 볼 수 있다.       1-1. CORS가 왜 필요한가?          보안상의 이유로 자바스크립트 엔진 표준 스펙에는 동일 출처 정책(Same-Origin Policy)이 포함되어있다. (만약 다른 서버의 내용까지 읽을 수 있게된다면, 사용자의 키보드 입력을 가로채는 스크립트를 다른 페이지에 심을 수도 있으므로 보안 이슈가 발생할 수 있다.)       하지만 우리는 양질의 웹페이지 개발을 하기 위해서는 타 오리진의 리소스가 필요하다.        (Ex. 기상청, 아큐웨더, 웨더채널의 API를 가져오는 네이버날씨)            이러한 이유들로 타 오리진의 리소스를 필요로 하는 경우가 생겨났으며, 특정 규약을 통해서 보안에 위배되지 않게 리소스를 공유하는 방법이 CORS이다.       1-2. CORS 동작 원리          CORS의 동작 원리는 세종류가 있다. 두가지 내용만 우선 언급하자면 서버에게 바로 본 요청을 직접 보내는 방법인 Simple request,              그리고 서버에 예비 요청을 보내서 안전한지 판단한 후 본 요청을 보내는 방법인 Preflight request이 있다.                   자세한 내용은 MDN CORS 접근 제어 시나리오 예제를 참조하자. 참조 : MDN       2. Mini Node Server (http모듈)          node.js의 http모듈 혹은 Express를 이용하여 웹 서버를 만드는 예제이다.       우선 http모듈은 HTTP 요청, 응답을 다룬다. HTTP 지식이 선행되어야 했기 때문에 먼저 HTTP 트랜잭션 해부공식 문서를 언급하고 넘어가야했다.       2-1. HTTP 트랜잭션 해부     우선 node.js HTTP 처리 과정을 공식문서를 참고로 학습하였다.           서버 생성  : 모든 node 웹 서버 애플리케이션은 웹 서버 객체를 만들어야 한다. 이 때 createServer를 이용한다.          const http = require('http'); \t      const server = http.createServer((request, response) =&gt; {      // 여기서 작업이 진행됩니다!    });           이 서버로 오는 HTTP 요청마다 createServer에 전달된 함수가 한 번씩 호출된다. HTTP 요청이 서버에 오면 node가 트랜잭션을 다루려고 request와 response 객체를 전달하며 요청 핸들러 함수를 호출한다. 요청을 실제로 처리하려면 listen 메서드가 server 객체에서 호출되어야 한다.       대부분은 서버가 사용하고자 하는 포트 번호를 listen에 전달하기만 하면 된다.       메서드, URL, 헤더 : 요청을 처리할 때, 메서드와 URL을 확인한 후 이와 관련된 적절한 작업을 실행해야 한다. Node가 request 객체에 유용한 프로퍼티를 넣어두었으므로 구조분해 할당으로 해당 값들을 쉽게 가져올 수 있다.        const { method, url } = request;          여기서 method는 항상 일반적인 HTTP 메서드/동사이며 url은 전체 URL에서 서버, 프로토콜, 포트를 제외한 나머지이다.       헤더도 많이 다르지 않다. request에 headers라는 전용 객체가 있으므로, 해당 프로퍼티를 사용한다.       const { headers } = request;  const userAgent = headers['user-agent'];           request에 headers라는 전용 객체가 있고, 클라이언트가 어떻게 헤더를 설정했는지에 관계없이 모든 헤더는 소문자로만 표현된다는 것을 기억하자. 이는 어떤 목적이든 헤더를 파싱하는 작업을 간편하게 해준다.            요청 바디 : POST나 PUT 요청을 받을 때 애플리케이션에 요청 바디는 중요할 것이다. 핸들러에 전달된 request 객체는 ReadableStream 인터페이스를 구현하고 있는데, 이 스트림의 'data'와 'end' 이벤트에 이벤트 리스너를 등록해서 데이터를 받을 수 있다.       각 'data' 이벤트에서 발생시킨 청크는 Buffer이다. 이 청크는 문자열 데이터이므로 이 데이터를 배열에 담고, 'end' 이벤트에서 이어 붙인 다음 문자열로 만드는 것이 가장 좋다.        let body = [];  request.on('data', (chunk) =&gt; {    body.push(chunk);  }).on('end', () =&gt; {    body = Buffer.concat(body).toString();    // 여기서 `body`에 전체 요청 바디가 문자열로 담겨있습니다.  });           2-2. Mini Node Server 구현          위 공식 문서를 토대로 작성하였다.       const http = require(\"http\"); const PORT = 5000; const ip = \"localhost\";  const server = http.createServer((request, response) =&gt; { if (request.method === \"OPTIONS\") { // CORS preflight request에 대한 응답   response.writeHead(200, defaultCorsHeader);   response.end(); } if (request.method === \"POST\") {   let body = [];    request     .on(\"data\", (chunk) =&gt; {       body.push(chunk);  // 요청바디. body 배열에 chunk를 push     })     .on(\"end\", () =&gt; {       body = Buffer.concat(body).toString();  // end 이벤트에서 이어 붙힌 뒤 문자열로 변환한다.       response.writeHead(201, defaultCorsHeader);        if (request.url === \"/lower\") {  // POST 메소드 Endpoint /lower에 따른 조건분기          response.end(body.toLowerCase());       } else if (request.url === \"/upper\") {         response.end(body.toUpperCase());       } else {       }     }); }  server.listen(PORT, ip, () =&gt; {  // 서버를 활성화하고 포트번호는 PORT(5000)로 아이피는 ip(localhost)로 받는다.   console.log(`http server listen on ${ip}:${PORT}`); });  const defaultCorsHeader = {  // CORS 응답헤더   \"Access-Control-Allow-Origin\": \"*\",   \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",   \"Access-Control-Allow-Headers\": \"Content-Type, Accept\",   \"Access-Control-Max-Age\": 10, };           3. Mini Node Server (프레임워크 Express)     Express.js는 Node.js 환경에서 웹 서버, 또는 API 서버를 제작하기 위해 사용되는 인기 있는 프레임워크이다.        위에서 Mini Node Server에서 http 모듈로 작성했던 서버를, 프레임워크 Express를 이용하는 방식으로 리팩토링하면 다음과 같다.       const express = require('express'); // express 모듈을 불러온다. const cors = require('cors');  // cors 미들웨어를 불러온다.    const app = express(); // 서버 app.use(cors());  // OPTIONS, 모든 요청에 대해 CORS 허용 app.use(express.json({strict: false}));  // 기본형은 true로 원시 자료형을 취급하지 않는다. false값을 줘서 원시자료형도 parsing 해주게끔 설정    const PORT = 5000; const ip = \"localhost\";    app.post('/upper', function(request, response){   response.json(request.body.toUpperCase()); })    app.post('/lower', function(request, response){   response.json(request.body.toLowerCase()); })    app.listen(PORT, () =&gt; {   console.log(`http server listen on ${ip}:${PORT}`); })           3-1. Express로 구현한 서버와 http 모듈로 작성돤 서버의 다른 점          미들웨어 추가가 편리하다 :  위 예제는  npm install cors 로 미들웨어 설치 후 사용만 해주면 되기에 편리하게 cors옵션을 설정할 수 있다.        const express = require('express');  const cors = require('cors');  const app = express();       app.use(cors());           위 내용만으로 모든 cross-origin 요청에 대해 응답한다. 만약 특정 도메인 요청만 받거나, 특정 요청에만 응답하는 경우 그에 따른 옵션을 설정해야한다.        const options = {    origin: '*', // 접근 권한을 부여하는 도메인    credentials: true, // 응답 헤더에 Access-Control-Allow-Credentials 추가    methods: 'GET, POST, OPTIONS'  // 메소드 접근 권한 부여  };  app.use(cors(options));                자체 라우터를 제공한다 :  자세한 설명은 참조링크로 대체.             오늘 느낀 점     CORS(교차 출처 리소스 공유)는 아직 공부할 영역이 많이 남은 느낌이다…   http 모듈을 이용한 서버 구현과 express.js를 이용한 서버에 대해서는 구조는 감을 잡았다. 조금더 많은 경우를 접해봐야 확실히 쓸 수 있을 듯하다. (아직 express에서의 cors 옵션 부분은 낯설다.)         내일 할 일     [React] 컴포넌트 디자인  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.10.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 15. primePassword",
        "excerpt":"  TOY 15. primePassword  문제   다음의 조건을 만족하면서 현재의 비밀번호(‘curPwd’)를 새 비밀번호(newPwd)로 변경하는 데 필요한 최소 동작의 수를 리턴해야 합니다.      한 번에 한 개의 숫자만 변경가능하다.   4자리의 소수(prime)인 비밀번호로만 변경가능하다.   정리하면, 비밀번호가 계속 소수를 유지하도록 숫자 한 개씩을 바꿔갈 때 현재 비밀번호에서 새 비밀번호로 바꾸는 데 최소 몇 개의 숫자를 변경해야 하는지를 리턴해야 합니다.   입력   인자 1 : curPwd     number 타입의 1,000 이상 9,999 이하의 자연수   인자 2 : newPwd     number 타입의 1,000 이상 9,999 이하의 자연수   출력      number 타입을 리턴해야 합니다.   주의사항      4자리인 소수는 1,000 이상의 소수를 말합니다.(0011, 0997 등은 제외)   입출력 예시   let output = primePassword(1033, 1033); console.log(output); // --&gt; 0  output = primePassword(3733, 8779); console.log(output); // --&gt; 3 (3733 -&gt; 3739 -&gt; 3779 -&gt; 8779)   TOY 15. Solution  수도코드   문제해결까지 생각이 닿질않아 레퍼런스 코드를 참고하였다.   우선 필요한 과정을 열거하자면..      DFS 방식으로 광범위한 경우의 수 탐색 (모든 경우의 수를 탐색한다. 경우의 수는 10^4)   중복 탐색을 방지하기 위한 방문여부 check 배열로 중복 탐색 방지 (10000개의 인덱스 default 설정)   첫 시작은 curPwd로 시작 queue에 [step(숫자 바뀐 횟수) 초기값은 0, curPwd] 를 enqueue한다. &gt; queue=[[0,curPwd]]   queue에 담긴 값을 꺼내어 step = queue[...][0], num = queue[...][1]을 할당해준다.   4자리 수의 수를 각 자리수 각 자리수마다 숫자를 0~9까지 하나씩 바꿔가며(현재 자리수와 같은수 제외) 탐색  한다. (탐색에 용이하게 각 자리수를 배열로 나누고, 다시 모든 자리수를 문자열로 합치는 함수 선언하여 사용 ) 코드 간결화를 위해 사용한다   만약 바뀐 Pwd가 newPwd와 같다면 현재의 step+1 을 리턴해주고 탐색은 종료된다   newPwd와 같지않으면서 1,000보다 크고 9999보다 작으며, 소수인 숫자중 방문된 적이 없는 num은 step+1과 함께 enqueue 한다.  &gt; queue=[…queue, [step+1, num]]   4~8번 과정을 큐가 비워질때까지 반복한다   문제풀이   // 수도코드와 Reference Code 주석 참조  Reference Code   const isPrime = (num) =&gt; { // 소수 check   if (num % 2 === 0) return false;    let sqrt = parseInt(Math.sqrt(num)); // 효율적인 계산을 위해 거듭제곤까지 check   for (let divider = 3; divider &lt;= sqrt; divider += 2) {     if (num % divider === 0) {       return false;     }   }   return true; };  // 4자리 수를 받아서 각 자리수의 수들의 배열로 변환하는 함수 //  let output = splitNum(3359); //  console.log(output); // --&gt; [3, 3, 5, 9] const splitNum = (num) =&gt; {   const digits = num.toString().split('');   return digits.map((d) =&gt; Number(d)); };  // 배열을 받아서, 4자리의 수로 변환하는 함수 // let output = splitNum([3, 3, 5, 9]); // console.log(output); // --&gt; 3359 const joinDigits = (digits) =&gt; Number(digits.join(''));  const primePassword = (curPwd, newPwd) =&gt; {   if (curPwd === newPwd) return 0;    // bfs를 위해 queue를 선언   let front = 0;   let rear = 0;   const queue = [];   const isEmpty = (queue) =&gt; front === rear;   const enQueue = (queue, item) =&gt; {     queue.push(item);     rear++;   };   const deQueue = (queue) =&gt; {     return queue[front++];     // const item = queue[front];     // front++;     // return item;   };    // 각 4자리의 방문 여부를 저장하는 배열   // 한 번 방문한 수(가장 최소의 동작으로 만든 수)는 다시 방문할 필요가 없다.   const isVisited = Array(10000).fill(false);      // bfs를 위한 시작점   // 큐에는 [필요한 동작 수, 비밀번호]가 저장된다.   isVisited[curPwd] = true;  // 현재 비밀번호 방문 check   enQueue(queue, [0, curPwd]);  // 현재 비밀번호 부터 시작    while (isEmpty(queue) === false) { // bfs는 큐가 빌(empty) 때까지 탐색한다.     const [step, num] = deQueue(queue);      // 각 자리수 마다 변경이 가능하므로 4번의 반복이 필요하다.     for (let i = 0; i &lt; 4; i++) {       const digits = splitNum(num);              for (let d = 0; d &lt; 10; d++) { // 0부터 9까지 시도한다.         if (d !== digits[i]) { // 각 자리수마다 원래 있던 수(digits[i])는 피해야 한다.           digits[i] = d; // 현재 자리수의 수를 변경하고,           const next = joinDigits(digits); // 변경한 후 4자리 수를 구한다.                      // 만약 이 수가 새 비밀번호와 같다면 리턴한다.           // next는 deQueue된 num으로부터 1단계 다음에 도달한 수이다.           if (next === newPwd) return step + 1;                      // 1,000보다 큰 소수여야 하고, 방문된 적이 없어야 한다.           if (next &gt; 1000 &amp;&amp; isPrime(next) &amp;&amp; isVisited[next] === false) {             // 방문 여부를 표시하고,             isVisited[next] = true;             // 큐에 넣는다.             enQueue(queue, [step + 1, next]);           }         }       }     }   }    // 큐가 빌 때까지, 즉 모든 경우의 수를 탐색할 때까지 리턴되지 않은 경우   // 현재 비밀번호에서 새 비밀번호를 만들 수 없다.   return -1; };  오늘 느낀 점  전혀 감을 못잡았다.. Reference Code를 보고 해석하는 정도도 겨우 소화해낸듯 싶다.   모든 경우의 수 탐색후 조건에 맞는 후보(1000 이상, 소수)들을 숫자를 바꾼 횟수 step과 조건에 부합하는 숫자 num을 큐 자료구조에 enqueue 하여 관리하며, 최종 newPwd 까지 몇회의 숫자바꿈으로 처리되는지 탐색하는 알고리즘이다.  현재보다 작은 패스워드들도 모두 check 하기 때문에 예외 경우도 모두 부합하는 결과를 얻을 수 있었다.   알고리즘도 어려웠기에 인상깊었지만, 함수를 작은 기능별로 쪼개는 모듈화도 인상깊히 학습하였다.   내일 할 일     TOY 16. quickSort  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.13.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 16. quickSort",
        "excerpt":"  TOY 16. primePassword  문제   정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 배열   arr[i]는 정수   arr.length는 100,000 이하     출력            number 타입을 요소로 갖는 배열을 리턴해야 합니다.   배열의 요소는 오름차순으로 정렬되어야 합니다.   arr[i] &lt;= arr[j] (i &lt; j)   주의사항      퀵 정렬을 구현해야 합니다.   arr.sort 사용은 금지됩니다.   입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   입출력 예시   let output = quickSort([3, 1, 21]); console.log(output); // --&gt; [1, 3, 21]   Advanced      quickSort 함수의 두 번째 인자로 callback 함수를 받아서, 그 함수의 리턴값을 기준으로 요소들을 정렬해 보세요.   TOY 16. Solution  수도코드      퀵정렬의 개념은 구글링을 통해 잡았다. 뭔놈의 정렬 알고리즘이 이리 다양한지…      arr[0] 을 최초 기준점으로 left, right 두 배열에 대소 비교하여 arr 요소 push   arr을 순회하며 완성된 left 와 right 배열 기준으로 다시 재귀 호출   arr 이 더이상 정렬할게 없을때 (길이가 2 미만으로 내려갔다면) 재귀 호출 종료   정렬이 완료된 배열을 ... 스프레드 연산자 혹은 concat으로 풀어서 한 배열로 붙여서 리턴하여 함수 종료   메모리 관리가 효율적인 Advanced 알고리즘은 Reference Code 를 참조하였다.  문제풀이   const quickSort = function (arr) {   // TODO: 여기에 코드를 작성합니다.   if(arr.length &lt; 2) return arr; // 재귀함수의 탈출 조건, 길이가 2보다 작다면 더이상 정렬할게 없다.      let pivot = arr[0]; // pivot   let left = []; // pivot 보다 작은 수가 담길 배열   let right = []; // pivot 보다 큰 수가 담길 배열    for(let i = 1; i &lt; arr.length; i++){ //pivot 제외한 arr 요소 조회     if(arr[i] &lt; pivot){ // pivot과 비교하여 left, right로 분류       left.push(arr[i])     } else if(arr[i] &gt; pivot){       right.push(arr[i])     }   }    // 재귀를 통해서 정렬 -&gt; 한 배열로 붙여서 return   return [...quickSort(left), pivot, ...quickSort(right)] };  Reference Code   // naive solution // const quickSort = function (arr) { //   if (arr.length &lt;= 1) return arr;  //   const pivot = arr[0]; //   const left = []; //   const right = [];  //   for (let i = 1; i &lt; arr.length; i++) { //     if (arr[i] &lt;= pivot) left.push(arr[i]); //     else right.push(arr[i]); //   }  //   const lSorted = quickSort(left); //   const rSorted = quickSort(right); //   return [...lSorted, pivot, ...rSorted]; // };  function quickSort(arr, transform = (item) =&gt; item) {   if (arr.length &lt;= 1) return arr;    const pivot = arr[0];   const left = [];   const right = [];    for (let i = 1; i &lt; arr.length; i++) {     if (transform(arr[i]) &lt; transform(pivot)) left.push(arr[i]);     else right.push(arr[i]);   }    const lSorted = quickSort(left, transform);   const rSorted = quickSort(right, transform);   return [...lSorted, pivot, ...rSorted]; }  오늘 느낀 점  효율적인 메모리를 위한 알고리즘에서는 더이상 진전이 없었다… 레퍼런스 코드가 왜 저렇게 구현되는지 잘 와닿지 않는다.   TOY13번에서 개념을 잡지않고 우선 넘어갔는데 같은 유형의 문제가 다시 나왔다… 우선 무조건 공부하고 짚고넘어가야 할 듯해서 찾아본 결과, 꼬리재귀를 공부해야 해당 부분을 깊게 이해 할 수 있다는 점 정도만 감을 잡았다. 재귀 스택이 쌓이는 과정에서의 오버헤드… 를 해결하는 알고리즘인듯하다.      함수를 재귀적으로 호출하여 문제를 해결하는 방식은 코드를 간결하고 의도를 파악하기 쉽게 작성할 수 있는 장점이 있다. 하지만 재귀함수의 콜스택이 깊어 질수록 메모리 오버헤드가 발생하는 단점도 있다. 이 문제를 해결하기 위한 재귀 호출 방식을 꼬리 재귀라고 부른다. 간단하게 정의하자면 재귀함수의 실행 결과가 연산에 사용되지 않고 바로 반환되게 함으로써 이전 함수의 상태를 유지할 필요가 없도록 재귀 함수를 작성하는 것이다.    시간이 늦어 오늘은 sort() 내장 메서드를 사용하지 않는 기본 알고리즘만 해결하고, 주말 추석 연휴중으로 꼬리재귀 에 대해서 학습해 볼 예정이다.   내일 할 일     TOY 17. balancedBracket  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.14.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 17. balancedBrackets",
        "excerpt":"  TOY 17. balancedBrackets  문제   문자열을 입력받아 문자열 내의 모든 괄호의 짝이 맞는지 여부를 리턴해야 합니다.      다음 단계에 맞춰 함수를 작성해 보세요            괄호의 종류를 단 한가지로 한정합니다.       괄호의 종류를 늘려 모든 종류의 괄호에도 작동하도록 합니다.       괄호를 제외한 문자열이 포함된 경우에도 작동하도록 합니다.           입력   인자 1 : str     string 타입의 괄호가 포함된 문자열   출력      boolean 타입을 리턴해야 합니다.   주의사항      괄호의 종류는 (, )만 고려합니다.   괄호는 먼저 열리고((), 열린만큼만 닫혀야()) 합니다.   빈 문자열을 입력받은 경우, true를 리턴해야 합니다.   입출력 예시   let output = balancedBrackets('('); console.log(output); // // -&gt; false  output = balancedBrackets('()'); console.log(output); // --&gt; true   Advanced      모든 종류의 괄호((, ), {, }, [, ])가 포함된 문자열을 입력빋아 모든 괄호의 짝이 맞는지 여부를 리턴해 보세요.   let output = balancedBrackets('[](){}'); console.log(output); // --&gt; true  output = balancedBrackets('[({})]'); console.log(output); // --&gt; true  let output3 = balancedBrackets('[(]{)}'); console.log(output); // --&gt; false   TOY 17. Solution  수도코드      스택 자료구조를 이용하여 괄호를 쌓아가며, 쌍이 맞는 괄호가 나오면 위에서 부터 꺼내는 알고리즘을 구현해보았다.      괄호로 구성된 문자열을 배열로 변환하여 반복문으로 해당 배열을 순회한다.   시작부터 닫는 괄호가 나온다면 무조건 괄호 쌍이 일치하지 않으므로 false를 리턴한다.   (, {, [ 여는 괄호가 나올 경우에는 stack 배열에 값을 넣어준다.   닫는 괄호가 나오는 경우 stack 배열의 최상단의 값과 일치하는 괄호가 있는지 검사 -&gt; 일치한다면 기존 stack배열에 쌓인 쌍이 되는 여는 괄호를 빼준다.   반복문이 종료된 후 stack배열이 비어있다면 괄호 쌍이 일치하므로 true를 리턴한다.     문제풀이            1. bare minimum   const balancedBrackets = function (str) {   // TODO: 여기에 코드를 작성합니다.   const strArr = str.split('');   let stack = [];      for(let el of strArr){     if(el === '('){  // 여는 괄호가 나온다면 stack 배열에 값을 넣는다       stack.push(el);     } else {  // 닫는 괄호가 나온다면,       if(stack.length === 0) return false;  // 닫는 괄호 + stack 의 길이가 0. 즉, 첫 시작부터 닫는 괄호가 나온다면 false 리턴        \t\t\tif(stack[stack.length-1] === '('){  // 닫는 괄호 + stack의 마지막 인덱스가 여는 괄호라면 stack의 값을 뺀다.         stack.pop();       }     }   }    return stack.length &gt; 0 ? false : true;  // stack 배열이 비어있다면, 괄호 쌍이 일치하므로 true 리턴. };   2. advanced   const balancedBrackets = function (str) {   // TODO: 여기에 코드를 작성합니다.   const array = str.split('');   let stack = [];    for (let el of array) {     if (el === '{' || el === '[' || el === '(') {  // 여는 괄호가 나온다면 stack 배열에 값을 넣는다       stack.push(el);     } else {  // 닫는 괄호가 나온다면,       if (stack.length === 0) return false;  // 닫는 괄호 + stack 의 길이가 0. 즉, 첫 시작부터 닫는 괄호가 나온다면 false 리턴        // 닫는 괄호 + stack의 마지막 인덱스가 쌍이 맞는 여는 괄호라면 stack의 값을 뺀다.         if (el === '}' &amp;&amp; stack[stack.length - 1] === '{') {           stack.pop();       } else if (el === ']' &amp;&amp; stack[stack.length - 1] === '[') {         stack.pop();       } else if (el === ')' &amp;&amp; stack[stack.length - 1] === '(') {         stack.pop();       }     }   }    return stack.length &gt; 0 ? false : true; // stack 배열이 비어있다면, 괄호 쌍이 일치하므로 true 리턴. };  Reference Code   // naive solution // const balancedBrackets = function (str) { //   const stack = []; //   const opener = '('; //   const closer = ')';  //   for (let i = 0; i &lt; str.length; i++) { //     if (str[i] === opener) { //       stack.push(str[i]); //     } else if (str[i] === closer) { //       const top = stack.pop(); //       if (top !== opener) { //         return false; //       } //     } //   }  //   return stack.length === 0; // };  const balancedBrackets = function (str) {   const stack = [];   const opener = {     '{': '}',     '[': ']',     '(': ')',   };   const closer = '}])';    for (let i = 0; i &lt; str.length; i++) {     if (str[i] in opener) {       stack.push(str[i]);     } else if (closer.includes(str[i])) {       const top = stack.pop();       const pair = opener[top];       if (pair !== str[i]) {         return false;       }     }   }    return stack.length === 0; };  오늘 느낀 점  오늘 TOY 문제는 어렵지않았다. 다만 Reference Code 처럼 간결하진 않지만…   여는 괄호를 opener 객체로 분류하여 키와 값 쌍으로 결과를 도출해내는 과정이 코드가 멋스러웠다…  참조할만한 코드라 생각되어 다시 풀어볼 예정이다.   오늘 스터디중 동기분이 보여주신 코드가 신기해서 가져와보았다. reduce()를 활용해 누산기를 스택으로 활용하는 알고리즘인데 아직 이해가 안간다.. reduce() 아직 생소해…  해당 내용도 알아두면 좋을듯해서 우선 가져와보았다. TOY 문제 다시 풀때 참고해봐야겠다.   const balancedBrackets = function (str) {   // TODO: 여기에 코드를 작성합니다.   let bList = { \"(\" : \")\", \"{\" : \"}\", \"[\" : \"]\" } // 짝에 맞추어 키와 값으로 객체    let stack = str.split('').reduce(function(ac, cv) { // str을 스플릿해 한글자씩 reduce함수를 돌린다     if (cv === bList[ac[ac.length - 1]]) { // ac를 스택으로 사용       ac.pop();     } else {       ac.push(cv);     }     return ac;   }, []);    return stack.length === 0 // 스택에 남아 있는 요소가 없다면 짝이 맞는! };   내일 할 일     TOY 18. getItemFromTwoSortedArrays  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.15.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. CDD 2. CSS in JS 방법론 3. React Custom Component",
        "excerpt":"   No class name bugs :      Today I Learnd      1. Component Driven Development (CDD)            부품 단위로 UI 컴포넌트를 만들어 나가는 개발이다.  페이지 단위로 UI 개발이 이루어지는 것과는 반대로 UI 컴포넌트들부터 만들고 이를 기반으로 페이지를 구성하는걸 말한다.              Storybook 같은 UI 컴포넌트 익스플러어 툴을 통해 체계적으로 관리, 개발자들간 쉽게 소통할 수 있는 장점이 있다.        2. CSS in JS 방법론   2-1. 구조적인 CSS 작성 방법의 발전          CSS 작성 방식도 꾸준히 진화해 오고 있다.              프로젝트의 규모나 복잡도가 점점 커지고 함께 작업해야할 팀원 수도 많아짐에 따라 CSS를 작성하는 일관된 패턴이 없다는 것은 개발자들에게 가장 큰 걸림돌이 되었다. 또한 모바일이나 태블릿을 비롯한 다양한 디바이스들의 등장으로 웹사이트들이 다양한 디스플레이를 커버해야 하기 때문에 CSS는 더 복잡해지게 되었다. 따라서 CSS 작업을 효율적으로 하기 위해 구조화된 CSS의 필요성이 대두되었다.       이러한 문제점들을 해결하기 위해 CSS 전처리기(CSS Preprocessor)라는 개념이 등장했다. CSS 전처리기(CSS Preprocessor)란 CSS가 구조적으로 작성될 수 있게 도움을 주는 도구이다.        CSS 전처리기 중에서 가장 유명한 SASS(Syntactically Awesome Style Sheets)는 CSS를 확장해 주는 스크립팅 언어이다.              자바스크립트처럼 특정 속성(ex. color, margin, width 등)의 값(ex. #ffffff, 25rem, 100px 등)을 변수로 선언하여 필요한 곳에 선언된 변수를 적용할 수도 있고, 반복되는 코드를 한번의 선언으로 여러 곳에서 재사용할 수 있도록 해 주는 등의 기능을 가졌다.       하지만 얼마 지나지 않아서 SASS가 ‘CSS의 구조화’를 해결해 주는 것의 장점보다 다른 단점들이 부각되며, BEM(Block, Element, Modifier로 구분하여 클래스명을 작성하는 방법론), OOCSS(Object Oriented CSS 중복을 최소화 하고 캡슐화를 원칙으로 하는 방법론), SMACSS(Scalable Modular Architecture CSS 범주화(categorization)로 패턴화 하고자 하는 방법론) 같은 새로운 CSS 방법론이 대두되었다. 각각의 장단점이 있으나 결국 세 방법론 모두 같은 지향점을 가지고 있다.            코드의 재사용       코드의 간결화(유지보수 용이)       코드의 확장성       코드의 예측성(클래스 명으로 의미 예측)           하지만 이러한 방법론들에서도 문제점이 발생하기 시작한다. 클래스명 선택자가 장황해지고, 이런 긴 클래스명 때문에 마크업이 불필요하게 커지며, 재사용하려고 할 때마다 모든 UI 컴포넌트를 명시적으로 확장해야만 했다.            어플리케이션으로 개발 방향이 진화하면서 컴포넌트 단위의 개발은 캡슐화의 중요성을 불러왔다.       하지만 CSS는 컴포넌트 기반의 방식을 위해 만들어진 적이 한번도 없었다는 문제점이 있었다. 이러한 문제를 해결하기 위해 CSS도 컴포넌트 영역으로 불러들여야했고, 이러한 문제해결을 위해 CSS-in-JS가 탄생해서 이 문제를 정확하게 해결하였다. 대표적인 CSS-in-JS에는 Styled-Component가 있다.        2-2. Styled-Component     CSS-in-JS 관련 React 라이브러리 중에서 가장 인기 있는 Styled Component는 React 의 컴포넌트 기반 개발 환경에서 스타일링을 위한 CSS의 성능 향상을 위해 탄생하였다. 특징은 아래와 같다.            Automatic critical CSS : Styled Component 는 화면에 어떤 컴포넌트가 렌더링 되었는지 추적해서 해당하는 컴포넌트에 대한 스타일을 자동으로 삽입한다. 따라서 코드를 적절히 분배해 놓으면 사용자가 어플리케이션을 사용할 때 최소한의 코드만으로 화면이 띄워지도록 할 수 있다.       No class name bugs : Styled Component 는 스스로 유니크한 className 을 생성한다. 이는 className 의 중복이나 오타로 인한 버그를 줄여준다.       Easier deletion of CSS : 기존에는 더 이상 사용하지 않거나 삭제한 컴포넌트에 해당하는 스타일 속성을 제거하기위해 CSS 파일 안의 className을 이리저리 찾아야 했었다. 하지만 Styled Component 는 모든 스타일 속성이 특정 컴포넌트와 연결되어 있기 때문에 만약 컴포넌트를 더 이상 사용하지 않아 삭제할 경우 이에 대한 스타일 속성도 함께 삭제된다.       Simple dynamic styling : className을 일일이 수동으로 관리할 필요 없이 React 의 props 나 전역 속성을 기반으로 컴포넌트에 스타일 속성을 부여하기 때문에 간단하고 직관적이다.       Painless maintenance : 컴포넌트에 스타일을 상속하는 속성을 찾아 다른 CSS 파일들을 검색하지 않아도 되기 때문에 코드의 크기가 커지더라도 유지보수가 어렵지 않다.       Automatic vendor prefixing : 개별 컴포넌트마다 기존의 CSS 를 이용하여 스타일 속성을 정의하면 될 뿐이다. 이외의 것들은 Styled Component 가 알아서 처리한다.            3. React Custom Component. 참조 : Github         오늘 느낀 점     CSS 어렵다…  오늘 실습은 React 기술적인 구현은 어렵지 않았지만 CSS를 다루는게 아직 쉽지않다. 정답이 없는 느낌?         내일 할 일     [React] 상태 관리  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.15.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 18. getItemFromTwoSortedArrays (작성중)",
        "excerpt":"  TOY 18. getItemFromTwoSortedArrays  문제   길이가 m, n이고 오름차순으로 정렬되어 있는 자연수 배열들을 입력받아 전체 요소 중 k번째 요소를 리턴해야 합니다.   입력   인자 1 : arr1     자연수를 요소로 갖는 배열   arr1.length는 m     인자 2 : arr2       자연수를 요소로 갖는 배열   arr2.length는 n     인자 3 : k       number 타입의 0 이상의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      두 배열의 길이의 합은 1,000,000 이하입니다.   어떤 배열 arr의 k번째 요소는 arr[k-1]을 의미합니다.   입출력 예시   let arr1 = [1, 4, 8, 10]; let arr2 = [2, 3, 5, 9]; let result = getItemFromTwoSortedArrays(arr1, arr2, 6); console.log(result); // --&gt; 8  arr1 = [1, 1, 2, 10]; arr2 = [3, 3]; result = getItemFromTwoSortedArrays(arr1, arr2, 4); console.log(result); // --&gt; 3   Advanced      단순히 처음부터 끝까지 찾아보는 방법(O(K)) 대신 다른 방법(O(logK))을 탐구해 보세요.   힌트      이진 탐색(binary search)을 응용하여 해결합니다.   TOY 18. Solution  수도코드   만약 시간복잡도를 고려하지 않는 문제라면 난이도 0.1 … 이런 걸 의도하진 않겠지…   우선 Advanced 조건인 시간복잡도가 (O(logK)) 되기 위해서는 1번의 검색 수행마다 경우의 수가 절반으로 줄어야 한다.   문제풀이    1. bare minimum   const getItemFromTwoSortedArrays = function (arr1, arr2, k) {   // TODO: 여기에 코드를 작성합니다.      let newArr = arr1.concat(arr2)   let result = newArr.sort(function(a,b) {     return a-b;   })      return result[k-1]; };  시간복잡도를 전혀 고려하지 않았다…  2. advanced     Reference Code   // naive solution // const getItemFromTwoSortedArrays = function (arr1, arr2, k) { //   let cnt = 0, //     left = 0, //     right = 0; //   let target; //   while (cnt &lt; k) { //     if (arr1[left] &lt; arr2[right]) { //       target = arr1[left]; //       left++; //     } else { //       target = arr2[right]; //       right++; //     } //     cnt++; //   } //   return target; // };  // O(logK) solution const getItemFromTwoSortedArrays = function (arr1, arr2, k) {   let leftIdx = 0,     rightIdx = 0;    while (k &gt; 0) {     // 이진 탐색을 위해 각 배열에서 k를 절반으로 쪼개서 카운트 한다.     let cnt = Math.ceil(k / 2);     let leftStep = cnt,       rightStep = cnt;      // 엣지 케이스     // 카운트가 남았음에도 배열의 끝에 도달하면 k를 나머지 배열쪽으로 넘긴다.     if (leftIdx === arr1.length) {       rightIdx = rightIdx + k;       break;     }      if (rightIdx === arr2.length) {       leftIdx = leftIdx + k;       break;     }      // 엣지 케이스     // 현재 카운트가 남아있는 후보 요소들보다 많을 경우, leftStep(현재 할당량)을 남아있는 요소들의 개수로 바꾼다.     if (cnt &gt; arr1.length - leftIdx) leftStep = arr1.length - leftIdx;     if (cnt &gt; arr2.length - rightIdx) rightStep = arr2.length - rightIdx;      // 두 배열의 현재 검사 요소 위치를 비교해서, 그 값이 작은 배열은 비교한 위치 앞에 있는 요소들을 모두 후보군에서 제외시킨다.     if (arr1[leftIdx + leftStep - 1] &lt; arr2[rightIdx + rightStep - 1]) {       leftIdx = leftIdx + leftStep;       // 처리가 끝나면 k값을 절반으로 떨어뜨린다.       k = k - leftStep;     } else {       rightIdx = rightIdx + rightStep;       k = k - rightStep;     }   }    leftMax = arr1[leftIdx - 1] || -1;   rightMax = arr2[rightIdx - 1] || -1;    return Math.max(leftMax, rightMax); };  오늘 느낀 점   내일 할 일     TOY 19. LPS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.17.algorithm1/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 19. LPS (작성중)",
        "excerpt":"  TOY 19. LPS  문제   문자열을 입력받아 다음의 조건을 만족하는 LPS*를 찾아 그 길이를 리턴해야 합니다.      LPS: 주어진 문자열의 가장 긴 접두어이자 접미어(Longest Prefix which is also Suffix)   non-overlapping: 접두어와 접미어는 서로 겹치는 부분이 없어야 합니다. 다시 말해, prefix와 suffix는 문자열의 동일한 인덱스에 위치한 문자를 요소로 가지면 안 됩니다.   입력   인자 1 : str     string 타입의 임의의 알파벳 소문자 문자열   str.length는 60,000 이하   출력      number 타입을 리턴해야 합니다.   주의사항      prefix(접두어)는 문자열의 첫 인덱스부터 시작하는 모든 부분 문자열을 의미합니다.   suffix(접미어)는 문자열의 마지막 인덱스부터 시작하는 모든 부분 문자열을 의미합니다.   입출력 예시   let output = LPS('abbbcc'); console.log(output); // --&gt; 0  output = LPS('aaaa'); console.log(output); // --&gt; 2 // prefix: str.slice(0, 2) // suffix: str.slice(2) // non-overlapping 조건이 없는 경우 정답은 4 입니다.  output = LPS('aaaaa'); console.log(output); // --&gt; 2 // prefix: str.slice(0, 2) // suffix: str.slice(3) // non-overlapping 조건이 없는 경우 정답은 5 입니다.   Advanced      LPS를 계산하는 효율적인 알고리즘(O(N))이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.   정규식(regular expression)을 활용하면 아래처럼 간단하게 구현할 수 있습니다. 정규식에 대해서 학습하시기 바랍니다. (참고사이트)   const LPS = (str) =&gt; {   const result = str.match(/^(\\w*).*\\1$/);   return result[1].length; };   TOY 19. Solution  수도코드   사실 문제가 이해가 잘 안가서 몇번 다시 쳐다보았다.  손으로 써가며 이해한 바로는         문자열을 절반(짝수 경우 5:5로 쪼갤수있고, 홀수인 경우엔 알아서… 비는 문자열 없이 나눠준다.)으로 나눠준다.   쪼개진 prefix와 sufix 안의 내부 문자를 반복문을 통해 순회한다.   prefix는 0번 인덱스는 고정,prefix[prefix.length] 인덱스를 줄여가며 만들어진 새로운 문자열은 LPS 후보가 된다   sufix는 0번 인덱스부터 늘려가며 sufix[sufix.length]인덱스는 고정한 상태에서 만들어진 새로운 문자열은 LPS 후보가 된다.   반복문을 순회하며 새로 만들어진 두 문자열이 같아지면 반복문을 종료하고 현재 중복된 문자열의 길이를 반환한다.     문제풀이           ```javascript  const LPS = function (str) {   // TODO: 여기에 코드를 작성합니다.   let result = ‘’;       for (let i=0; i&lt;= str.length/2; i++) {     let prefix = str.slice(0, i);     let suffix = str.slice(str.length-i);   if (prefix===suffix) {   result=prefix; }   };   return result.length; };  ### Reference Code --- ```javascript // naive solution // const LPS3 = function (str) { //   if (str.length &lt; 2) return 0;  //   // 문자열을 두 부분으로 나누고 //   // 부분 문자열을 쉽게 구하기 위해 //   // 왼쪽 부분의 마지막 인덱스와 오른쪽 부분의 첫 인덱스를 저장  //   let halfSize = Math.floor(str.length / 2); //   // 문자열의 길이가 홀수일 수 있으므로, 올림한다. //   let rightStart = Math.ceil(str.length / 2);  //   // 가장 긴 LPS 후보부터 차례대로 검사한다 //   for (let offset = 0; offset &lt; halfSize; offset++) { //     let matched = true; //     for (let i = 0; i &lt; halfSize - offset; i++) { //       if (str[i] !== str[rightStart + offset + i]) { //         matched = false; //         break; //       } //     } //     if (matched) return halfSize - offset; //   }  //   // LPS가 없는 경우 //   return 0; // };  // naive solution2 // const LPS = function (str) { //   if (str.length &lt; 2) return 0;  //   // 문자열을 두 부분으로 나누고 //   // 각 부분의 첫 인덱스를 저장 //   let leftIdx = 0; //   // 문자열의 길이가 홀수일 수 있으므로, 올림한다. //   let rightIdx = Math.ceil(str.length / 2);  //   while (rightIdx &lt; str.length) { //     if (str[leftIdx] == str[rightIdx]) { //       // LPS 검사를 시작한 위치부터 지금까지 계속 같은 경우 //       // 다음 문자도 같은지 확인하기 위해 인덱스를 이동한다. //       leftIdx++; //       rightIdx++; //     } else { //       // leftIdx가 0인 경우, 단순히 rightIdx를 1 증가 (suffix의 시작점을 뒤로 한 칸 이동) //       // prefix, suffix가 계속 일치하다가 중간에서 일치하지 않는 경우에도, //       // 현재 suffix의 시작점을 뒤로 한 칸 이동한다. //       rightIdx = rightIdx - leftIdx + 1; //       leftIdx = 0; //     } //   }  //   // LPS가 없는 경우 //   return leftIdx; // };  // dynamic solution: O(N) // non-overlapping 조건을 제거하고 lps를 구한다. // lps는 주어진 문자열에서 아래 조건을 만족하는 가장 긴 접두어(prefix)의 길이를 의미한다. //  - 해당 접두어는 주어진 문자열의 접미어(suffix)이기도 하다. // 이때, 문자열 자기 자신은 그 자체로 prefix이자 suffix인데, 이는 고려 대상에서 제외한다. const LPS = function (str) {   // lps[i]는 0부터 i까지의 부분 문자열, 즉 str.slice(0, i + 1)에서 lps의 길이를 저장한다.   const lps = Array(str.length);   // lps[0]은 길이가 1인 문자열의 lps의 길이이므로 항상 0이다. (자기 자신 포함 금지)   lps[0] = 0;   let leftIdx = 0;   let rightIdx = 1;   // lps[i]를 1부터, 즉 문자열의 길이가 2일때부터 차례대로 구한다.   while (rightIdx &lt; str.length) {     if (str[leftIdx] === str[rightIdx] &amp;&amp; rightIdx &gt;= str.length / 2) {       // 가장 단순한 경우를 생각해보면, 쉽게 이해할 수 있다.       // 1) 길이가 2 경우       // 2) 길이가 3 이상인데 전부 같은 문자인 경우       // 0부터 leftIdx까지 매칭이 되었으므로 매칭된 길이는 leftIdx + 1이다.       leftIdx++;       lps[rightIdx] = leftIdx;       rightIdx++;     } else {       // 중간에 매칭이 되지 않은 경우, leftIdx를 조정한다.       // 현재 lps[0]부터 lps[rightIdx - 1]까지 계산이 완료된 상태이다.       // 처음부터 다시 prefix, suffix 매칭을 하는 것이 원칙이지만       // 앞서 계산한 결과인 lps 배열을 통해 처음으로 되돌아갈 필요는 없다.        // 예. aaabaaaa       // 현재 leftIdx는 2, rigthIdx는 3, lps는 [0, 1, 2]인 상태라고 가정해보자.       // leftIdx가 1일 때까지, 즉 현재 leftIdx 직전(leftIdx - 1)까지는 매칭이 되었다.       if (leftIdx !== 0) {         leftIdx = lps[leftIdx - 1];         // Also, note that we do         // not increment i here       } else {         // rightIdx가 1인 경우, 즉 첫 iteration일 경우         // lps[rightIdx]가 0인 것은 명백하다. (예. ab)         // leftIdx가 0이라는 것은 처음부터 prefix, suffix 매칭을 하는 경우이다.         //         // lps가 존재하지 않는 경우이다.         lps[rightIdx] = 0;         rightIdx++;       }     }   }   const res = lps[lps.length - 1];   return res &gt; str.length / 2 ? Math.floor(str.length / 2) : res; };  오늘 느낀 점   내일 할 일     TOY 19. LPS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.17.algorithm2/",
        "teaser": null
      },{
        "title": "[TIL] 1. React 상태관리 2. 클라이언트 빌드&배포",
        "excerpt":"  Today I Learnd  1. React 상태관리   1-1. 프론트엔드 개발에서의 상태 관리     우선 상태란 컴포넌트 내부에서 변화되는 값이다. 특별히 프론트엔드 영역에서는 “동적으로 표현되는 데이터”라 부를 수 있다.        우리는 컴포넌트 우선 개발 방식에 대해서 학습했었다 (21.09.07 TIL, React 데이터 흐름 참조) . 하향식 데이터 흐름에 따라 props를 이용해서 데이터를 전달하며 이는 단방향 데이터 흐름이다.       따라서 이 “상태”의 위치가 매우 중요하다. 우선 Javascript를 처음 배울 때 처럼 전역 변수와 지역 변수에 처럼 생각을 해보자.              로컬 상태는 특정 컴포넌트 안에서만 관리되는 상태이며, 전역 상태는 프로덕트 전체 혹은 여러가지 컴포넌트가 동시에 관리하는 상태이다.       로컬 상태를 구분하는 것은 간단하다. 보통 컴포넌트 내에서만 영향을 끼지는 상태는 로컬 상태를 뜻한다.  그럼 전역 상태는 다른 컴포넌트와 상태를 공유하고 영향을 끼치는 상태를 의미할 것이다.       전역 상태라는 말은 서로 다른 컴포넌트가 동일한 상태를 다룬다는 뜻이다. 만약 이러한 상황이라면, 이 출처는 오직 한 곳이어야 한다. 만일 사본이 있을 경우, 두 데이터는 서로 동기화(sync)하는 과정이 필요한데, 이는 문제를 어렵게 만들게 된다. 리액트에서는 한 곳의 컴포넌트에서만 상태를 저장하고 접근하는게 데이터를 효과적이고 효율적으로 관리하는 방식이다.       이를 다르게 말하자면 “데이터 무결성을 위해, 동일한 데이터는 항상 같은 곳에서 데이터를 가지고 오도록 해야만 한다” 이다. Single source of truth(신뢰할 수 있는 단일 출처) 원칙은 프론트엔드 뿐만 아니라 다양한 곳에서 언급되는 원칙이다.        1-2. 상태 관리를 위한 각종 툴             상태 관리에 대해 전반적으로 알아보았다. 위에서 말했듯이 상태를 전역상태로 관리하는 방식은 데이터 무결성을 위해 동일한 컴포넌트에서 관리해야한다. 다른 컴포넌트에서 이 전역상태에 접근하려면 props로 데이터를 전달해주어야만 하위 컴포넌트에서도 이 전역상태를 사용할 수 있다. 이 과정이 컴포넌트의 계층 단계가 많은 계층으로 이루어져있다면 매우 불편할 것이다.       그러한 불편함을 해소하기 위해 이를 도와주는 각종 툴들이 있다. 해당 툴들을 사용함으로써 얻는 이점은 다음과 같다.              첫번째로는 앞서 꾸준히 언급한 전역 상태를 위한 저장소를 제공해 준다.       다음은, props drilling 문제를 해결 해준다. 첫번째 이점의 연장선이다. 위에서 언급한 계층 구조에서 props로 데이터를 전달해주는 과정을 생략할 수 있게 된다.                “상태 관리 툴이 반드시 필요할까요?” 라는 질문에는 “아닙니다” 라는 답변을 할 수 있다. 상태 관리 툴이 없어도 충분히 규모있는 애플리케이션을 만들 수는 있다. 그러므로 장단점을 분명히 인지하고 상태 관리 툴을 써야한다.       그리고 상태 관리의 기본기라고 볼 수 있는 “상태가 어디에 위치해야 하는지” 라는 개념을 인지하는게 우선이 되어야 한다.       1-3. Redux          React에서는 상태와 속성(props)을 이용한 컴포넌트 단위 개발 아키텍처를 배웠다면, Redux에서는 컴포넌트와 상태를 분리하여 관리한다. 상태 변경 로직을 컴포넌트로부터 분리하면, 표현에 집중한 보다 단순한 함수 컴포넌트를 만들 수 있게 된다.       단순히 말하자면 React에서는 상태를 Store라는 별도의 오직하나뿐인 장소에서 관리하게되며, 해당 장소에서 상태를 관리하게 된다. 그렇다면 해당 상태들은 어떻게 변경해야할까? 간단히 말하자면 Action을 통해서 변화를 감지하며, Dispatch메서드를 통하여 Action을 전달한다. Store에 들어가기전 Reducer를 거쳐서 현재의 상태(State)와 전달된 액션이 결합되어 새로운 상태로 변경되게 된다.              잘 정리된 블로그가 있어서 해당 링크 참조로 Redux 설명은 대체하겠다.      1-4. Cmarket (Hooks 버전)             컴포넌트 구조를 감안하여 상태의 위치를 고려하여 코딩하였다.            전역상태(items, cartItems)는 최상단 컴포넌트 App 컴포넌트에서 관리.       Item 컴포넌트에서 items 상태를 다루기 위해서는 App - ItemListContainer - Item 컴포넌트까지 상태를 내려줘야 하는 props drilling 현상 발생           참조 : Github 링크   1-5. Cmarket (Redux 버전)     참조 : Github 링크         2. 클라이언트 빌드&amp;배포        오늘 느낀 점              내일 할 일     HA2  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.09.28.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 21. inequalityNumber",
        "excerpt":"  TOY 21. inequalityNumber  문제   아래와 같은 과정을 거쳐 부등호 수(inequalityNumber)를 만들 수 있습니다.     최대 9개의 부등호(&lt;, &gt;)가 주어집니다.   부등호의 좌우에는 0부터 9사이의 숫자가 한 번씩만 들어가야 합니다.   부등호를 만족하는 숫자의 조합을 차례대로 이어 붙여 만든 정수를 부등호 수라고 한다. 부등호 기호들을 입력받아 부등호를 만족하는 최대 부등호 수와 최소 부등호 수의 차이를 리턴해야 합니다.   입력   인자 1: signs     배열을 요소로 갖는 배열   string 타입의 공백을 사이에 둔 부등호 기호들   signs.length는 17 이하 (최대 9개의 부등호 기호)   출력      number 타입을 리턴해야 합니다.   주의사항      첫 자리가 0인 경우도 부등호 수에 포함되어야 합니다.   모든 입력에 답은 항상 존재합니다.   입출력 예시   llet output = inequalityNumber('&lt;'); console.log(output); // --&gt; 88 (89 - 01)  output = inequalityNumber('&lt; &gt;'); console.log(output); // --&gt; 876 (897 - 021)  output = inequalityNumber('&gt; &lt; &gt;'); console.log(output); // --&gt; 8,754 (9,786 - 1,032)   TOY 21. Solution  수도코드    문제풀이        Reference Code  const inequalityNumber = function (signs) {   const aux = (idx, signs, nums, digits, isVisited) =&gt; {     if (idx === signs.length) {       // 부등호 수를 만든 경우       return parseInt(nums.join(''));     }      const sign = signs[idx];     for (let i = 0; i &lt; digits.length; i++) {       // 숫자를 차례대로 검토한다.       // max를 구할 때는 9부터, min을 구할 때는 0부터       const right = digits[i];       // 이전 단계에서 사용한 숫자인 경우 스킵       if (isVisited[right]) continue;        // 첫번째 숫자가 아닌 경우에는 조건이 중요하다.       if (idx &gt;= 0) {         // 항상 바로 직전의 숫자와 비교하면 된다.         const left = nums[nums.length - 1];         if (sign === '&lt;' &amp;&amp; left &gt;= right) continue;         if (sign === '&gt;' &amp;&amp; left &lt;= right) continue;       }        // 조건을 만족하거나 첫번째 숫자인 경우       isVisited[right] = true;       const target = aux(idx + 1, signs, nums.concat(right), digits, isVisited);       if (target !== undefined) {         // 부등호 수를 이미 찾은 경우 탐색을 더 할 필요가 없다.         return target;       }       // 탐색에 실패한 경우, 시도한 숫자의 상태(사용중)를 원래대로(사용안함) 바꿔놔야 한다.       isVisited[right] = false;     }      return undefined;   };    signs = signs.split(' ');   const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];   // arr.reverse()는 in-place 함수(데이터 직접 변경)이므로 min과 max의 순서는 중요하다.   const min = aux(-1, signs, [], digits, Array(10).fill(false));   const max = aux(-1, signs, [], digits.reverse(), Array(10).fill(false));   return max - min; };   오늘 느낀 점   DFS로 접근해야겠구나 감은 잡히지만, 구현은 어렵다. Reference Code를 참고하였다.   내일 할 일     TOY 22. rotateMatrix  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.09.30.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 22. rotateMatrix",
        "excerpt":"  TOY 22. rotateMatrix  문제   2차원 N x N 배열을 시계 방향으로 90도 회전시킨 배열을 리턴해야 합니다.  입력   인자 1 : matrix     가로 길이(matrix[i].length)와 세로 길이(matrix.length)가 모두 N인 2차원 배열   matrix[i][j]는 number 타입   출력      2차원 배열을 리턴해야 합니다.   입출력 예시   const matrix = [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9, 10, 11, 12],   [13, 14, 15, 16], ]; console.log(matrix[0][0]); // --&gt; 1 console.log(matrix[3][2]); // --&gt; 15  const rotatedMatrix = rotateMatrix(matrix); console.log(rotatedMatrix[0][0]); // --&gt; 13 console.log(rotatedMatrix[3][2]); // --&gt; 8   힌트      컴퓨터 과학에서 행렬은 ‘행’의 길이인 m과 ‘열’의 길이인 n의 곱으로 표현됩니다. m X n 행렬은 아래와 같이 2차원 배열로 구현할 수 있습니다. (행렬의 요소를 전부 initVal로 초기화)   const matrix = []; for(let row = 0; row &lt; m; row++&gt;) {   matrix.push(Array(n).fill(initVal)) }   이때 matrix[i][j]는 ‘행(세로축)을 기준으로 i만큼 아래에 있고 열(가로축)을 기준으로 j만큼 옆에 있다.’ 를 뜻합니다. 이 방식은 기하학에서 좌표 평면 위의 한 점을 나타낼 때 (x, y), 즉 가로축을 먼저 표기하고 세로축을 다음에 표기하는 방식과는 다릅니다. 그래프를 인접행렬로 구현할 때, 이 점을 주의하셔야 합니다.   Advanced       세로와 가로의 길이가 각각 M, N인 2차원 M X N 배열을 시계방향으로 90도씩 K번 회전시킨 배열을 리턴해 보세요. 회전수가 두 번째 입력으로 주어집니다.   TOY 22. Solution  수도코드   간단한 구조이다. 90도로 돌려주는 문제이기때문에 배열의 행과 열을 주의해서 2중 for문으로 풀어준다.   Advanced는 입력횟수를 받으므로 기존 함수를 몇번 재사용 할지만 정의해주면 해결 가능하다. 입력 횟수가 없다면 1을 기본값으로 지정해준다.  문제풀이   /* const matrix = [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9, 10, 11, 12],   [13, 14, 15, 16], ]; */  const rotateMatrix = function (matrix)  {   let result = [];    if(matrix.length === 0) return result;  // 빈 배열 입력시 빈 배열 리턴    for(let i=0; i&lt;matrix[0].length; i++) {     let temp = [] // 행 단위 임시배열     for(let j=matrix.length-1; j&gt;=0; j--){       temp.push(matrix[j][i]);     } // case 1 : [13, 9, 5, 1] -&gt; case 2 : [14, 10, 6, 2]...     result.push(temp);   }    return result; };    Advanced   const rotateMatrix = function (matrix, k=1) {  // 기본값 매개변수 = 1   if(matrix.length === 0) return matrix;      for(let i = 0; i &lt; k; i++){      matrix = rotate90(matrix);   }    return matrix };  const rotate90 = function (matrix)  {   let result = [];    for(let i=0; i&lt;matrix[0].length; i++) {     let temp = [] // 행 단위 임시배열     for(let j=matrix.length-1; j&gt;=0; j--){       temp.push(matrix[j][i]);     } // case 1 : [13, 9, 5, 1] -&gt; case 2 : [14, 10, 6, 2]...     result.push(temp);   }    return result; };     Reference Code  // const rotateMatrix = function (matrix) { //   const N = matrix.length; //   const M = matrix[0] &amp;&amp; matrix[0].length; //   let output = [];  //   for (let row = 0; row &lt; M; row++) { //     output[row] = []; //     for (let col = 0; col &lt; N; col++) { //       output[row][col] = matrix[N - col - 1][row]; //     } //   }  //   return output; // };  const rotateMatrix = function (matrix, rotateNum = 1) {   // rotateNum 이 0일 수 있으므로 아래와 같은 초기화는 지양해야 함   // rotateNum = rotateNum || 1   const N = matrix.length;   // 빈 배열을 입력받을 수 있다.   const M = matrix[0] &amp;&amp; matrix[0].length;    rotateNum = rotateNum % 4;   // 회전하지 않는다.   if (rotateNum === 0) return matrix;    const rotated = [];   // 홀수번 회전 시 M x N, 짝수번 회전 시 N x M   const RC = rotateNum % 2 === 1 ? [M, N] : [N, M];    for (let row = 0; row &lt; RC[0]; row++) {     rotated[row] = [];     for (let col = 0; col &lt; RC[1]; col++) {       if (rotateNum === 1) rotated[row][col] = matrix[N - col - 1][row];       else if (rotateNum === 2)         rotated[row][col] = matrix[N - row - 1][M - col - 1];       else rotated[row][col] = matrix[col][M - row - 1];     }   }    return rotated; };   오늘 느낀 점  Reference Code와 크게 다르지 않게 풀렸다. 문제의 난이도가 오늘은 어렵지 않아 금방 해결 할 수 있었다.   내일 할 일     TOY 23. spiralTraversal  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.01.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 23. spiralTraversal",
        "excerpt":"  TOY 23. spiralTraversal  문제   2차원 M x N 배열을 나선형(spiral)으로 순회해야 합니다.  입력   인자 1 : matrix     세로 길이(matrix.length)가 M, 가로 길이(matrix[i].length)가 N인 2차원 배열   matrix[i]는 string 타입을 요소로 갖는 배열   matrix[i][j].length는 1   출력      string 타입을 리턴해야 합니다.   입출력 예시   let matrix = [   ['A', 'B', 'C'],   ['D', 'E', 'F'],   ['G', 'H', 'I'], ]; let output = spiralTraversal(matrix); console.log(output); // --&gt; 'ABCFIHGDE'  matrix = [   ['T', 'y', 'r', 'i'],   ['i', 's', 't', 'o'],   ['n', 'r', 'e', 'n'],   ['n', 'a', 'L', ' '], ]; output = spiralTraversal(matrix); console.log(output); // --&gt; 'Tyrion Lannister'  TOY 23. Solution  수도코드   상단, 우측, 하단, 좌측 돌려가며 matrix를 깎으(?)면서 배열에 담긴 값을 result에 넣어주면 언젠가는 matix가 빈 배열로 남게된다.  해당 네가지 과정을 담은 함수들을 작성해준다.   spiralTraversal 메인 함수에서는 matrix가 모두 깎인(?) 빈 배열의 상태가 될때까지 반복으로 해당 과정들을 수행해준다.   문제풀이   // 매트릭스 상단 순서대로 result 담는 함수 const insertTop = (matrix, result) =&gt; {     for(let el of matrix[0]){     result += el;   }   matrix.shift();  // 상단(윗변) 삭제   return result; }  // 매트릭스 우측 순서대로 result 담는 함수 const insertRight = (matrix, result) =&gt; {   for(let i=0; i&lt;matrix.length; i++){     let char = matrix[i].pop();  // 우측 한글자씩 삭제 후 변수에 담아 리턴한다     result += char;   }   return result; }  // 매트릭스 하단 순서대로 result 담는 함수 const insertBottom = (matrix, result) =&gt; {   matrix[matrix.length-1].reverse(); // 하단(아랫변)은 상단과 다르게 역순으로 담긴다.   for(let el of matrix[matrix.length-1]){     result += el;   }   matrix.pop();  // 하단(아랫변) 삭제   return result; }  // 매트릭스 좌측 순서대로 result 담는 함수 const insertLeft = (matrix, result) =&gt; {   for(let i=matrix.length-1; i&gt;=0; i--){     let char = matrix[i].shift();  // 좌측 한글자씩 삭제 후 변수에 담아 리턴한다     result += char;   }   return result }  const spiralTraversal = function (matrix) {   let result = '';    while(true){     result = insertTop(matrix,result);     if(matrix.length === 0) break;  // 반복문이 끝나는 조건은 상단 혹은 하단 삭제 후 matrix가 모두 비어버리는 경우이다.     result = insertRight(matrix,result);     result = insertBottom(matrix,result);     if(matrix.length === 0) break;     result = insertLeft(matrix,result);   }    return result; };    Reference Code  const spiralTraversal = function (matrix) {   // 각 방향마다 row와 col의 변화를 저장   const RIGHT = [0, 1];   const DOWN = [1, 0];   const LEFT = [0, -1];   const UP = [-1, 0];   // 각 방향을 위한 lookup table   const MOVES = [RIGHT, DOWN, LEFT, UP];   const M = matrix.length;   const N = matrix[0].length;   const isValid = (row, col) =&gt; row &gt;= 0 &amp;&amp; row &lt; M &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; N;    let cnt = 0;   let row = 0,     col = -1;   let direction = 0;   let result = '';   while (cnt &lt; M * N) {     const move = MOVES[direction];     const [rd, cd] = move;      row = row + rd;     col = col + cd;     while (isValid(row, col) &amp;&amp; matrix[row][col] !== false) {       result = result + matrix[row][col];       // 한 요소를 두 번 접근하지 않게 하기 위해서, 접근된 요소를 false로 변경한다.       matrix[row][col] = false;       row = row + rd;       col = col + cd;       cnt++;     }     // row, col 이 행렬의 범위를 벗어났기 때문에,     // 진행된 방향의 반대로 한 칸 이동한다.     row = row - rd;     col = col - cd;      // 각 방향이 순환되기 때문에 모듈러 연산을 사용한다.     direction = (direction + 1) % 4;   }   return result; };   오늘 느낀 점  레퍼런스 코드는 길찾기 알고리즘과 비슷한 메커니즘으로 문제를 해결하였다. 여러가지 함수를 만들지 않고 방향성을 갖고 [0,0] 인덱스부터 나선형으로 돌며 모든 배열의 인덱스를 순회하는 알고리즘으로 깔끔히 구현하였다.   해당 길찾기(?) 알고리즘은 눈에 익혀두어야 겠다.   내일 할 일     TOY 24. radixSort  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.05.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. Linux 사용권한 2. Linux 환경변수",
        "excerpt":"  Today I Learnd  1. Linux 사용권한   1-1. 터미널 파일 및 폴더 생성 명령어          mkdir명령어로 linux이름의 폴더를 생성하고 nano (리눅스 기반 오픈소스 편집 프로그램)를 통해 helloworld.js 파일을 생성 한 후 명령어 ls -l 을 프롬프트에 입력하고 Enter(엔터 키)를 누르면 다음과 같은 출력 결과를 얻을 수 있다.              터미널에 출력된 결과 중에서, 가장 왼쪽의 표현을 살펴보면, 파일 helloworld.js는 -rw-r--r-- 이라고 출력되었고, 폴더 linux는 drwxr-xr-x 라고 출력되었다.       이 표현의 첫 시작인 - 와 d 는 각각 not directory와 directory를 나타낸다. 폴더이면 d로, 파일이면 - 로 표현한다. 이어지는 r, w, x는 각각 read permission, write permission, execute permission으로 읽기 권한, 쓰기 권한, 실행 권한을 나타낸다. 3번에 걸쳐 나타나는 이유는 사용자와 그룹, 나머지에 대한 권한을 표시하기 때문이다.       파일 helloworld.js의 권한은 rw- rw- r-- 으로, 소유자는 읽기와 쓰기가 가능하고, 다른 사용자 그룹은 읽기만 가능하다는 의미이며, 폴더 linux의 권한은 rwx rwx r-x 으로, 소유자는 읽기와 쓰기, 실행이 가능하고, 다른 사용자 그룹은 읽기와 실행만 가능함을 뜻한다.               1-2. User, Group, and Other     User : user는 파일의 소유자이다. 기본적으로 파일을 만든 사람이 소유자가 된다. 소유자(Owner)라 부르기도 한다.   Group : group에는 여러 user가 포함될 수 있다. 그룹에 속한 모든 user는 파일에 대한 동일한 group 액세스 권한을 갖는다. 많은 사람이 파일에 액세스해야 하는 프로젝트가 있다고 가정하면, 각 user에게 일일이 권한을 할당하는 대신에 모든 user를 group에 추가하고, 파일에 group 권한을 할당할 수 있다.   Other : 파일에 대한 액세스 권한이 있는 다른 user이다. 파일을 만들지 않은 다른 모든 user를 의미한다. 따라서 other 권한을 설정하면, 해당 권한을 global 권한 설정이라고 볼 수도 있다.    1-3. chmod     명령어 chmod는 폴더나 파일의 읽기, 쓰기, 실행 권한을 변경할 수 있다. OS에 로그인한 사용자와, 폴더나 파일의 소유자(Owner)가 같을 경우에 명령어 chmod 로 폴더나 파일의 권한을 변경할 수 있다. 만약 OS에 로그인한 사용자와, 폴더나 파일의 소유자가 다를 경우(Other)에는 관리자 권한을 획득하는 명령어 sudo 를 이용해 폴더나 파일의 권한을 변경할 수 있다.   명령어 chmod로 권한을 변경하는 방식은 두 가지가 있다.            첫 번째는 더하기(+), 빼기(-), 할당(=)과 액세서 유형을 표기해서 변경하는 Symbolic method,       두 번째는 rwx를 3 bit로 해석하여, 숫자 3자리로 권한을 표기해서 변경하는 Absolute form이다.                Symbolic method는 액세스 클래스, 연산자, 액세스 타입으로 구분한다.                                  Access class           Operator           Access Type                                           u (user)           + (add access)           r (read)                             g (group)           - (remove access)           w (write)                             o (other)           = (set exact access)           x (execute)                             a (all: u, g, and o)                                                   chmod g-r filename # removes read permission from group chmod g+r filename # adds read permission to group chmod g-w filename # removes write permission from group chmod g+w filename # adds write permission to group chmod g-x filename # removes execute permission from group chmod g+x filename # adds execute permission to group chmod o-r filename # removes read permission from other chmod o+r filename # adds read permission to other chmod o-w filename # removes write permission from other chmod o+w filename # adds write permission to other chmod o-x filename # removes execute permission from other chmod o+x filename # adds execute permission to other chmod u+x filename # adds execute permission to user           chmod a=rw helloworld.js # -rw-rw-rw- chmod u= helloworld.js # ----rw-rw- chmod a+rx helloworld.js # -r-xrwxrwx chmod go-wx helloworld.js # -r-xr--r-- chmod a= helloworld.js # ---------- chmod u+rwx helloworld.js # -rwx------                Absolute form은 숫자 7까지 나타내는 3 bits의 합으로 표기한다. 사용자, 그룹, 또는 다른 사용자나 그룹마다 rwx 가 나타나고, 각 영역의 boolean 값으로 표기할 수 있다.                                  Permission           Number                                           Read (r)           4                             Write (w)           2                             Execute (x)           1                             # u=rwx (4 + 2 + 1 = 7), go=r (4 + 0 + 0 = 4)   chmod 744 helloworld.js # -rwxr--r--            2. Linux 환경변수     Linux 기반의 운영체제의 PC에는 시스템 자체에 전역변수를 설정할 수 있다. 그리고 시스템에 설정한 전역변수를 환경변수라고 한다. 명령어를 이용해 환경변수를 설정및 활용할 수 있다.   프로그래밍 도중 API key와 같이 공개할 수 없는 정보가 코드에 포함될 경우, 네트워크를 통해 API key가 공개될 수 있다. 이런 일을 방지하기 위해서 API key를 PC에 저장해두고 사용해야 보안에 취약하지 않게 프로그램을 설계할수 있다. JavaScript에서 변수에 문자열을 할당하는 것처럼, API key를 PC에서 사용하는 변수에 할당하고 Javascript 코드에서 해당 환경변수를 호출하여 사용하는게 보안을 지키며 프로그래밍을 할 수 있는 방법이다.   2-1. export: 환경변수 확인하기 &amp;&amp; 환경변수 임시 적용          Linux 운영체제에는 이미 많은 환경변수가 설정되어 있다. 터미널에 명령어 export 를 입력해, 기록된 환경변수를 확인할 수 있다.                   명령어 export 를 이용하면, 새로운 환경변수를 추가할 수 있다. 이 때 등호 표시(Equal sign, =) 앞뒤에는 반드시 공백이 없어야 하며, 명령어 echo 와 함께 환경변수를 입력하면, 환경변수의 값을 확인할 수 있다. 이때 환경변수의 앞에는 달러사인($)을 입력하여, 변수라는 뜻을 터미널에 전달해야 확인이 가능하다.              위와 같은 방법으로 할당한 환경변수들은 unset [환경변수명] 명령어를 통해 비활성화 할 수 있다. 또한 해당 환경변수들은 재시작시 자동으로 비활성화가 되는 임시적용 상태이다.       2-2. dotenv: 자바스크립트에서 환경변수 사용하기          npm 모듈 dotenv를 사용하면, 자바스크립트에서 환경변수를 사용할 수 있다. npm init 을 입력후 npm i dotenv 를 입력해 모듈을 설치한다.       설치한 dotenv 모듈을 이용해 환경변수에 접근할 수 있다. Node.js의 내장 객체 process.env를 이용하면 명령어 export 로 확인한 내용과 동일한 내용을 객체로 출력한다.              2-3. .env: Node.js에서 환경변수 영구 적용          2-1에서 언급하였지만 명령어 export 로 적용한 환경변수는 현재 사용 중인 터미널에서만 임시로 사용이 가능하며 재시작시 초기화된다. 환경변수를 Linux 운영체제에 영구적으로 저장하는 방법은 여러 가지가 있지만, Node.js에서는 파일 .env를 만들어 저장하는 방법이 보편적이다.       다시 정리하자면, dotenv 모듈을 통하여 자바스크립트로 Node.js의 내장 객체 process.env를 이용하여 Linux PC 환경변수에 접근할 수 있다. (이때 process.env를 콘솔창을 통해 확인해보면 export명령어와 같은 환경변수를 객체 형태로 확인 가능하다.) 그리고 .env파일에 원하는 환경변수를 입력 한 뒤 저장 후 모듈 dotenv를 이용하면, 파일 .env에 저장한 환경변수를 조회할 수 있게된다.              이와 같은 과정들을 토대로 환경변수를 이용해 API key, DB password와 같이 민감한 정보를 저장하고 관리할 수 있으며, 그뿐만 아니라 서로 다른 PC 또는 여러 .env 파일에서, 같은 변수 이름에 다른 값을 할당할 수 있다.             오늘 느낀 점          Linux 환경에서의 환경변수를 사용하는 목적은 로컬PC에서만 사용되어야 하는 정보(ex. API Key, DB password…)를 프로그램 코드에 심지 않고 환경변수에 심은 뒤 해당 환경변수를 JS 환경에서 사용할 수 있게되는게 주된 목적이라 생각된다.       프로그램 코드에 해당 데이터값을 심고 배포한다면, 해당 데이터들이 노출될 우려가 있으므로 보안에 취약해진다.            아직 실사용 경험이 없어서 정확히 .env 파일에 어떤식으로 해당 데이터값들을 심어서 사용하는지 감을 잡기가 어렵다. 우선 사용목적과 프로세스는 확실히 학습하였다.             내일 할 일     [자료구조/알고리즘]  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.05.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 24. radixSort",
        "excerpt":"  TOY 24. radixSort  문제   정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.  입력   인자 1 : arr     number 타입을 요소로 갖는 배열   arr[i]는 0 이상의 정수   arr.length 100,000 이하   출력      number 타입을 요소로 갖는 배열을 리턴해야 합니다.   배열의 요소는 오름차순으로 정렬되어야 합니다.   arr[i] &lt;= arr[j] (i &lt; j)   주의사항      기수 정렬을 구현해야 합니다.   arr.sort 사용은 금지됩니다.   입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   입출력 예시   let output = radixSort([3, 1, 21]); console.log(output); // --&gt; [1, 3, 21]   힌트      기수 정렬(radix sort)은 내부적으로 계수 정렬(counting sort)을 사용합니다.   계수 정렬을 먼저 학습하고, 어떤 경우에 기수 정렬을 사용하는지 학습하도록 합니다.   Advanced      arr[i]의 범위가 정수 전체로 확대될 경우, 기수 정렬 알고리즘을 완성해 보세요.   TOY 24. Solution  수도코드    기수정렬 이란?     정렬할 원소의 키값에 해당하는 버킷에 원소를 분배하였다가 버킷의 순서대로 원소를 꺼내는 방법이다.   원소의 키를 표현하는 값의 기수만큼 버킷이 필요하다.   키 값의 길이만큼 기수 정렬을 반복한다.   반복 횟수는 매개변수의 배열의 요소 중 최댓값의 길이이다.         문제풀이       Reference Code  /* const arr = [3, 1, 21] */  function getMax(arr) {   return arr.reduce((max, item) =&gt; {     if (item &gt; max) return item;     return max;   }, 0); } // 배열에서 최대값 색출  function countingSort(arr, radix) { // arr = [3,1,21], radix = 1 (자릿수)   const N = arr.length; // arr의 길이 3   const output = Array(N).fill(0); // [0,0,0]   const count = Array(10).fill(0); // [0,0,0,0,0,0,0,0,0,0]    // 현재 자리수를 기준으로 0~9의 개수를 센다.   arr.forEach((item) =&gt; {     const idx = Math.floor(item / radix) % 10;     count[idx]++; // [0,2,0,1,0,0,0,0,0,0]   });    // count[i]가 i까지의 누적 개수가 되도록 만든다.   count.reduce((totalNum, num, idx) =&gt; {     count[idx] = totalNum + num;     return totalNum + num;   });// [0,2,2,3,3,3,3,3,3,3]    // 아래 속성이 유지되도록 하기 위해 배열을 거꾸로 순회한다.   //  1. 가장 큰 값을 먼저 본다.   //  2. 가장 큰 값을 가장 마지막에 놓는다.   let i = N - 1;   while (i &gt;= 0) {     const idx = Math.floor(arr[i] / radix) % 10;     // count[idx]: 현재 radix의 idx까지 누적 개수     // count[idx]개만큼 있으므로, 인덱스는 count[idx] - 1     output[count[idx] - 1] = arr[i];     count[idx] -= 1;     i--;   }    return output; // [1,21,3] }  // naive solution // 양의 정수만 정렬 가능 // function radixSort(arr) { //   const max = getMax(arr); //   let radix = 1; //   while (parseInt(max / radix) &gt; 0) { //     arr = countingSort(arr, radix); //     radix *= 10; //   } //   return arr; // }  // 음의 정수를 포함한 기수 정렬 // 1. 주어진 배열을 음수 부분과 양수 부분으로 나눈다. // 2. 음수는 절대값을 기준으로, 즉 양수로 변환하여 기수 정렬한다. // 3. 양수를 정렬한다. // 4. 정렬된 음수 부분을 다시 음수로 바꾸고 순서를 뒤짚는다. // 5. 음수 부분과 양수 부분을 붙인다. function radixSort(arr) {   let left = [];   let right = [];   arr.forEach((item) =&gt; {     if (item &gt;= 0) right.push(item);     else left.push(item * -1);   }); // 양수면 오른쪽에 음수면 양수로 바꿔서 왼쪽에 넣어준다.    let max = getMax(left); // 왼쪽의 최대값 구하기   let radix = 1;   while (parseInt(max / radix) &gt; 0) {     left = countingSort(left, radix);     radix *= 10;   } // 왼쪽 정렬    max = getMax(right); // 오른쪽의 최대값 구하기   radix = 1;   while (parseInt(max / radix) &gt; 0) {     right = countingSort(right, radix);     radix *= 10;   } // 오른쪽 정렬    return left     .reverse()     .map((item) =&gt; item * -1)     .concat(right); } // 정렬된 왼쪽값을 뒤집어서 다시 음수로 만들어준뒤 오른쪽 값들을 합쳐준다.   오늘 느낀 점  기수정렬의 개념에 대해서만 이해하고 Reference Code를 보며 이해하는 정도에 그쳤다.. 나중에 다시 풀어볼 예정   정렬.. 잊을만 하면 한번씩 나온다 ㅠㅠ   내일 할 일     TOY 25. robotPath  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.06.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 25. robotPath",
        "excerpt":"  TOY 25. robotPath  문제   세로와 가로의 길이가 각각 M, N인 방의 지도가 2차원 배열로 주어졌을 때, 1은 장애물을 의미하고 0 이동이 가능한 통로를 의미합니다. 로봇은 지도 위를 일분에 한 칸씩 상하좌우로 이동할 수 있습니다. 로봇의 위치와 목표 지점이 함께 주어질 경우, 로봇이 목표 지점까지 도달하는 데 걸리는 최소 시간을 리턴해야 합니다.   입력   인자 1 : room     배열을 요소로 갖는 배열   room.length는 M   room[i]는 number 타입을 요소로 갖는 배열   room[i].length는 N   room[i][j]는 세로로 i, 가로로 j인 지점의 정보를 의미   room[i][j]는 0 또는 1   인자 2 : src     number 타입을 요소로 갖는 배열   src.length는 2   src[i]는 0 이상의 정수   src의 요소는 차례대로 좌표평면 위의 y좌표, x좌표   인자 3 : dst     number 타입을 요소로 갖는 배열   dst.length는 2   dst[i]는 0 이상의 정수   dst의 요소는 차례대로 좌표평면 위의 y좌표, x좌표   출력      number 타입을 리턴해야 합니다.   주의사항      M, N은 20 이하의 자연수입니다.   src, dst는 항상 로봇이 지나갈 수 있는 통로입니다.   src에서 dst로 가는 경로가 항상 존재합니다.   입출력 예시   let room = [   [0, 0, 0, 0, 0, 0],   [0, 1, 1, 0, 1, 0],   [0, 1, 0, 0, 0, 0],   [0, 0, 1, 1, 1, 0],   [1, 0, 0, 0, 0, 0], ]; let src = [4, 2]; let dst = [2, 2]; let output = robotPath(room, src, dst); console.log(output); // --&gt; 8   TOY 25. Solution  수도코드   Toy 알고리즘 너무 어렵다… 우선 레퍼런스를 보기전 열심히 구글링을 해보니 내가 이해할 수 있는 수준의 코드로 풀이를 해놓은 블로그를 발견하여서 이해하는 수준에서 마무리지었다.   우선 키포인트는 완전탐색이다.  현재의 좌표를 기준으로 4방향으로 움직인다. 다만, 최단거리를 구하는 효율성 문제이므로 BFS 방식(시작 지점부터 가까운 정점들 우선 탐색하는 방법)으로 풀었다고한다.   코드가 복잡해보이지만 전형적인 BFS 탐색 방식이다. 코드의 세부적인 내용은 주석으로 대체하였다.   문제풀이   const robotPath = function (room, src, dst) {   const visit = Array(room.length).fill().map(()=&gt;Array(room[0].length).fill(0)); // 0으로 채워진 방문여부 지도 (room.length X room[0].length 사이즈) 2차원 배열 생성   const queue = [[...src, 1]];  // [y,x,cnt] 값, 큐가 비워지며 반복문을 시작하므로 1부터 시작한다.   const direction = [  // 4방향 좌표이동치     [0,1],     [0,-1],     [1,0],     [-1,0]   ];   const ny = room.length - 1;  // y값의 최대값(인덱스)은 room배열의 length-1, 유효값 검사에 쓰인다.   const nx = room[0].length - 1;  // x값의 최대값(인덱스)은 room[0]배열의 length-1    visit[src[0]][src[1]] = 1;  // 시작점부터 방문 체크 진행 후 반복문에 진입한다.    while(queue.length !== 0) {  // 큐가 모두 비워질때까지 진행한다.     let result = queue.shift();       let [y, x, cnt] = result;  // 큐에서 뺀 result 값을 각각 y,x,cnt로 구조분해 할당           for(let i = 0; i &lt; 4; i++) {       let dy = y + direction[i][0];  // robot이 이동할 다음 좌표 (현재 기준점에서 사방향을 모두 검사한다 [완전탐색])       let dx = x + direction[i][1];        // robot이 이동하기 전, 다음좌표가 이동이 가능한지 유효성 검사       if(dx &lt; 0 || dy &lt; 0 || dx &gt; nx || dy &gt; ny ) continue;  // robot이 이동할 좌표가 room 배열을 벗어나는 경우       if(room[dy][dx] === 1) continue;  // robot이 이동할 좌표가 장애물이 있는 경우       if(visit[dy][dx]) continue;  // robot이 이동할 좌표가 이미 방문한적이 있는 경우        // 다음 이동할 좌표가 dst(도착점) 좌표와 일치하다면 반복문 탈출       if(dy === dst[0] &amp;&amp; dx === dst[1]) return result[2];  // 이동할 좌표가 dst와 일치하다면 result 배열의 cnt값을 반환한다.        // 유효성 검사를 통과했으며, 도착점도 아니라면 아래의 코드를 수행한다       visit[dy][dx] = 1;  // 현재 좌표를 방문표시한다.       queue.push([dy, dx, cnt + 1]);  // queue에 이동할 다음 좌표값을 넣고 cnt값을 증가시킨다.     }   } };   Reference Code  const robotPath = function (room, src, dst) {   const aux = (M, N, candi, step) =&gt; {     // 현재 위치     const [row, col] = candi;      // 배열의 범위를 벗어난 경우     if (row &lt; 0 || row &gt;= M || col &lt; 0 || col &gt;= N) return;      if (room[row][col] === 0 || room[row][col] &gt; step) {       room[row][col] = step;     } else {       // 장애물(1)이거나 이미 최소 시간(1)으로 통과가 가능한 경우       return;     }      // dfs로 4가지 방향에 대해 탐색을 한다.     // 완전탐색을 해야하므로 bfs나 dfs가 큰 차이가 없다.     // bfs의 경우 목적지에 도착하는 경우 탐색을 중단해도 되므로,     // 약간 더 효율적이다.     aux(M, N, [row + 1, col], step + 1); // 상     aux(M, N, [row - 1, col], step + 1); // 하     aux(M, N, [row, col - 1], step + 1); // 좌     aux(M, N, [row, col + 1], step + 1); // 우   };    // 로봇이 서 있는 위치를 1로 초기화하면 (다시 방문하지 않기 위해서),   // 바로 옆 통로는 2가 된다.   // 계산이 완료된 후에 최종값에 1을 빼주면 된다.   aux(room.length, room[0].length, src, 1);    const [r, c] = dst;   return room[r][c] - 1; };   오늘 느낀 점  const visit = Array(room.length).fill().map(()=&gt;Array(room[0].length).fill(0));  2차원 배열로 지도(방문여부 플래그)를 그리는 코드이다. map 메서드를 이용해서 room.length * room[0].length 사이즈의 2차원 배열을 생성한다. 생소하지만 앞으로 유용할 듯 하다.   아직 BFS 탐색 알고리즘… 완전탐색 알고리즘이 익숙하지 않다. (언제쯤 혼자 풀어볼까…)  내일 할 일     TOY 26. LSCS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.07.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 26. LSCS",
        "excerpt":"  TOY 26. LSCS  문제   정수를 요소로 갖는 배열을 입력받아 다음의 조건을 만족하는 LSCS*를 리턴해야 합니다.      LSCS: 주어진 배열의 연속된 부분 배열*의 합을 구한다고 할 때, 이 중 가장 큰 값(Largest Sum of Contiguous Subarray)   연속된 부분 배열들: 배열 [1,2,3]의 연속 부분 배열은 [1], [1, 2], [1, 2, 3], [2], [2, 3], [3] 입니다.   입력   인자 1 : arr      number 타입을 요소로 갖는 배열   arr.length는 60,000 이하   arr[i]는 -100,000 이상 100,000 이하의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      배열의 모든 요소가 음수인 경우도 있습니다.   입출력 예시   let output = LSCS([1, 2, 3]); console.log(output); // --&gt; 6  output = LSCS([1, 2, 3, -4]); console.log(output); // --&gt; 6 ([1, 2, 3])  LSCS([1, 2, 3, -4, 5]); console.log(output); // --&gt; 7 ([1, 2, 3, -4, 5])  LSCS([10, -11, 11]); console.log(output); // --&gt; 11 ([11])   TOY 26. Solution  수도코드   문제가 잘 이해가 안갔다… arr 배열의 요소들로 만들 수 있는 모든 부분 집합 배열들 중 합이 가장 큰 경우를 리턴해주면 되는 문제이다. 만약, 모든 배열의 요소가 양수라면 부분집합의 합중 가장 큰 부분집합은 자기 자신(arr)일것이다.   O(n^2)이라는 최악의 시간복잡도가 나오겠지만, 가장 쉬운 방법은 이중 for문으로 모든 요소를 탐색하며 부분집합의 합을 계산하여 가장 큰 값이 무엇인지 추려내는 과정일 것 이다.   문제풀이   const LSCS = function (arr) {   let max = -100000;  // 입력조건중 arr[i]의 최소값은 -100,000    // for문을 2개를 사용하여, 모든 경우의 수를 탐색한다. O(n^2)   for (let i = 0; i &lt; arr.length; i++) {     let sum = arr[i];      if (sum &gt; max) max = sum;      for (let j = i + 1; j &lt; arr.length; j++) {       sum = sum + arr[j];       if (sum &gt; max) max = sum;     }   }   return max; };   Reference Code  const LSCS = function (arr) {   let subArrSum = 0; // 연속 배열의 합   let max = Number.MIN_SAFE_INTEGER; // JavaScript에서 안전한 최소 정수값      for (let i = 0; i &lt; arr.length; i++) {     subArrSum = subArrSum + arr[i];      // 배열의 모든 요소가 음수라면, 이 비교식에 걸려 배열의 모든 요소를 한번씩 탐색 후 가장 큰 정수 요소만 반환된다.     if (subArrSum &gt; max) max = subArrSum;        // 연속된 구간의 합이 음수인 경우, 0으로 초기화. 즉 LSCS와 상관없는 연산이되므로, 해당 값은 고려하지 않는다.     if (subArrSum &lt; 0) subArrSum = 0;   }   return max;   };   오늘 느낀 점  사실 시간복잡도를 고려하기전 “부분집합의 합을 구하라”라는 문제라고 느껴서 부분집합을 모두 구한 뒤.. 해당 배열들의 합을 구해서… 리턴을해야하나? 라는 생각부터 들었다.   문제를 아직 많이 풀어본 경험이 없어서 문제 자체를 너무 1차원적으로 받아들인다라고 스스로 느껴졌다.   Reference Code는 특별한 알고리즘이 아닌 발상을 전환해서, 모든 수가 음수라면..가장 큰 음수를 max값으로 넣고 리턴해줄수 있을 뿐만아니라, 부분집합의 합이 음수가 되는 경우는 LSCS를 만족하지 못하는 경우의 수 이기때문에 연산에서 배제시키는 알고리즘을 구현하였다.   간단하면서도 풀이가 명확하다 느껴졌다.   Number.MIN_SAFE_INTEGER // JavaScript에서 안전한 최소 정수값  사담이지만, 이러한 정수값 표현 방법도 배웠다. 반대로 안전한 최대 정수값은 MIN_SAFE_INTEGER로 치환해주면 성립된다.  내일 할 일     TOY 27. LSCS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.08.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 27. gossipProtocol",
        "excerpt":"  TOY 27. gossipProtocol  문제   세로와 가로의 길이가 각각 M, N인 마을지도가 배열로 주어졌을 때, '1'은 주민이 있는 집을 의미하고 '0'은 주민이 없는 땅을 의미합니다. 이 마을은 소문이 시작되면 하루에 상하좌우 한 칸 바로 옆에 있는 집으로 퍼집니다. 특정 주민의 집 (R, C)으로부터 어떤 소문이 시작될 경우, 마을 전체로 소문이 퍼지는데 걸리는 시간(일)을 리턴해야 합니다.   입력   인자 1 : village     string 타입을 요소로 갖는 배열   village.length는 M   village[i]는 string 타입   village[i].length는 N   village[i][j]는 세로로 i, 가로로 j인 지점의 정보를 의미   village[i][j]는 '0' 또는 '1'   인자 2: row     number 타입의 0 이상의 정수   소문이 시작되는 집의 세로 위치   인자 3: col     number 타입의 0 이상의 정수   소문이 시작되는 집의 가로 위치   출력      number 타입을 리턴해야 합니다.   주의사항      M, N은 100 이하의 자연수입니다.   row, col에는 항상 주민이 살고 있습니다.   모든 집은 연결되어 있습니다. 즉, 한 집에서 다른 집으로 가는 경로가 항상 존재합니다.   village를 그래프로 구현하는 함수가 주어집니다.   입출력 예시   let village = [   '0101', // 첫 번째 줄   '0111',   '0110',   '0100', ]; let row = 1; let col = 2; let output = gossipProtocol(village, row, col); console.log(output); // --&gt; 3 /* 1. 시작: (1, 2)에서 시작, 소문이 퍼진 곳을 x로 표기  [   '0101',   '01x1',   '0110',   '0100',  ]  2. 1일 뒤  [   '0101',   '0xxx',   '01x0',   '0100',  ]  3. 2일 뒤  [   '0x0x',   '0xxx',   '0xx0',   '0100',  ]  4. 3일 뒤: 소문이 전부 퍼짐 (끝)  [   '0x0x',   '0xxx',   '0xx0',   '0x00',  ] /*   TOY 27. Solution  수도코드   소문의 근원지 부터 시작하여 인근 인덱스 값이 1이면 소문을 퍼트리는 재귀를 구현하면 될 듯 싶었는데, 생각대로 되지 않았다. Reference Code 를 보았다.   문제풀이      Reference Code  const createMatrix = (village) =&gt; {   const matrix = [];   village.forEach((line) =&gt; {     const row = [];     for (let i = 0; i &lt; line.length; i++) row.push(line[i]);     matrix.push(row);   });   return matrix; };  const gossipProtocol = function (village, row, col) {   // bfs 구현을 위해 큐를 선언한다.   // enQueue, deQueue시마다 인덱싱을 다시 하지 않기 위해   // 순환 큐(circular queue)로 구현한다.   // 문제의 특성에 따라 큐에는 좌표 평면의 한 점이 삽입되고, 한번 삽입된 요소는 두 번 다시 삽입되지 않는다.    const R = village.length;   const C = village[0].length;   const matrix = createMatrix(village);   const MOVES = [     [-1, 0], // UP     [1, 0], // DOWN     [0, 1], // RIGHT     [0, -1], // LEFT   ];   const isValid = (row, col) =&gt; row &gt;= 0 &amp;&amp; row &lt; R &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; C;   // 마을을 벗어나는지 안 벗어나는지 검사   const queue = [];    const enQueue = (queue, pos) =&gt; {     queue.push(pos)   }; // 소문을 들은 집의 좌표를 queue에 넣는다.   const deQueue = (queue) =&gt; {     const pos = queue.shift();     return pos;   }; // 소문을 들은 집의 좌표를 queue에서 빼준다.    let cnt = 0; //소문이 퍼진 시간    enQueue(queue, [row, col]); // 시작점의 집을 먼저 queue에 넣어준다.      matrix[row][col] = 0; // 마을 좌표의 값으로 소문이 퍼지는 데 걸리는 시간을 저장   while (queue.length &gt; 0) {     // 큐의 가장 앞 자리의 좌표를 얻는다.     const [row, col] = deQueue(queue);     cnt = matrix[row][col];      // 현재 지점을 기준으로 네 방향을 검토한다.     MOVES.forEach((move) =&gt; {       const nextRow = row + move[0];       const nextCol = col + move[1];       if (isValid(nextRow, nextCol) &amp;&amp; matrix[nextRow][nextCol] === '1') {          // 마을을 벗어나지 않고 소문이 퍼지지 않은 집을 queue에 넣어준다.         enQueue(queue, [nextRow, nextCol]);         matrix[nextRow][nextCol] = matrix[row][col] + 1; // 소문이 퍼진 시간 증가       }     });   }   return cnt; };   오늘 느낀 점  문제가 상당히 어렵다.. 길찾기(?) 알고리즘, 각 방향성을 갖고 모든 경우를 탐색하는 알고리즘이 다시 등장했다.   일단 쭉쭉 읽어 내려가며 이해는 하였지만, 다시 같은 문제를 풀으라하면 잘 모르겠다.. 다시 풀어볼 예정   내일 할 일     TOY 28. robotPath2  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.12.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 28. robotPath2",
        "excerpt":"  TOY 28. robotPath2  문제   세로와 가로의 길이가 각각 M, N인 방의 지도가 2차원 배열로 주어졌을 때, 1은 장애물을 의미하고 0 이동이 가능한 통로를 의미합니다. 로봇은 한 번에 임의의 k칸 직진과 90도 회전 중 1가지 동작을 할 수 있다. 로봇의 현재 위치와 방향, 목표 지점과 방향이 함께 주어집니다. 이 때, 방향은 위쪽이 1, 오른쪽이 2, 아래쪽이 3, 왼쪽이 4로 주어집니다. 로봇이 목표 지점까지 도달해 목표 방향으로 회전하는 데 필요한 동작의 수를 리턴해야 합니다.   입력   인자 1 : room     배열을 요소로 갖는 배열   room.length는 M   room[i]는 number 타입을 요소로 갖는 배열   room[i].length는 N   room[i][j]는 세로로 i, 가로로 j인 지점의 정보를 의미   room[i][j]는 0 또는 1   인자 2 : src     number 타입을 요소로 갖는 배열   src.length는 2   src[i]는 0 이상의 정수   src의 요소는 차례대로 좌표평면 위의 y좌표, x좌표   인자 3: sDir     number 타입의 자연수   인자 4 : dst     number 타입을 요소로 갖는 배열   dst.length는 2   dst[i]는 0 이상의 정수   dst의 요소는 차례대로 좌표평면 위의 y좌표, x좌표   인자 5 : dDir     number 타입의 자연수   출력      number 타입을 리턴해야 합니다.   주의사항      M, N은 20 이하의 자연수입니다.   src, dst는 항상 로봇이 지나갈 수 있는 통로입니다.   src에서 dst로 가는 경로가 항상 존재합니다.   목표 지점에 도달한 후 방향까지 일치해야 합니다.   직진은 1칸 직진이 아니라 임의의 k칸을 직진할 수 있습니다. 즉 한번의 직진 명령으로 장애물이 없는 한 계속 갈 수 있습니다.   왼쪽에서 오른쪽 또는 아래에서 위쪽으로 방향을 바꾸는 데 총 2번의 회전 동작이 필요합니다.   입출력 예시   let room = [   [0, 0, 0, 0],   [0, 1, 1, 0],   [0, 1, 0, 0],   [0, 0, 1, 1], ]; let src = [3, 0]; let sDir = 3; let dst = [2, 2]; let dDir = 2; let output = robotPath2(room, src, sDir, dst, dDir); console.log(output); // --&gt; 11 /* 1. 시작 - (3, 0)에서 아래 방향을 향한 상태 장애물은 x로 표시, 출발지점은 s로 표시 [   [0, 0, 0, 0],   [0, x, x, 0],   [0, x, 0, 0],   [s, 0, x, x], ]   2. 로봇은 아래 방향을 향하고 있음    3인 이유: 위로 가기 위해서는 90도 회전이 2번, 직진 1번 필요함. 직진 한번으로 도달할 수 있는 모든 칸을 표기.    2인 이유: 오른쪽으로 가기 위해서는 90도 회전 1번, 직진 1번이 필요함 [   [3, 0, 0, 0],   [3, x, x, 0],   [3, x, 0, 0],   [s, 2, x, x], ]   3. (0, 0) 지점에서 로봇은 위 방향을 향하고 있음    5인 이유: 오른쪽으로 가기 위해서는 90도 회전이 1번, 직진 1번 필요함.   1인 이유: 직진 1번으로 충분 [   [3, 5, 5, 5],   [3, x, x, 0],   [3, x, 0, 0],   [s, 2, x, x], ]   4. 비슷한 방식으로 계산하면 최종적으로 방향 전환까지 11번이 나오게 된다. */  room = [   [0, 0, 0, 0, 0, 0],   [0, 1, 1, 0, 1, 0],   [0, 1, 0, 0, 0, 0],   [0, 0, 1, 1, 1, 0],   [1, 0, 0, 0, 0, 0], ]; src = [4, 2]; sDir = 1; dst = [2, 2]; dDir = 3; output = robotPath2(room, src, sDir, dst, dDir); console.log(output); // --&gt; 7   TOY 28. Solution  수도코드    문제풀이      Reference Code  const robotPath2 = function (room, src, sDir, dst, dDir) {   // 가로와 세로의 길이   const R = room.length;   const C = room[0].length;   // 4가지 방향: 위(1), 오른쪽(2), 아래(3), 왼쪽(4)   // 차례대로 [방향, 상하이동, 좌우이동]   const MOVES = [     [1, -1, 0], // UP     [2, 0, 1], // RIGHT     [3, 1, 0], // DOWN     [4, 0, -1], // LEFT   ];    // 맵을 벗어나는지 확인   const isValid = (row, col) =&gt; row &gt;= 0 &amp;&amp; row &lt; R &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; C;    // 각 위치별 최소의 동작으로 도달 가능한 경우의 \"방향을 저장\"   const directions = [];   // 각 위치별 최소 \"동작의 수\"를 저장. 편의상 거리(dist)로 표현   const dist = [];   for (let row = 0; row &lt; R; row++) {     directions.push(Array(C).fill(0));     dist.push(Array(C).fill(Number.MAX_SAFE_INTEGER));   }    // bfs 구현을 위해 큐를 선언한다.   const queue = []   const enQueue = (queue, pos) =&gt; {     queue.push(pos)   };   const deQueue = (queue) =&gt; {     const pos = queue.shift()     return pos   };    // 출발 지점의 좌표   const [sRow, sCol] = src;   directions[sRow][sCol] = sDir; //방향 저장   dist[sRow][sCol] = 0; // 동작수 저장    // 목표 지점의 좌표   const [dRow, dCol] = dst;    enQueue(queue, [sRow, sCol]); // queue에 출발 지점의 좌표를 넣는다.    while (queue.length &gt; 0) {     const [row, col] = deQueue(queue);      const dir = directions[row][col]; // 방향      for (move of MOVES) {       const [nDir, rDiff, cDiff] = move;       // 이동할 좌표       const nRow = row + rDiff;       const nCol = col + cDiff;        // 맵을 벗어나거나 장애물(1)이 있으면 건너 뛴다.       if (isValid(nRow, nCol) === false || room[nRow][nCol] === 1) continue;        // 현재 위치의 방향과 이동할 방향과의 차이       const dDiff = Math.abs(nDir - dir);        let candidate;       if (dDiff === 0) {// 출발 지점에서의 방향과 이동하려는 방향이 같은 경우         // 직진만 하면 되지만 그러기 위해서는 1로 초기화 되어야 한다.         candidate = dist[row][col] || 1;       } else if (dDiff === 2) {         // 2번 회전해야 하는 경우: 회전 2 + 직진 1         candidate = dist[row][col] + 3;       } else {         // 1번만 회전해도 되는 경우: 회전 1 + 직진 1         candidate = dist[row][col] + 2;       }        if (nRow === dRow &amp;&amp; nCol === dCol) {         // 다음에 도달하는 곳이 목표 지점인 경우         // 목표 방향까지 고려해서 필요한 동작수를 계산한다.         const dDiff = Math.abs(nDir - dDir);         if (dDiff === 0) {           candidate = candidate;         } else if (dDiff === 2) {           candidate = candidate + 2;         } else {           candidate = candidate + 1;         }       }        if (candidate &lt; dist[nRow][nCol]) {         // 유망한 좌표는 큐에 삽입한다.         enQueue(queue, [nRow, nCol]);         dist[nRow][nCol] = candidate; // 해당 좌표에 동작수를 넣는다.         directions[nRow][nCol] = nDir; // 해당 좌표에 방향을 넣는다.       }     }   }    return dist[dRow][dCol]; // 도착지점에 있는 동작수를 리턴 };   오늘 느낀 점  Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정  내일 할 일     TOY 29. binaryHeap  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.13.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. DataBase & SQL 2. Schema design 3. DataBase 설계 4. Node.js에서 데이터베이스 사용",
        "excerpt":"  Today I Learnd  1. DataBase &amp; SQL   1-1. DataBase  데이터베이스는 IN-MEMORY, FILE I/O 방식의 한계와 관리하는 데이터의 양이 방대해짐에따라 효율적이고 데이터의 무결성을 지키기 위해 고안된 데이터에 특화된 서버이다.      이 데이터베이스가 활용되는 구조는 이전의 “2-TIER 아키텍쳐”인 클라이언트/서버의 구조에서 더 나아가, 웹&amp;앱에서 취급하는 데이터를 따로 분리 하는 “3-TIER 아키텍쳐”라 불리우며 보안성, 대용량 서비스에서의 강점을 지닐수 있게 되었다.    1-2. SQL          하나의 언어인 Structured Query Language (SQL) 은 데이터베이스 언어로, 주로 관계형 데이터베이스에서 사용한다. 예를 들어 MySQL, Oracle, SQLite, PostgreSQL 등 다양한 데이터베이스에서 SQL 구문을 사용하여 데이터베이스에 쿼리(Query) 를 보내 원하는 데이터를 가져오거나 삽입할 수 있다.              SQL을 사용할 수 있는 데이터베이스와 달리, 데이터의 구조가 고정되어 있지 않은 데이터베이스를 NoSQL이라고 한다. 관계형 데이터베이스와는 달리, 테이블을 사용하지 않고 데이터를 다른 형태로 저장을 한다. NoSQL의 대표적인 예시는 MongoDB 와 같은 문서 지향 데이터베이스가 있다.            SQL 문법은 링크를 통하여 학습하였다.        1-3. ACID  ACID(원자성, 일관성, 고립성, 지속성) 는 데이터베이스 트랜잭션 이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어이다.   여기서 트랜잭션이란? 데이터베이스의 상태를 변환시키는 논리적 기능을 수행하기 위해 행해지는 하나 이상의 쿼리를 모아 놓은 작업의 단위 이다.      원자성(Atomicity) 은 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.   일관성(Consistency) 은 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.   독립성(Isolation) 은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다. 공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다. 자세한 내용은 관련 문서를 참조해야 한다.   지속성(Durability) 은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.   2. Schema design   2-1. 스키마(Schema)     스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.   스키마는 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.   스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나눠진다.    2-2. Schema design (인스타그램 예제)        게시물(Post) 작성 기능 : 인스타그램에서는 여러 개의 사진(A)을 올릴 수 있다. 사진을 업로드할 때, 사진을 설명하는 간단한 글(C)이 올라간다.   게시물에 댓글 달기 및 좋아요 기능 : 게시물이 업로드되면 다른 사용자는 이 게시물에 댓글(E)을 달 수 있고, 좋아요(B) 를 눌러 관심을 표할 수 있다.   해시태그 기능 : 게시물에 #감성 #맛집 등의 해시태그(D)를 남길 수 있으며, 이 해시태그를 누르면 이 해시태그가 사용된 모든 게시물을 한 데 모아 볼 수 있다.   follow 기능 : 인스타그램에서 친구 관계는 팔로워(follower)와 팔로잉(following)으로 나뉜다. 김코딩이 최해커를 following 하면, 최해커의 피드가 김코딩의 홈 화면에 나타난다. 최해커의 입장에서는 김코딩이 follower로 추가된다.   해당 내용을 DB diagram에서 스키마 디자인을 해보면 다음 그림과 같다.     3. 관계형 데이터베이스     구조화된 데이터는 하나의 테이블로 표현할 수 있다. 사전에 정의된 테이블을 relation 이라고도 부르기 때문에, 테이블을 사용하는 데이터베이스를 관계형 데이터베이스(Relational database)라고 한다.   관계의 종류는 다음과 같다.            1:1 관계 : 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우, 그러나 1:1 관계는 자주 사용하지 않는다. 1:1로 나타낼 수 있는 관계라면 관계를 맺기보다 직접 저장하는 게 나을 수 있다.                1:N 관계 : 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우이다. 1:N(일대다) 관계는 관계형 데이터베이스에서 가장 많이 사용한다.           2-2. 스키마 디자인(인스타그램 예제)을 예로 든다면, 하나의 posts(게시글) 에는 여러개의 post_comments(댓글)을 가질 수 있다.                        N:N 관계 : 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우이다. N:N(다대다) 관계를 위해 스키마를 디자인할 때에는, Join 테이블을 만들어 관리해야한다. 1:N(일대다) 관계와 비슷하지만, 양방향에서 다수의 레코드를 가질 수 있다.           2-2. 스키마 디자인(인스타그램 예제)을 예로 든다면, posts(게시글)과 hashtags(태그)을 꼽을 수 있다. 이 과정에서 두 테이블을 엮기 위해서 posts_hashtags(Joint 테이블) 을 사용하였다.               Self Referencing 관계 : 때로는 테이블 내에서도 관계가 필요하다. 예를 들어 추천인이 누구인지 파악하기 위해 사용할 수 있다. 이 관계는 1:N(일대다) 관계와 유사하다고 생각할 수 있다. 그러나 일반적으로 1:N 관계는 서로 다른 테이블의 관계를 나타낼 때 표현하는 방법이다.           4. Node.js에서 데이터베이스 사용  .env 환경변수 파일을 통하여 dotenv 패키지로 환경변수를 변수처럼 가져와 사용 할 수 있음을 이미 우리는 학습하였다. 이를 통하여Node.js 환경에서 데이터베이스와 연결하는 부분은 이미 작성된 예제를 통하여 SQL 실습을 진행하였다.   자세한 내용은 링크 참조.         오늘 느낀 점  SQL 새로운 언어를 배웠다. 우선 첫 느낌은 뭐지 싶었는데 정말 엑셀과 유사하다…? 느낌이다. 여러 정보들을 시트(데이터베이스)에 담고 필요한 행과 열에 저장된 데이터 정보를 필터로 원하는값을 출력하는 느낌을 받았다.   실제로도 SQL Server에 담긴 정보를 Excel 파일로 내보낼 수 있는 기능도 있다는 걸 검색으로 알게되었다. (안써봤지만 몹시 유용해 보인다..)      일단 문법도 사람이 읽기 좋은 형태의 문법이기때문에 보고 쓰기에 어렵진 않지만, 학습할 내용이 조금 방대해보인다.. 실무에서는 데이터베이스만 따로 관리하는 DB 관리자가 있다는 얘기도 얼핏 들었다.   아직 단순하게 SQL을 써서 원하는 값을 추려내는 정도뿐이다. 앞으로 실제 예제를 통해서 데이터베이스를 활용하는 경험이 필요하다.         내일 할 일     [데이터베이스 MVC]  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.13.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 29. binaryHeap",
        "excerpt":"  TOY 29. binaryHeap  문제   정수를 요소로 갖는 배열을 입력받아 이진 힙(binary heap)* 을 리턴해야 합니다.     이진 힙(binary heap)은 노드의 값이 특정한 순서를 가지고 있는 완전 이진 트리(Complete Binary Tree)입니다.   완전 이진 트리는 이진 트리의 (마지막 레벨 또는 마지막 깊이를 제외하고) 모든 레벨이 노드로 가득 채워져 있어야 합니다. 마지막 레벨은 왼쪽부터 차례대로 채워져 있습니다.   이진 힙에서 부모 노드의 값이 (이진 트리이므로 2개의) 자식 노드의 값보다 큰 경우를 최대 힙(max heap), 반대의 경우를 최소 힙(min heap)이라고 합니다.     입력           인자 1 : arr       number 타입을 요소로 갖는 배열   arr[i]는 -100,000 이상 100,000 이하의 정수   arr.length는 100,000 이하     출력            number 타입을 요소로 갖는 배열을 리턴해야 합니다.   주의사항      최대 힙(max heap) 을 구현해야 합니다.   입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   최대 힙 구현을 위해 선언된 함수들(getParentIdx, insert)을 전부 완성해야 합니다.   swap, getParentIdx, insert를 전부 사용해야 합니다.   swap, binaryHeap을 수정하지 않아야 합니다.   테스트 케이스에서 힙 함수들을 정확히 구현했는지 함께 테스트합니다.   insert의 시간 복잡도는 O(logN)입니다.   주어진 배열을 내림차순으로 정렬(O(logN))해도 최대 힙의 조건을 만족합니다. 하지만 이는 insert를 구현하는 것과는 거리가 먼 방법이며, 테스트를 통과할 수도 없습니다.   입출력 예시   let output = binaryHeap([5, 4, 3, 2, 1]); console.log(output); // --&gt; [5, 4, 3, 2, 1]  output = binaryHeap([3, 1, 21]); console.log(output); // --&gt; [21, 1, 3]  output = binaryHeap([4, 10, 3, 5, 1]); console.log(output); // --&gt; [10, 5, 3, 4, 1]   힌트      이진 힙은 트리 객체를 이용해 구현할 수도 있고, 배열로도 구현할 수 있습니다. 사실 거의 모든 트리를 배열로 구현할 수 있습니다. 트리를 배열로 구현했을 때의 장점은 (데이터가 선형적으로 저장되기 때문에) 저장공간을 절약할 수 있고 노드 접근 시 오버헤드(재귀호출, 반복문 등)가 약간 줄어듭니다. 다만 이를 위해서 매우 복잡한 인덱스 관리가 필요합니다. 반면, 트리 객체를 이용한 구현은 직관적(이해하기 쉬움)입니다. 그 대신 저장 공간과 약간의 오버헤드를 희생해야 합니다. 거의 모든 기술(구현)은 다수의 선택 사이의 트레이드 오프(trade-off)입니다. 무엇을 선택할 지는 요구사항(requirements), 즉 주어진 문제의 제약과 조건을 고려하여 결정해야 합니다. 이 점을 반드시 기억하시기 바랍니다.   완전 이진 트리는 노드가 낮은 레벨부터 채워지고, 같은 레벨에서는 왼쪽부터 채워지기 때문에 배열로 구현하는 것이 쉽습니다.   최대 힙과 이진 검색 트리(binary search tree)는 둘다 완전 이진 트리입니다. 하지만 이진 검색 트리에서는 모든 노드가 정렬되는 것과 달리 최대 힙에서는 오직 부모 노드와 직계 자식들 간의 관계만 유지됩니다. 이는 아래의 사실로부터 바로 알 수 있습니다.            이진 검색 트리에서 오른쪽 자식 노드의 값은 부모 노드의 값보다 크지만, 최대 힙에서는 부모 노드의 값이 두 자식 노드의 값보다 크다.           아래와 같은 최대 힙에서 10을 삽입할 경우, 최대 힙을 유지하려면 어떻게 해야하는 지 고민하시기 바랍니다.         9    / \\   6   7  / \\ / \\ 4  5 2           최소 힙은 부모 노드의 값이 두 자식 노드의 값보다 작다는 점을 제외하고는 최대 힙과 구현이 일치합니다. 아래 링크는 최소 힙의 동작을 눈으로 직접 확인할 수 있습니다. 참고하시기 바랍니다.   TOY 29. Solution  수도코드   max heap을 구현하는 알고리즘을 요구하며, 문제의 틀은 아래와 같이 이미 구현이 되어있다.   // 아래 코드는 수정하지 마세요. function swap(idx1, idx2, arr) {   // 두 변수를 바꾸는 방법    // 1) 임시 변수를 활용한 방법   // let temp = arr[idx1];   // arr[idx1] = arr[idx2];   // arr[idx2] = temp;    // 2) Destructuring assignment를 활용한 방법   // arr이 reference type이라 가능   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];    // 3) XOR 연산을 활용한 방법   // arr이 reference type이라 가능   // arr[idx1] ^= arr[idx2];   // arr[idx2] ^= arr[idx1];   // arr[idx1] ^= arr[idx2]; }  function getParentIdx(idx) {   // TODO: 여기에 코드를 작성합니다. }  function insert(heap, item) {   // TODO: 여기에 코드를 작성합니다. }  // 아래 코드는 수정하지 마세요. const binaryHeap = function (arr) {   return arr.reduce((heap, item) =&gt; {     return insert(heap, item);   }, []); };   트리구조로 정렬된 구조를 배열로 max heap을 구현해야 하므로, INDEX를 철처히 관리해주어야 하는게 핵심이다.   getParentIdx 함수는 현재의 idx를 받아 부모 노드의 배열 idx를 반환 해주어야 한다. 인덱스값이 0부터 싲가하는 배열에 담는 이진탐색트리 구조이므로, 부모 노드는 자식 노드 (idx-1)/2 값의 소숫점을 버린 값이 된다.      위 그림을 보면 쉽게 이해 할 수 있다. 따라서 getParentIdx 함수는 parseInt혹은 Math.floor 메소드를 써서 쉽게 부모 노드의 idx값을 구할 수 있다.   다음으로 insert함수는 빈 heap에 새로 들어갈 요소의 인덱스를 기준으로 해당 부모 요소와 크기 비교 후 swap함수를 통해 두 요소의 위치를 바꿔주는 행위를 새 요소가 현재 인덱스 기준으로 부모 요소보다 큰 경우 반복해주면 된다.  문제풀이   function swap(idx1, idx2, arr) {   // 두 변수를 바꾸는 방법   // 구조 분해 할당 활용 -&gt; arr가 reference type이라 가능함   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]; };  function getParentIdx(idx) {   // 인덱스가 0부터 시작하는 이진트리의 부모노드 인덱스 값 구하기.   return Math.floor((idx - 1) / 2); };  function insert(heap, item) {   heap.push(item);   let curIdx = heap.length - 1;  // 현재 노드의 위치   let pIdx = getParentIdx(curIdx);  // 부모 노드의 위치      // 부모 노드의 값이 유효하며, 현재 노드에 들어간 값이 부모 노드의 값보다 크면 while 구문 실행   while (pIdx &gt;= 0 &amp;&amp; heap[curIdx] &gt; heap[pIdx]) {     // 현재 노드와 부모 노드 배열자리 swap     swap(curIdx, pIdx, heap);     // swap 후 idx 교체 작업     curIdx = pIdx;     // 부모 idx는 swap후 curIdx의 부모 idx로 값을 다시 할당     pIdx = getParentIdx(curIdx);   }   return heap; };  function binaryHeap(arr) {   return arr.reduce((heap, item) =&gt; {     return insert(heap, item);   }, []); };    Reference Code  // 아래 코드는 수정하지 마세요. function swap(idx1, idx2, arr) {   // 두 변수를 바꾸는 방법    // 1) 임시 변수를 활용한 방법   // let temp = arr[idx1];   // arr[idx1] = arr[idx2];   // arr[idx2] = temp;    // 2) Destructuring assignment를 활용한 방법   // arr이 reference type이라 가능   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];    // 3) XOR 연산을 활용한 방법   // arr이 reference type이라 가능   // arr[idx1] ^= arr[idx2];   // arr[idx2] ^= arr[idx1];   // arr[idx1] ^= arr[idx2]; }  function getParentIdx(idx) {   // TODO: 여기에 코드를 작성합니다.   return Math.floor((idx - 1) / 2); }  function insert(heap, item) {   // TODO: 여기에 코드를 작성합니다.   heap.push(item);   let curIdx = heap.length - 1;   let pIdx = getParentIdx(curIdx);   while (pIdx &gt;= 0 &amp;&amp; heap[curIdx] &gt; heap[pIdx]) {     swap(curIdx, pIdx, heap);     curIdx = pIdx;     pIdx = getParentIdx(curIdx);   }   return heap; }  // 아래 코드는 수정하지 마세요. const binaryHeap = function (arr) {   return arr.reduce((heap, item) =&gt; {     return insert(heap, item);   }, []); };   오늘 느낀 점  정렬..참 종류도 많다. 힙 정렬 같은 경우 이진탐색 트리의 특성을 잘 활용한 정렬이라 느껴졌다.   이진트리를 배열로 표현할 경우 인덱스를 구하는 방식의 규칙을 깨닫고나니 어려운 문제는 아니라 느껴졌다. (물론 레퍼런스 코드를 보고 풀었지만..)  내일 할 일     TOY 30. heapSort  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.14.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 30. heapSort",
        "excerpt":"  TOY 30. heapSort  문제   정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.  입력   인자 1 : arr     number 타입을 요소로 갖는 배열   arr[i]는 -100,000 이상 100,000 이하의 정수   arr.length는 100,000 이하   출력      number 타입을 요소로 갖는 배열을 리턴해야 합니다.   주의사항      힙 정렬을 구현해야 합니다.   arr.sort 사용은 금지됩니다.   입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.   최소 힙(min heap) 을 구현해야 합니다.   최소 힙 구현을 위해 선언된 함수들(getParentIdx, insert, removeRoot)을 전부 완성해야 합니다.   swap, getParentIdx, insert, removeRoot를 전부 사용해야 합니다.   swap, binaryHeap을 수정하지 않아야 합니다.   테스트 케이스에서 힙 함수들을 정확히 구현했는지 함께 테스트합니다.   removeRoot의 시간 복잡도는 O(logN)입니다.   입출력 예시   let output = heapSort([5, 4, 3, 2, 1]); console.log(output); // --&gt; [1, 2, 3, 4, 5]  output = heapSort([3, 1, 21]); console.log(output); // --&gt; [1, 3, 21]  output = heapSort([4, 10, 3, 5, 1]); console.log(output); // --&gt; [1, 3, 4, 5, 10]   힌트      앞에서 말했듯이, 최소 힙은 최대 힙과 구현이 거의 일치한다. 아래 링크를 다시 한번 참고하시기 바랍니다.            https://www.cs.usfca.edu/~galles/visualization/Heap.html           아래와 같은 최소 힙에서 루트 노드의 값(2)은 전체 노드의 값 중에서 가장 작습니다. 루트 노드를 제거한 후에도 최소 힙을 유지해야 하려면 어떤 작업이 필요한 지 고민하시기 바랍니다. 2가 제거된 후의 최소 힙의 루트 노드는 2를 제외한 값 중 가장 작은 값(3)이 되어야 합니다. 아래와 같은 사실로부터 힙 정렬에 대한 아이디어를 얻길 바랍니다.            루트 노드를 제거하고(가장 작은 값을 제거하고) 다시 최소 힙을 유지하면, 새로운 루트 노드의 값은 그 다음으로 가장 작은 값이다.               2    / \\   5   3  / \\ / \\ 6  8 7  9           TOY 30. Solution  수도코드   heap 정렬을 구현하는 알고리즘이다. max heap을 구현하는 알고리즘을 요구하며, 문제의 틀은 아래와 같이 이미 구현이 되어있다.   // 아래 코드는 수정하지 마세요. function swap(idx1, idx2, arr) {   // 두 변수를 바꾸는 방법    // 1) 임시 변수를 활용한 방법   // let temp = arr[idx1];   // arr[idx1] = arr[idx2];   // arr[idx2] = temp;    // 2) Destructuring assignment를 활용한 방법   // arr이 reference type이라 가능   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];    // 3) XOR 연산을 활용한 방법   // arr이 reference type이라 가능   // arr[idx1] ^= arr[idx2];   // arr[idx2] ^= arr[idx1];   // arr[idx1] ^= arr[idx2]; }  function getParentIdx(idx) {   // TODO: 여기에 코드를 작성합니다. }  function insert(heap, item) {   // TODO: 여기에 코드를 작성합니다. }  // 아래 코드는 수정하지 마세요. const binaryHeap = function (arr) {   return arr.reduce((heap, item) =&gt; {     return insert(heap, item);   }, []); };   트리구조로 정렬된 구조를 배열로 max heap을 구현해야 하므로, INDEX를 철처히 관리해주어야 하는게 핵심이다.   getParentIdx 함수는 현재의 idx를 받아 부모 노드의 배열 idx를 반환 해주어야 한다. 인덱스값이 0부터 싲가하는 배열에 담는 이진탐색트리 구조이므로, 부모 노드는 자식 노드 (idx-1)/2 값의 소숫점을 버린 값이 된다.      위 그림을 보면 쉽게 이해 할 수 있다. 따라서 getParentIdx 함수는 parseInt혹은 Math.floor 메소드를 써서 쉽게 부모 노드의 idx값을 구할 수 있다.   다음으로 insert함수는 빈 heap에 새로 들어갈 요소의 인덱스를 기준으로 해당 부모 요소와 크기 비교 후 swap함수를 통해 두 요소의 위치를 바꿔주는 행위를 새 요소가 현재 인덱스 기준으로 부모 요소보다 큰 경우 반복해주면 된다.  문제풀이   // 아래 코드는 수정하지 마세요. function swap(idx1, idx2, arr) {   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]; }  function getParentIdx(idx) {   // TODO: 여기에 코드를 작성합니다.   return Math.floor((idx - 1) / 2); }  function insert(heap, item) {   heap.push(item);   let curIdx = heap.length - 1;  // 현재 노드의 위차   let pIdx = getParentIdx(curIdx);  // 부모 노드의 위치      // 부모 노드의 값이 유효하며, 현재 노드에 들어간 값이 부모 노드의 값보다 크면 while 구문 실행   while (pIdx &gt;= 0 &amp;&amp; heap[curIdx] &lt; heap[pIdx]) { // max heap 반대     // 현재 노드와 부모 노드 배열자리 swap     swap(curIdx, pIdx, heap);     // swap 후 idx 교체 작업     curIdx = pIdx;     // 부모 idx는 swap후 curIdx의 부모 idx로 값을 다시 할당     pIdx = getParentIdx(curIdx);   }   return heap; }  function removeRoot(heap) {   // TODO: 여기에 코드를 작성합니다.   swap(0, heap.length - 1, heap); // 배열의 첫번째(최솟값)과 배열의 마지막 값을 바꾼다.   heap.pop(); // 배열의 최솟값 제거    if (heap.length === 0) return [];    // 다시 최소힙을 유지   let curIdx;   let minIdx = 0;   while (curIdx !== minIdx) {     curIdx = minIdx;     let left = curIdx * 2 + 1;     let right = curIdx * 2 + 2;     if (left &lt; heap.length &amp;&amp; heap[left] &lt; heap[minIdx]) {       minIdx = left;     }     if (right &lt; heap.length &amp;&amp; heap[right] &lt; heap[minIdx]) {       minIdx = right;     }     swap(curIdx, minIdx, heap);   }   return heap; }  // 아래 코드는 수정하지 마세요. const binaryHeap = function (arr) {   return arr.reduce((heap, item) =&gt; {     return insert(heap, item);   }, []); };  const heapSort = function (arr) {   let minHeap = binaryHeap(arr);   // TODO: 여기에 코드를 작성합니다.   const sorted = [];   while (minHeap.length &gt; 0) {     sorted.push(minHeap[0]);     minHeap = removeRoot(minHeap);   }   return sorted; };    Reference Code  // 아래 코드는 수정하지 마세요. function swap(idx1, idx2, arr) {   // 두 변수를 바꾸는 방법    // 1) 임시 변수를 활용한 방법   // let temp = arr[idx1];   // arr[idx1] = arr[idx2];   // arr[idx2] = temp;    // 2) Destructuring assignment를 활용한 방법   // arr이 reference type이라 가능   [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];    // 3) XOR 연산을 활용한 방법   // arr이 reference type이라 가능   // arr[idx1] ^= arr[idx2];   // arr[idx2] ^= arr[idx1];   // arr[idx1] ^= arr[idx2]; }  function getParentIdx(idx) {   // TODO: 여기에 코드를 작성합니다.   return Math.floor((idx - 1) / 2); }  function insert(heap, item) {   // TODO: 여기에 코드를 작성합니다.   heap.push(item);   let curIdx = heap.length - 1;   let pIdx = getParentIdx(curIdx);   while (pIdx &gt;= 0 &amp;&amp; heap[curIdx] &gt; heap[pIdx]) {     swap(curIdx, pIdx, heap);     curIdx = pIdx;     pIdx = getParentIdx(curIdx);   }   return heap; }  // 아래 코드는 수정하지 마세요. const binaryHeap = function (arr) {   return arr.reduce((heap, item) =&gt; {     return insert(heap, item);   }, []); };   오늘 느낀 점  정렬..참 종류도 많다. 힙 정렬 같은 경우 이진탐색 트리의 특성을 잘 활용한 정렬이라 느껴졌다.   이진트리를 배열로 표현할 경우 인덱스를 구하는 방식의 규칙을 깨닫고나니 어려운 문제는 아니라 느껴졌다. (물론 레퍼런스 코드를 보고 풀었지만..)  내일 할 일     TOY 30. heapSort  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.15.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. MVC 2. Cmarket Database",
        "excerpt":"  Today I Learnd  1. MVC    모델-뷰-컨트롤러(model–view–controller, MVC)는 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴이다.      하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 디자인 패턴을 일컫는다.  1-1. 웹 애플리케이션 MVC design pattern    위의 모식도는 개념적인 MVC 를 나타낸 그림이며, 대부분의 웹 애플리케이션에서의 MVC는 다음 아래와 같은 구조로 이루어진다.      모델-뷰-컨트롤러 각각의 구성요소들 사이에는 다음과 같은 관계가 있다.      모델(Model) : 애플리케이션의 정보, 데이터를 나타낸다. 데이타베이스 혹은 또한 이러한 여러 정보들의 가공을 책임지는 컴포넌트를 말한다.   뷰(View) : input 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타낸다. 다시 말해 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당한다.   컨트롤러(Controller) : 데이터와 사용자인터페이스 요소들을 잇는 다리역할을 한다. 즉, 사용자가 데이터를 클릭하고, 수정하는 것에 대한 “이벤트”들을 처리하는 부분이다.   2. Cmarket Database    MVC 모델 디자인 관념으로 본다면, V(client)는 완성되어 있다.   3 tier architecture 완성시키는게 목적인 스프린트이다.   2-1. Database(스키마, 시드파일)           DB 작성은 커맨드 창에 명령어를 하나하나 입력하는 방법과 다르게, 미리 구성되어 있는 Cmarket 스키마를 기반으로 MySQL에 배치모드를 활용하여 cmarket 데이터베이스의 테이블을 생성한다.            우선 스키마는 im-sprint-cmarket-database/server/schema.sql 파일에 명시되어 있다. 해당 파일을 들여다 보면 다음과 같다.       CREATE TABLE users ( /* 테이블 생성 : CREATE TABLE 테이블이름 */   id INT AUTO_INCREMENT,   username varchar(255),   PRIMARY KEY (id) );   /* ...생략 */   ALTER TABLE orders ADD FOREIGN KEY (user_id) REFERENCES users (id); /* 테이블 수정(컬럼 추가[외래키]) : ALTER TABLE 테이블이름 ADD ~ */                시드파일은  im-sprint-cmarket-database/server/seed.sql 파일에 명시되어 있다. 해당 파일을 들여다 보면 다음과 같다.       /* ...생략  */  INSERT INTO users (username) VALUES (\"김코딩\"); /* INSERT INTO 테이블이름(필드이름1 ...) VALUES (데이터값...) */                스프린트에서는 위 schema.sql파일과 seed.sql파일을 토대로 node.j mysql 모듈을 통해서 DB를 다룬다. im-sprint-cmarket-database/server/db/index.js 파일을 살펴보면 다음과 같다.       const mysql = require('mysql');  // mysql 모듈 사용 선언, npm install mysql 후 사용가능하다. const dotenv = require('dotenv');  // DB 비밀번호등 환경변수는 .env 모듈을 통해 사용한다. const config = require('../config/config'); // config 또한 환경변수를 다루는 모듈이다. .env와 함께 사용한다. dotenv.config(); // 환경변수 불러오기    const con = mysql.createConnection(  // mysql 연결   config[process.env.NODE_ENV || 'development'] // development 환경, test 환경 이지선다로 실행한다. (서버를 킨 채로 test를 실행하면 오류 발생의 원인) );  // ...생략                  im-sprint-cmarket-database/server/.env.sample 과 im-sprint-cmarket-database/server/config/config.js 파일에 환경변수들이 담겨져있다. 개발환경에 맞게 설정하자.            위와 같은 설정이 모두 끝났다면, config.js 파일에 DB 이름은 cmarket 으로 설정되어 있으므로 mysql을 통해서 빈 cmarket DB를 만들어 준다   schema.sql 파일을 활용하여 내부 테이블을 배치모드로 한번에 만들 수 있게 된다. mysql -u (유저이름) -p &lt; server/schema.sql -Dcmarket   seed.sql 파일을 활용하여 테이블 내에 준비된 시드파일을 심어준다. mysql -u (유저이름) -p &lt; server/seed.sql -Dcmarket     2-2. 서버      서버를 실행하기 전, 위에서 만든 DB를 사용하게끔 환경 설정이 필요하다.        package.json을 확인하면 dependencies에 mysql 모듈이 있다.  이 모듈을 통해 서버와 데이터베이스서버를 연결해줄 수 있다.       해당 모듈을 통해 mysql에 접속하기 위한 username, password를 코드에 작성할 수도 있겠지만, 보안상/편의상 이유로 비밀번호는 .env 파일에 환경 변수로 분리해놓고, .gitignore에 .env파일을 올려두어 외부에 노출되지 않게끔 관리되고 있음을 볼 수 있다.            해당 환경을 서버에서 사용하기 위해 config/config.js파일을 보면 .env 와 연결되어 있는 걸 볼 수 있다.        즉, .env 파일을 통해 환경변수 등 민감한 개인정보가 외부로 노출되지 않게끔 설정하고, .env파일을 config.js 에 연결하여  환경변수를 서버에서 활용하는 모습을 볼 수 있다.         const dotenv = require('dotenv');  /* .env 사용 */   dotenv.config();    const config = {       development: {           host: 'localhost',           user: process.env.DATABASE_SPRINT_USER,  /* .env 환경변수 사용 */           password: process.env.DATABASE_SPRINT_PASSWORD,           database: 'cmarket'       } \t\t   /* 생략 */                이제 mysql DB가 node.js 서버환경에서 어떻게 사용되는지는 파악하였다. 이제 스프린트 통과를 위해 서버를 보자면, app.js 파일에는 express로 서버를 만드는 코드가 이미 작성되어있다.         const express = require('express');   const indexRouter = require('./routes');   const cors = require('cors');   const morgan = require('morgan');   const app = express();   const port = 4000;    app.use(       morgan('      :method :url :status :res[content-length] - :response-time ms')   );   app.use(cors());   app.use(express.urlencoded({ extended: true }));   app.use(express.json());   app.use('/', indexRouter);  /* router 진입점 */    module.exports = app.listen(port, () =&gt; {       console.log(`      🚀 Server is starting on ${port}`);   });           해당 코드를 통해 router 진입점을 알 수 있다.  라우팅 연결 시작점을 알았으니 해당 진입점부터 작성해나가자.       2-3. Router           라우터는 컨트롤러로 진입할 수 있게 도와주는 endpoint이다.       스프린트에서 요구하는 endpoint는 세가지이다.    아래의 요구사항에 맞춰서 users router 파일을 추가로 작성해주고, routes/index.js 파일에서도 routes/users.js 로 연결되게끔 설정해 준다.             GET /items       GET /users/:userId/orders       POST /users/:userId/orders                따라서 routes/index.js에서는,         const itemsRouter = require('./items'); /* GET/items */   const usersRouter = require('./users'); /* GET /users/:userId/orders 와 POST /users/:userId/orders */    // TODO: Endpoint에 따라 적절한 Router로 연결해야 합니다.   router.use('/items', itemsRouter);   router.use('/users', usersRouter);           위와 같이 routes/users.js로 연결을 해줘야 한다.            그리고 routes/users.js에서는 각 endpoint에 알맞게 작성해준다.         const controller = require('./../controllers');    router.get('/:userId/orders', controller.orders.get);   router.post('/:userId/orders', controller.orders.post);           2-4. Controller      세 endpoint에 이르는 경로는 router에서 모두 구현을 하였다.   이제 각 endpoint에 대한 각기 다른 구현이 필요하다. controller를 작성해보자.   아이템 가져오기 : GET /items           스프린트에서 이미 작성되어 있다.         items: {           get: (req, res) =&gt; {               models.items.get((error, result) =&gt; {                   if (error) {                       res.status(500).send('Internal Server Error');                   } else {                       res.status(200).json(result);                   }               });           },       },           요구사항도 Response로 json 형식으로 데이터값을 받으며 상태코드 200번을 출력하라는 요구사항이니 문제없이 통과가 된다.       주문하기 : POST /users/:userId/orders           우선 주문은 해당 json 형식으로 주문을 해야 한다.         {       \"orders\": [           {               \"quantity\": 1,               \"itemId\": 2           }           // ...여러 개의 주문 아이템       ],       \"totalPrice\": 16900   }           POST /users/:userId/orders 요청에서 클라이언트가 잘못된 요청을 했을 경우 상태코드 400을 보내야합니다.  POST /users/:userId/orders 요청에 성공했을 경우 상태코드 201을 보내야합니다.       그리고 위 두가지의 테스트케이스를 통과해야한다.            우선 테스트 케이스의 잘못된 요청이 들어온 경우는 req.body로 받아온 orders, totalPrice의 값이 올바르지 못한 경우를 말한다.         if (!orders || !totalPrice) {  /* 잘못된 요청이 들어 올경우 400번 */       return res.status(400).send('잘못된 요청');   }                그리고 요청에 성공하는 경우 201번과 위에 있는 json 형식에 알맞는 주문을 받아야 한다.       주문에 필요한 인자는 userId, orders, totalPrice 이다. 해당 값들을 적절히 사용하면 POST /users/:userId/orders endpoint는 다음과 같이 작성이 가능하다.         post: (req, res) =&gt; {       const userId = req.params.userId;       const { orders, totalPrice } = req.body;       // TODO: 요청에 따른 적절한 응답을 돌려주는 컨트롤러를 작성하세요.        if (!orders || !totalPrice) {  /* 잘못된 요청이 들어 올경우 400번 */           return res.status(400).send('Bad request');       } else {           models.orders.post(userId, orders, totalPrice,(error, result) =&gt; {                 if (error) {                   res.status(500).send('Internal Server Error');               } else {                   res.status(201).json('success POST');               }           });       }   }           주문 내역 조회 : GET /users/:userId/orders           주문 내역 조회는 userId를 params로 받아와서 json형태로 상태코드 200번과 함께 Response 해주면 되는 간단한 로직이다. DB의 구조가 복잡하고 양이 많지만…해당 부분은 Models에서 제어하자.       다음과 같은 json 형식으로 반환해주어야 한다.         [       {           \"id\": 1, // orders 테이블의 id           \"created_at\": \"2021-02-19T04:34:11.000Z\",               \"total_price\": 7800,           \"name\": \"칼라 립스틱\",            \"price\": 2900,           \"image\": \"../images/lip.jpg\",           \"order_quantity\": 1,       },       {           \"id\": 1,           \"created_at\": \"2021-02-19T04:34:11.000Z\",           \"total_price\": 7800,           \"name\": \"뜯어온 보도블럭\",           \"price\": 4900,           \"image\": \"../images/block.jpg\",           \"order_quantity\": 1,       },       // ...여러 개의 주문내역   ];                아이템 가져오기 로직과 비슷하다. userId params만 추가해서 해당 내역만 뿌려주면 된다.         get: (req, res) =&gt; {       const userId = req.params.userId;       // TODO: 요청에 따른 적절한 응답을 돌려주는 컨트롤러를 작성하세요.       models.orders.get(userId, (error, result) =&gt; {           res.status(200).json(result);       });   }           2-5. Model      server/models/index.js 파일에서는 controller 에서 사용할 orders, items 모델을 정의해야 한다.   server/db/index.js 의 함수를 불러온 뒤, SQL 쿼리문으로 DB의 정보를 처리해 주어야 하는 구조이다.  데이터베이스 쿼리는 비동기 요청으로 진행 되야 하는 점을 고려하여 작성하자.   아이템 가져오기 SQL 쿼리문           간단하다. items 테이블의 내용을 모두 보여주는 쿼리문을 작성하면 된다.         get: (callback) =&gt; {       // TODO: Cmarket의 모든 상품을 가져오는 함수를 작성하세요       const queryString = `SELECT * FROM items`;        db.query(queryString, (error, result) =&gt; {           callback(error, result);       });   }           주문하기 SQL 쿼리문           주문하기 가 구현이 다소 복잡하다. 우선 다시 주문 json 형식을 보자면,         {       \"orders\": [           {               \"quantity\": 1,               \"itemId\": 2           }           // ...여러 개의 주문 아이템           ],       \"totalPrice\": 16900   }           orders라는 1개의 주문안에 배열 형식으로 여러개의 주문 아이템과 totalPrice 값이 들어가 있는 걸 확인 할 수 있다.       즉,  orders 쿼리문과 내부에 들어가는 items 쿼리문 두개의 쿼리가 이중으로 필요함을 알 수 있다.   orders는 userId와 totalPrice가 들어가야 하며, 내부에서는 orders_items의 목록(order_id, item_id, order_quantity)을 쏴주는 쿼리가 필요함을 알 수 있다.         post: (userId, orders, totalPrice, callback) =&gt; {       // TODO: 해당 유저의 주문 요청을 데이터베이스에 생성하는 함수를 작성하세요       const orderPostSQL = `INSERT INTO orders(user_id, total_price) VALUES (${userId}, ${totalPrice})`;       const orderItemPostSQL = `INSERT INTO order_items(order_id, item_id, order_quantity) VALUES ?`;        db.query(orderPostSQL, (error, result) =&gt; {             let params = orders.map(item =&gt; [                result.insertId, //result 객체 내부의 insertId 활용               item.itemId,               item.quantity           ]);            db.query(orderItemPostSQL, [params], () =&gt; callback(error, result));       });   }                orderItemPostSQL의 VALUES값은 prepared statement 방식으로 처리하였다.       주문 내역 조회 SQL 쿼리문           간단하면서…복잡하다. 여러개의 join문을 통해서 원하는 데이터 값을 모두 출력하는 쿼리문을 완성하자.         get: (userId, callback) =&gt; {       // TODO: 해당 유저가 작성한 모든 주문을 가져오는 함수를 작성하세요       const orderGetSQL = `           SELECT orders.id, orders.created_at, orders.total_price, items.name, items.price, items.image, order_items.order_quantity            FROM orders INNER JOIN order_items ON orders.id = order_items.order_id           INNER JOIN items ON order_items.item_id = items.id           INNER JOIN users ON orders.user_id = users.id           WHERE users.id = ${userId}       `;        db.query(orderGetSQL, (error, result) =&gt; {           callback(error, result);       });   }                    오늘 느낀 점  MVC 로 나뉘어진 3 tier architecture를 만들어 내는 것이 이번 스프린트의 핵심이다.   순수 mysql문을 이용하여 node.js에서 활용하는 프레임워크를 배웠다.    mysql 문법자체가 어렵진 않기때문에 갓 구글링, 어렵지 않게 쿼리문들을 작성할 수 있었다.   앞으로 만들어 내야할 웹 애플리케이션의 초석을 오늘 시간에 다진거 같다.  이러한 나눠진 디자인 패턴으로 인해 각각의 역할이 뚜렷하게 구분이 되며, 코드의 유지보수성이 확실히 올라가는 구조다…라는 개념정도는 학습한 것 같다.         내일 할 일     [데이터베이스 MVC]  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.15.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 31. rangeMinimum",
        "excerpt":"  TOY 31. rangeMinimum  문제   정수를 요소로 갖는 배열과 특정 구간을 입력받아, 해당 구간 내에서 최소값을 리턴해야 합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 배열   arr.length는 500,000 이하   arr[i]는 -100,000 이상 100,000 이하의 정수   인자 2 : ranges     number 타입을 요소로 갖는 배열   ranges.length는 10,000 이하   ranges[i]는 특정 구간을 의미   ranges[i][0]은 i번째 구간의 시작 인덱스   ranges[i][1]은 i번째 구간의 마지막 인덱스   출력      배열(arr)를 리턴해야 합니다. (입출력 예시 참고)   arr[i]는 i번째 구간(ranges[i])의 최소값   입출력 예시   const arr = [1, 3, 2, 7, 9, 11]; const mins = rangeMinimum(arr, [   [1, 4],   [0, 3], ]); console.log(mins); // --&gt; [2, 1]   Advanced     Advanced1: 주어진 배열에서 특정 구간의 최소값을 구하는 단순한 알고리즘은 단순 순회(O(N))입니다. 같은 배열에 대해서 다양한 구간에 대한 최소값을 구할 경우, 단순 순회는 O(N^2) 입니다(구간의 개수도 N개라 가정할 경우). 적절한 자료구조를 통해 이와 같은 구간 조회에 대한 반복 작업을 효율적(O(N * logN))으로 수행할 수 있습니다. 구간 트리(segment tree)에 대해서 학습하시고, Advanced 테스트 케이스를 통과해 보시기 바랍니다.   트리를 객체 또는 배열로 구현할 수 있습니다. 객체로 구현하는 것이 보다 직관적이기 때문에 객체로 먼저 도전하시기 바랍니다. 레퍼런스는 모두 주어집니다.   구간의 최대값, 합도 동일한 로직으로 구현하면 됩니다.   TOY 31. Solution  수도코드   Advanced가 아니라면 한번의 반복문을 사용해서 문제를 해결할 수 있다(O(n)). 구간 하나를 가져와서 그 구간 사이의 값을 for문을 통해 최솟값을 리턴해준다.   Advanced 코드는 Reference Code를 보았다.   문제풀이       Reference Code  // naive solution: O(N) (search only) // const rangeMinimum = function (arr, ranges) { //   return ranges.map((range) =&gt; { //     const [start, end] = range; //     let min = Number.MAX_SAFE_INTEGER; //     for (let i = start; i &lt;= end; i++) { //       if (arr[i] &lt; min) min = arr[i]; //     } //     return min; //   }); // };  // solution with segment tree: O(logN) (search only) // object implementaion const rangeMinimum = function (arr, ranges) {   // ts: tree start. te: tree end   // arr의 ts부터 te까지를 tree로 만든다.   const createMinTree = (arr, ts, te) =&gt; {     // base case     if (ts === te) {       return { value: arr[ts] };     }      // recursive case     // 현재 범위를 절반을 기준으로 왼쪽과 오른쪽으로 나눈다     const mid = parseInt((ts + te) / 2);     const left = createMinTree(arr, ts, mid);     const right = createMinTree(arr, mid + 1, te);      return {       value: Math.min(left.value, right.value),       left,       right,     };   };   const tree = createMinTree(arr, 0, arr.length - 1);    // rs: range start, re: reange end   const findMin = (ts, te, rs, re, tree) =&gt; {     // 현재 tree와 구간이 정확히 일치하거나     // 구간이 tree를 포함할 경우     if (rs &lt;= ts &amp;&amp; te &lt;= re) {       return tree.value;     }      // 현재 tree에 주어진 구간이 겹치지 않는 경우     if (te &lt; rs || re &lt; ts) {       return Number.MAX_SAFE_INTEGER;     }      // 겹치는 부분이 존재하는 경우     const mid = parseInt((ts + te) / 2);     return Math.min(       findMin(ts, mid, rs, re, tree.left), //       findMin(mid + 1, te, rs, re, tree.right)     );   };    const mins = ranges.map((range) =&gt; {     const [start, end] = range;     return findMin(0, arr.length - 1, start, end, tree);   });   return mins; };  // solution with segment tree: O(logN) (search only) // array implementaion // const rangeMinimum = function (arr, ranges) { //   const createMinTree = (arr, ts, te, tree, idx) =&gt; { //     if (ts === te) { //       tree[idx] = arr[ts]; //       return arr[ts]; //     }  //     const mid = Math.floor((ts + te) / 2); //     tree[idx] = Math.min( //       createMinTree(arr, ts, mid, tree, idx * 2 + 1), // //       createMinTree(arr, mid + 1, te, tree, idx * 2 + 2) //     );  //     return tree[idx]; //   };  //   // 트리 전체의 높이(루트 노트에서 가장 깊은 리프 노드까지의 거리)를 구하고 //   // 전체 배열의 크기를 구한다. //   const height = Math.ceil(Math.log2(arr.length)); //   const size = Math.pow(2, height + 1) - 1; //   const tree = Array(size).fill(null); //   createMinTree(arr, 0, arr.length - 1, tree, 0);  //   const findMin = (ts, te, rs, re, idx) =&gt; { //     if (rs &lt;= ts &amp;&amp; te &lt;= re) { //       return tree[idx]; //     }  //     if (te &lt; rs || re &lt; ts) { //       return Number.MAX_SAFE_INTEGER; //     }  //     const mid = parseInt((ts + te) / 2); //     return Math.min( //       findMin(ts, mid, rs, re, 2 * idx + 1), // //       findMin(mid + 1, te, rs, re, 2 * idx + 2) //     ); //   };  //   const mins = ranges.map((range) =&gt; { //     const [start, end] = range; //     return findMin(0, arr.length - 1, start, end, 0); //   }); //   return mins; // };   오늘 느낀 점  Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정  내일 할 일     TOY 32. largestRectangularArea  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.18.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. ORM 2. Sequelize 3. Short.ly MVC",
        "excerpt":"  Today I Learnd  1. ORM(Object-Relational Mapping)           ORM은 SQL문을 사용하지 않고 JS문법을 통해서 Object로 DB에 접근할 수 있도록 돕는 역할을 한다.              ORM은 SQL문법 대신 어플리케이션의 개발언어를 그대로 사용할 수 있게 함으로써, 개발 언어의 일관성과 가독성을 높여준다는 장점을 갖고 있다.            ORM에는 여러가지 종류 (Django — ORM cookbook, Node.js — Sequalize, Java — Hibernate, JPA 등) 가 있지만, 학습방향과 알맞는 Node.js — Sequalize 를 사용 할 예정이다.       2. Sequelize      Sequelize란 Node.JS에서 mysql을 사용할 때 Query문을 사용하지 않고 더욱 쉽게 다룰 수 있도록 도와주는 라이브러리이다.        Sequelize는 자바스크립트 객체와 데이터베이스의 릴레이션을 매핑해주므로 자바스크립트 구문을 알아서 SQL문으로 변경해준다.       사용방법은 공식문서와 아래의 스프린트(Short.ly MVC)를 통해 학습하였다.       3. Short.ly MVC   MVC(Model–View–Controller) 모델 디자인중 V(Client)가 빠진 형태의 구조이다.   이번 스프린트의 목적은 ORM(Node.JS-Sequelize)에 익숙해지는데 목적이 있다.    3-1. 사전 준비: sequelize 및 sequelize-cli 설치      Sequelize ORM 공식문서를 보고 sequelize 설치를 하였으며 package.json 파일의 dependencies 모듈을 확인해보니 \"sequelize\": \"^6.9.0\" 를 확인 할 수 있었다.    Sequelize - Migrations 문서를 통해 sequelize-cli 를 설치하였으며 마찬가지로 devDependencies 모듈에서 \"sequelize-cli\": \"^6.3.0\" 를 확인 할 수 있었다.   3-2. ORM 설정           성공적으로 bootstraping이 끝나면 다음 파일 및 폴더들이 생성된다.              config/config.json  models/  migrations/  seeders/                 우선 config.json 파일을 확인하여서 mysql 환경과 일치하는 환경으로 설정해준다.       {   \"development\": {     \"username\": /* mysql username */     \"password\": /* mysql password */     \"database\": \"database_development\", /* 해당 이름의 데이터베이스는 직접 생성해야 한다 */     \"host\": \"127.0.0.1\",     \"dialect\": \"mysql\"   },   \"test\": {     \"username\": /* mysql username */     \"password\": /* mysql password */     \"database\": \"database_test\",     \"host\": \"127.0.0.1\",     \"dialect\": \"mysql\"   },   \"production\": {     \"username\": /* mysql username */     \"password\": /* mysql password */     \"database\": \"database_production\",     \"host\": \"127.0.0.1\",     \"dialect\": \"mysql\"   } }                또한 config/config.json 파일은 민감한 정보를 담고 있기 때문에 .gitignore 파일 확인시 포함되어 있는 걸 알 수 있다.       위 과정이 끝나면 CLI를 통하여 필요한 파일들이 모두 자동으로 만들어졌으며, mysql에 접속 할 수 있게 된다.             3-3. 모델 생성           CLI를 통해 모델을 만들어야 한다.       npx sequelize-cli model:generate --name url --attributes url:string,title:string,visits:integer           모델(테이블의 이름) 이름은 url로 설정하였지만, 실제 결과물은 urls로 나왔다.(아마 복수형은 자동 취급되는 듯 보인다.)            필드가 가지는 특별한 요구 사항(기본값 등)은 파일을 직접 수정해서 정의해야 한다.       위에서 만들어진 models/url.js 파일은 다음과 같다. visits의 기본값은 0으로 설정하기 위해서는 첫째로 모델 파일을 직접 수정해야한다.         /* 생략 */   url.init({       url: DataTypes.STRING,       title: DataTypes.STRING,       /* visits 의 defaultValue : 0 으로 직접 모델 파일을 수정해줘야 한다. */       visits: {type : DataTypes.INTEGER, defaultValue : 0}   }           두 번째로, migrations/2021xxxx-create-url.js 파일의 스키마 구조 또한 수정해주어야 한다.         /* 생략 */   url: {       type: Sequelize.STRING   },   title: {       type: Sequelize.STRING   },   visits: {       type: Sequelize.INTEGER,        defaultValue: 0 /* defaultValue 값 추가 */   },                위 과정을 모두 거친다면, 테이블에 알맞은 필드값이 요구 사항에 맞춰 작성된 걸 볼 수 있다.             3-4. 마이그레이션           모델이나, 스키마 변경이 있을 때 자동으로 적용되지 않기 때문에 마이그레이션을 실행해 줘야 한다.       npx sequelize-cli db:migrate           Sequelize 명령어로 반영이 가능하다.            해당과정까지 진행하면 Part-1은 모두 통과하게 된다.                    데이터베이스의 준비가 완료되었으니, MVC V는 사실 없다  패턴을 적용하여 Short.ly의 백엔드 부분을 완성하면 스프린트는 완성된다.       3-5. controller 작성      스프린트에서 제공하는 endpoint는 다음과 같다.            GET /links       GET /links/:id (리디렉션)       POST /links                그중 우선 리디렉션은 추후에 추가하고, 테스트 요구사항에 맞추어서 controllers/links/index.js 디렉토리 구조를 만들어서 controller 파일을 만들어 주었다.       const utils = require('../../modules/utils'); const { url : urlModels } = require('../../models');  /* const urlModels = require('../../models').url 과 같은 의미이다. */  module.exports = {   get: (req, res) =&gt; {     // get method   },   post: (req, res) =&gt; {     // post method   }, }           다음과 같은 get, post 두가지 메소드가 존재하는 contoller 파일이 존재한다면 (2-1) controller 작성 테스트는 쉽게 통과할 수 있다.             3-6. router 연결           위에 나열한 endpoint에 맞추어 router 파일을 만들어 주면된다.       routes/index.js 파일은 있었기에 controller 각 endpoint의 메소드에 맞추어 routes/links.js 분기점을 만들어 주었다.       const express = require('express'); const router = express.Router(); const controllers = require('../controllers/links');    router.get('/', controllers.get); router.get('/:id', controllers.redirect); router.post('/', controllers.post);  module.exports = router;           여기부터는 controller 와 router 파일 모두 완성시켜 연결되어야 테스트가 통과가 된다.  이전 controller 파일 작성 단계에서는 테스트 통과를 위하여 뼈대만 작성해 놓았기 때문에 테스트 통과를 위해서 controller 구현 과정을 마저 작성하도록 하자.       3-7. controller 구현            우선 첫번째 기능인 GET /links 는 urls 테이블의 모든 내역을 조회하는 역할이다.         SELECT * FROM urls           위 역할을 대신 할 Sequelize 구문을 작성해주면 된다. 공식 문서를 참조하여 findAll 메소드를 활용하였다.       const { url : urlModels } = require('../../models'); \t module.exports = {   get: (req, res) =&gt; {     urlModels       .findAll()       .then(data =&gt; {         res.status(200).json(data)       });   }                다음 기능은 POST /links로써, urls 테이블에 값을 넣는 역할이다.       스프린트에 나온 내용대로 utils.js에서 url 사이트의 메타 정보 title 을 긁어올 수 있는 코드인 utils.getUrlTitle를 사용하였으며, 그 외 공식 문서를 참조하여 findOrCreate 메소드를 활용하였다.       .findOrCreate()는 원하는 값을 조회 후 없다면 생성까지 할 수 있는 함수이기때문에 결과값으로 반환하는 인자가 2개인 점이 특징이다. 사실 .create() 만 사용해도 된다.       const utils = require('../../modules/utils');  /* 생략 */  post: (req, res) =&gt; {     const { url } = req.body;        utils.getUrlTitle(url, (err, title) =&gt; {       urlModels         .findOrCreate({           where: { url: url },           default : { title: title }         })         .then(([data, created]) =&gt; {           if (!created) {             return res.status(201).json(data);           }           res.status(201).json(data);          })     });   }                마지막 기능은 GET /links/:id로써, redirect 기능 역할이다.       .finOne() 으로 id가 일치하는 url을 찾아, update 메소드로 visits를 1 증가 시키고 리디렉션 한다.       redirect: (req, res) =&gt; {     urlModels       .findOne({         where: { id: req.params.id }       })       .then(data =&gt; {         return data.update(           { visits: data.visits + 1 }         );       })       .then(data =&gt; {         res.redirect(data.url);       })   }                 오늘 느낀 점   ORM을 통한 DB 작성과 백엔드 기능을 중점으로 다루었다.   어제부터 계속 학습해온 MVC 로 구분하여 프로그래밍을 하는 이유, 그리고 오늘은 심화과정인 ORM(Sequelize)을 통하여 DB를 다루는 방법까지 배웠다.   SQL 문법이 어렵지 않았기에 사실 Sequelize 문법이 편하다?… 는 결코 아닌거같다..   당장 많이 써보지 않아 익숙하지 않아 코드를 짤 때 느끼는 이질감은 당연히 있지만, 이 백엔드 로직은 충분히 학습해야겠다 라는 생각이 들었다.   개발언어를 혼용해가며 쓴다는 개념보다는 한가지의 개발언어로 프로그램을 작성 한다는게 가독성에는 유리한 측면은 당연한 얘기이기 때문이다.   그리고 .then()을 계속 쓰고는 있는데 쓰는 코드가 길어질 수록 뭔가… 코드가 안예쁘다 async/await 방법 두가지 모두 활용하여 코드를 짜는 습관을 학습하는 단계에서는 길러봐야겠다.         내일 할 일     [데이터베이스 NoSQL]  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.18.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 32. largestRectangularArea",
        "excerpt":"  TOY 32. largestRectangularArea  문제   히스토그램(histogram)은 표(도수 분포표, 빈도표)로 되어 있는 도수 분포(frequency distribution)를 정보 그림으로 나타낸 것입니다. 예를 들어, 대학교의 한 학과에서 신입생들의 현재 거주 지역을 조사한 결과가 다음과 같다고 가정해 봅시다.      서울 2명, 경기 1명, 대전 4명, 부산 5명, 대구 1명, 광주 3명, 제주도 3명…   이 자료를 히스트그램으로 나타내면 각각 높이 2, 1, 4, 5, 1, 3, 3인 직사각형이 왼쪽부터 그려지게 됩니다. 편의상 직사각형의 너비는 1이라고 가정합니다. 이를 그림으로 나타내면 아래와 같습니다.   6 | 5 |       x 4 |     x x 3 |     x x   x x 2 | x   x x   x x 1 | x x x x x x x ------------------   이 히스토그램 내에서 만들 수 있는 가장 큰 직사각형의 면적은 8입니다 (O로 표시한 부분).   6 | 5 |       x 4 |     O O 3 |     O O   x x 2 | x   O O   x x 1 | x x O O x x x ------------------   이처럼 임의의 히스토그램 내에서 가장 큰 직사각형의 면적을 리턴해야 합니다.   입력   인자 1 : histogram     number 타입을 요소로 갖는 배열   histogram[i]는 100,000 이하의 양의 정수   histogram.length는 100,000 이하   출력      number 타입을 리턴해야 합니다.   입출력 예시   let histogram = [2, 1, 4, 5, 1, 3, 3]; let output = largestRectangularArea(histogram); console.log(output); // --&gt; 8  let histogram = [6, 2, 5, 4, 5, 1, 6]; let output = largestRectangularArea(histogram); console.log(output); // --&gt; 12 /* 6 | x           x 5 | x   x   x   x 4 | x   O O O   x 3 | x   O O O   x 2 | x x O O O   x 1 | x x O O O x x ------------------ */   Advanced      임의의 히스토그램에서 가장 큰 직사각형의 넓이를 계산하는 효율적인 알고리즘(O(N * logN))이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.   힌트      문제를 어렵게 만드는 것은 높이를 포기하고 너비를 선택할지, 너비를 포기하고 높이를 선택할지 따져봐야 한다는 것입니다.   문제를 직접 풀어보고 유심히 관찰하는 것은 문제 해결의 첫 걸음입니다.   길이 n인 histogram에서 가장 큰 직사각형이 histogram[i]부터 막대 histogram[j]까지라고 가정해봅시다. i와 j는 0 ~ n-1 사이에 놓여 있습니다. (0 &lt;= i &lt;= j &lt;= n-1)   이 사각형의 높이는 이 구간의 막대 중 가장 낮은 높이를 가진 막대(histogram[k])의 높이와 같습니다.   이 사각형은 전체 구간(0 ~ n-1) 중 가장 낮은 막대를 포함하고 있거나 그렇지 않은 경우로 나뉩니다.   전자는 i === 0이고 j === n-1인 경우 뿐입니다.   후자는 이 직사각형이 차지하는 구간 바깥에 존재합니다. (k &lt; i이거나 j &lt; k)   이 이후부터는 스스로 생각해보시기 바랍니다.   구간 트리(segment tree)를 약간 변형하여 해결합니다.   TOY 32. Solution  수도코드   그려진 히스토그램 내에서 가장 큰 직사각형을 찾는 문제이다. Reference Code 를 보았다.   문제풀이  (스택을 활용한 풀이)    const largestRectangularArea = function (histogram) {   const n = histogram.length, stack = [];   let maxArea = 0;    for (let i=0; i&lt;n; i++) {   // Check if the current bar is lower than the previous bar in the stack     while (stack.length &amp;&amp; histogram[i] &lt;= histogram[stack[stack.length-1]]) {       // Calculate the area       maxArea = Math.max(maxArea, getArea(i, histogram, stack));     }     stack.push(i);   }    // Calcualte the remaining bar in the stack   while (stack.length) {     maxArea = Math.max(maxArea, getArea(n, histogram, stack));   }    return maxArea; };  const getArea = (i, histogram, stack) =&gt; {   const h = histogram[stack.pop()];   const w = stack.length ? i - stack[stack.length-1] - 1 : i;    return h * w; };    Reference Code  // naive solution: O(N) (search only) // const rangeMinimum = function (arr, ranges) { //   return ranges.map((range) =&gt; { //     const [start, end] = range; //     let min = Number.MAX_SAFE_INTEGER; //     for (let i = start; i &lt;= end; i++) { //       if (arr[i] &lt; min) min = arr[i]; //     } //     return min; //   }); // }; /* 단순하게 밑변의 모든 경우랑 윗변의 모든 경우를 구해보고 그 중 최댓값을 구하는 코드이기에 시간 복잡도를 많이 소모한다. */  // solution with segment tree: O(logN) (search only) // object implementaion const rangeMinimum = function (arr, ranges) {   // ts: tree start. te: tree end   // arr의 ts부터 te까지를 tree로 만든다.   const createMinTree = (arr, ts, te) =&gt; {     // base case     if (ts === te) {       return { value: arr[ts] };     }      // recursive case     // 현재 범위를 절반을 기준으로 왼쪽과 오른쪽으로 나눈다     const mid = parseInt((ts + te) / 2);     const left = createMinTree(arr, ts, mid);     const right = createMinTree(arr, mid + 1, te);      return {       value: Math.min(left.value, right.value),       left,       right,     };   };   const tree = createMinTree(arr, 0, arr.length - 1);    // rs: range start, re: reange end   const findMin = (ts, te, rs, re, tree) =&gt; {     // 현재 tree와 구간이 정확히 일치하거나     // 구간이 tree를 포함할 경우     if (rs &lt;= ts &amp;&amp; te &lt;= re) {       return tree.value;     }      // 현재 tree에 주어진 구간이 겹치지 않는 경우     if (te &lt; rs || re &lt; ts) {       return Number.MAX_SAFE_INTEGER;     }      // 겹치는 부분이 존재하는 경우     const mid = parseInt((ts + te) / 2);     return Math.min(       findMin(ts, mid, rs, re, tree.left), //       findMin(mid + 1, te, rs, re, tree.right)     );   };    const mins = ranges.map((range) =&gt; {     const [start, end] = range;     return findMin(0, arr.length - 1, start, end, tree);   });   return mins; };  // solution with segment tree: O(logN) (search only) // array implementaion // const rangeMinimum = function (arr, ranges) { //   const createMinTree = (arr, ts, te, tree, idx) =&gt; { //     if (ts === te) { //       tree[idx] = arr[ts]; //       return arr[ts]; //     }  //     const mid = Math.floor((ts + te) / 2); //     tree[idx] = Math.min( //       createMinTree(arr, ts, mid, tree, idx * 2 + 1), // //       createMinTree(arr, mid + 1, te, tree, idx * 2 + 2) //     );  //     return tree[idx]; //   };  //   // 트리 전체의 높이(루트 노트에서 가장 깊은 리프 노드까지의 거리)를 구하고 //   // 전체 배열의 크기를 구한다. //   const height = Math.ceil(Math.log2(arr.length)); //   const size = Math.pow(2, height + 1) - 1; //   const tree = Array(size).fill(null); //   createMinTree(arr, 0, arr.length - 1, tree, 0);  //   const findMin = (ts, te, rs, re, idx) =&gt; { //     if (rs &lt;= ts &amp;&amp; te &lt;= re) { //       return tree[idx]; //     }  //     if (te &lt; rs || re &lt; ts) { //       return Number.MAX_SAFE_INTEGER; //     }  //     const mid = parseInt((ts + te) / 2); //     return Math.min( //       findMin(ts, mid, rs, re, 2 * idx + 1), // //       findMin(mid + 1, te, rs, re, 2 * idx + 2) //     ); //   };  //   const mins = ranges.map((range) =&gt; { //     const [start, end] = range; //     return findMin(0, arr.length - 1, start, end, 0); //   }); //   return mins; // };   오늘 느낀 점  이미 너무 유명한 문제였다. 문제가 어려워 힌트를 얻고자 구글링을 해보니 백준, leetcode등 사이트에서 다양한 코드리뷰들이 많이 나왔다. HARD문제다…   지금은 이해가 안가지만 깔끔히 정리된 코드가 보여 풀이과정에 우선 올려두었다.   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정  내일 할 일     TOY 33. LIS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.19.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 33. LIS",
        "excerpt":"  TOY 33. LIS  문제   정수를 요소로 갖는 문자열을 입력받아 다음의 조건을 만족하는 LIS 의 길이를 리턴해야 합니다.      LIS: 배열의 연속되지 않는 부분 배열 중 모든 요소가 엄격하게 오름차순으로 정렬된 가장 긴 부분 배열(Longest Increasing Subsequence)   배열 [1, 2, 3]의 subseqeunce는 [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] 입니다.   엄격한 오름차순: 배열이 동일한 값을 가진 요소없이 오름차순으로 정렬되어 있는 경우를 말합니다.   입력   인자 1 : arr     number 타입을 요소로 갖는 배열   arr.length는 60,000 이하   arr[i]는 100,000 이하의 양의 정수   출력      number 타입을 리턴해야 합니다.   입출력 예시   let output = LIS([3, 2]); console.log(output); // --&gt; 1 (3 or 2)  output = LIS([3, 10, 2, 1, 20]); console.log(output); // --&gt; 3 (3, 10, 20)   Advanced      LIS를 계산하는 효율적인 알고리즘(O(N^2))이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.   subsequence는 문자열 또는 배열같이 순서가 있는 데이터에서 순서의 대소 관계가 유지되는 모든 부분 문자열 또는 부분 배열을 의미합니다. sequence가 순서 또는 서열을 의미하기 때문에 subsequence는 부분 서열이라고 부르기도 합니다. 반면 substring 또는 subarray는 연속된 형태의 부분 문자열 또는 부분 배열을 의미합니다. 문자열 'abcd'의 subsequence와 substring은 각각 아래와 같습니다.            substring: 'a', 'b', 'c', 'd', 'ab', 'bc', 'cd', 'abc', 'bcd', 'abcd'       subsequence: 'a', 'b', 'c', 'd', 'ab', 'ac', 'ad', 'bc', 'bd', 'cd', 'abc', 'abd', 'acd', 'bcd', 'abcd'       LIS의 길이 대신 LIS 자체를 리턴하는 함수를 구현해 보시기 바랍니다.           TOY 33. Solution  수도코드   문제도 잘 이해 못하겠다..   문제풀이        Reference Code  // naive solution: O(2^N) // 배열의 각 요소에 대해서 선택, 무시의 2가지 선택이 가능 // const LIS = function (arr) { //   // 현재 검토할 차례인 배열의 '인덱스'와 //   // 이전에 선택된 요소의 '값'을 인자로 전달한다. //   const pickOrNot = (idx, before) =&gt; { //     // base case //     // 가장 짧은 LIS의 길이는 1이다. 모든 요소는 그 자체로 길이 1인 부분 서열이다. //     if (idx === arr.length) return 1;  //     // recursive case //     // (초기값인 Number.MAX_SAFE_INTEGER를 포함해) 이전에 선택된 요소와 비교를 한다. //     const adder = arr[idx] &gt; before ? 1 : 0; //     return Math.max( //       // 1) 현재 요소를 선택한다. //       //  1-1) adder === 1: 현재 요소를 이전에 선택된 요소 뒤에 이어지는 요소로 생각해 LIS의 길이에 1을 더한다. //       //  1-2) adder === 0: 현재 요소를 이어지는 요소로 생각할 수 없는 경우. 이전 요소를 건너뛰고 LIS의 처음 또는 중간 요소로 현재 요소를 선택한다. //       adder + pickOrNot(idx + 1, arr[idx]), // concat or restart //       // 2) 현재 요소를 무시한다. //       pickOrNot(idx + 1, before) // ignore //     ); //   }; //   // 첫 번째 요소의 이전 요소는 없기 때문에 매우 큰 값을 이전 값으로 설정한다. //   // 첫 번째 요소부터 시작하는 LIS를 검사하는 효과를 갖는다. //   return pickOrNot(0, Number.MAX_SAFE_INTEGER); // };  // dynamic programming with memoization: O(N^2) // const LIS = function (arr) { //   // memo[i]는 i부터 시작하는 LIS의 길이를 저장 //   const memo = Array(arr.length).fill(-1); //   // 마지막 요소부터 시작하는 LIS는 1이 유일하다. //   memo[memo.length - 1] = 1; //   const calculateLIS = (idx) =&gt; { //     if (memo[idx] !== -1) return memo[idx];  //     let max = 1; //     for (let i = idx + 1; i &lt; arr.length; i++) { //       const len = calculateLIS(i); //       // idx와 i가 연결되지 않을 수도 있다. //       if (arr[idx] &lt; arr[i]) { //         // i부터 시작하는 LIS를 연결할 수 있는 경우 //         max = Math.max(max, len + 1); //       } //       // i부터 시작하는 LIS가 더 길 수도 있다. //       // idx부터 시작하는 LIS를 구해야 하므로, 무시한다. //     } //     memo[idx] = max; //     return memo[idx]; //   }; //   calculateLIS(0); //   // 가장 긴 길이를 구한다. //   return Math.max(...memo); // };  // dynamic programming with tabulation: O(N^2) const LIS = function (arr) {   const N = arr.length;   // lis[i]는 i에서 끝나는 LIS의 길이를 저장   // 최소한 각 요소 하나로 LIS를 만들 수 있으므로 1로 초기화한다.   const lis = Array(N).fill(1);   for (let i = 1; i &lt; N; i++) {     // i에서 끝나는 LIS의 길이     for (let j = 0; j &lt; i; j++) {       // i 이전의 인덱스만 검사하면 된다.       // i는 1부터 시작하므로, 짧은 길이부터 검사한다. (bottom-up 방식)       if (arr[i] &gt; arr[j] &amp;&amp; lis[i] &lt; lis[j] + 1) {         lis[i] = lis[j] + 1;       }     }   }   return Math.max(...lis); };   오늘 느낀 점  문제에서 레퍼런스코드를 보라한다… 갈수록 알고리즘 난이도가 너무 높다.   2주 세미 프로젝트 진행과 맞물려서 HA3 준비, 그리고 매일 진행되는 알고리즘까지 너무 시간이 모자르다. 커리큘럼이 너무 알고리즘에 매달리는 느낌을 지울수가 없다   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   내일 할 일     TOY 34. LCS  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.20.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. HTTPS 2. Hashing 3. Cookie",
        "excerpt":"  Today I Learnd  1. HTTPS           HTTP는 웹 환경에서 브라우저와 웹서버가 통신하는 방법이란걸 이전에 학습하였다. 그렇다면 HTTPS는 무엇일까?              HTTPS (HTTP + Secure) 는 HTTP protocol의 암호화된 버전이다. 기존 HTTP 프로토콜은 주고 받는 데이터가 암호화 되지 않고 그대로 전송되는 단점이 있기에 HTTPS가 등장하였다.            HTTPS는 HTTP의 하부에 SSL과 같은 보안계층을 제공함으로써 동작한다.             1-1. 암호화 키(Key)              위에서 HTTPS는 주고 받는 데이터를 암호화하여 데이터를 주고받는다 하였다. 이때 사용되는 암호화 알고리즘을 담은 키를 암호화 키라 부른다.       암호화를 위한 알고리즘은 노출되지 않아야 하며, 또한 원래 데이터로 복호화 하는 과정에서도 키가 필요하다. 따라서 키는 양쪽에서 모두 분배하여 공유되어야 한다.       1-2. 인증서(Certificate)         암호화시 사용되는 암호화 키를 담으며 데이터 제공자의 신원을 확인 할 수 있는 수단이다.   이처럼 HTTPS 통신과정에서 중요한 인증서는 인증기관인 CA(Certificate Authority)에서 발급하고 관리를 하므로 세계적으로 신뢰받는 기관이 운영한다.   1-3. HTTPS 통신 과정       2. Hashing           어떤 문자열에 임의의 ‘연산’을 적용하여 다른 문자열로 변환하는 것을 말한다.       여러 알고리즘이 존재하나, 개념만 익히고 넘어가자.       3. Cookie      쿠키는 서버에서 클라이언트에 데이터를 저장하는 방법중 하나이다.  웹사이트를 방문하게 되면, 사용자는 작은 정보 조각인 쿠키를 저장하게 된다. 이 쿠키에 로그인 정보등을 담아 로그인 상태를 유지하는등의 기능이 가능하게 된다.        앞서 언급한 것처럼 웹 서버는 사용자에게 쿠키를 이용하여 데이터를 저장하고 원할 때 이 데이터를 다시 불러와 사용할 수 있다.       하지만 데이터를 저장한 이후 아무 때나 데이터를 가져올 수 없으며, 데이터를 저장한 이후 특정 조건들이 만족하는 경우에만 다시 가져올 수 있다.  쿠키 옵션을 살펴보면 다음과 같다.       3-1. Cookie 옵션      Domain            쿠키 옵션에서 도메인 정보가 존재한다면 클라이언트에서는 쿠키의 도메인 옵션과 서버의 도메인이 일치해야만 쿠키를 전송할 수 있다.           Path                     세부 경로는 서버가 라우팅할 때 사용하는 경로이다.           만약 요청해야 하는 URL이 http://www.localhost.com:3000/users/login 인 경우라면 여기에서 Path는 /users/login이다.                        명시하지 않으면 기본으로 / 으로 설정되어 있다.                   MaxAge or Expires                     쿠키가 유효한 기간을 정하는 MaxAge는 앞으로 몇 초 동안 쿠키가 유효한지 설정하는 옵션이다.           Expires 은 MaxAge와 비슷하지만, 해당 옵션값은언제까지 유효한지 Date를 지정하는 차이가 있다.                   Secure            쿠키를 전송해야 할 때 사용하는 프로토콜에 따른 쿠키 전송 여부를 결정한다. 만약 해당 옵션이 true로 설정된 경우, ‘HTTPS’ 프로토콜을 이용하여 통신하는 경우에만 쿠키를 전송할 수 있다.           HttpOnly            자바스크립트에서 브라우저의 쿠키에 접근 여부를 결정한다. 만약 해당 옵션이 true로 설정된 경우, 자바스크립트에서는 쿠키에 접근이 불가하다.       명시되지 않는 경우 기본으로 false로 지정되어 있다. 만약 이 옵션이 false인 경우 자바스크립트에서 쿠키에 접근이 가능하므로 ‘XSS’ 공격에 취약해진다.           SameSite            Cross-Origin 요청을 받은 경우 요청에서 사용한 메소드와 해당 옵션의 조합으로 서버의 쿠키 전송 여부를 결정하게 된다.                    Lax : Cross-Origin 요청이면 GET 메소드에 대해서만 쿠키를 전송할 수 있다.           Strict : Cross-Origin이 아닌 same-site 인 경우에만 쿠키를 전송 할 수 있다.           None : 항상 쿠키를 보내줄 수 있다. 다만 쿠키 옵션 중 Secure 옵션이 필요하다.                             이러한 옵션들을 지정한 다음 서버에서 클라이언트로 쿠키를 처음 전송하게 된다면 헤더에 Set-Cookie라는 프로퍼티에 쿠키를 담아 전송할 수 있다.   이후 클라이언트 혹은 서버에서 쿠키를 전송해야 한다면 클라이언트는 헤더에 Cookie라는 프로퍼티에 쿠키를 담아 서버에 쿠키를 전송하게 된다.   3-2. Cookie를 이용한 상태 유지           HTTP 프로토콜의 특징중 하나인 무상태성(Stateless) 은 클라이언트와 서버의 통신이 연결을 끊는 순간  상태 정보는 유지하지 않는 특성이다.       하지만 쿠키의 등장으로 서버는 클라이언트에 인증정보를 담은 쿠키를 전송하고, 클라이언트는 전달받은 쿠키를 요청과 같이 전송하여 무상태성의 성격을 지닌 인터넷 연결을 Stateful 하게 유지할 수 있게 되었다.            하지만 기본적으로는 쿠키는 MaxAge등 옵션설정으로 인해 오랜 시간 동안 유지될 수 있고, 자바스크립트를 이용해서 쿠키에 접근할 수 있기 때문에 쿠키에 민감한 정보를 담는 것은 위험하다.             오늘 느낀 점   HTTPS 프로토콜의 등장 이유(결제 사이트등…보안성을 위한 홈페이지의 필요성)와 그를 가능하게 하는 암호화 과정, 그리고 그를 해독하기 위한 해싱이 공신력있는 CA업체에서 발급한 신뢰있는 인증서를 통한 과정이라는 개념을 학습했다. 살면서 브라우저 주소창에 자물쇠가 있었다는 걸 처음알았다   이를 처리하는 과정에서 클라이언트/서버에서는 어떠한 프레임워크가 이뤄지는지 실습까지 이어가자.         내일 할 일     [인증/보안] 기초  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.20.til1/",
        "teaser": null
      },{
        "title": "[TIL] 1. Part1 - Session",
        "excerpt":"  Today I Learnd  1. Part1 - Session   HTTPS 프로토콜 서버를 만들고, 클라이언트에서 쿠키에 담긴 세션 정보를 확인해야 한다.   세션 기반 인증은 서버(혹은 DB)에 유저 정보를 담는 인증 방식이다. 이때 웹사이트에서는 로그인을 유지하기 위한 수단으로 쿠키를 사용하며 쿠키에는 서버에서 발급한 세션 아이디를 저장되어 있다.   1-1. 사전 준비   환경 변수 설정      Sequelize 스프린트때 해보았기 때문에 별도로 mysql을 node.js에서 어떻게 사용하는지 구조를 뜯어보진 않았다. .env 파일을 내 로컬환경에 알맞게 설정해 주었다.   config/config.js 파일에 이미 데이터베이스 이름(database: 'authentication')이 명시되어 있었다.  해당 이름의 DB를 생성해주었다.   데이터베이스 마이그레이션           이 또한 Sequelize 스프린트때 해보았기 때문에 models와 migrations 폴더 내부의 파일들을 확인하지 않았다.       npx sequelize-cli db:migrate           위 sequelize 명령어로 이미 짜여진 DB 스키마를 내 mysql 환경으로 마이그레이션 해주었다.       인증서 발급      mkcert라는 프로그램을 이용해서 로컬 환경에서 인증서를 생성했다.   1-2. 서버 구현    쿠키 옵션 &amp; HTTPS 옵션 설정           server-session/index.js 파일에서 쿠키 옵션 설정을 해주었다.         // TODO: express-session 라이브러리를 이용해 쿠키 설정을 해줄 수 있습니다.   app.use(       session({           secret: '@codestates',           resave: false,           saveUninitialized: true,           cookie: {               domain: 'localhost', // Domain : 쿠키의 Domain 옵션과 서버의 도메인이 일치해야한다.(스프린트는 로컬 환경)               path: '/',  // Path : default값은 '/'이다.               maxAge: 24 * 6 * 60 * 10000,  // maxAge : 해당 초만큼 유지되는 쿠키 유효기간 옵션이다.               sameSite: 'none',  // sameSite : 항상 쿠키를 보내 줄 수 있다.(secure : true 옵션과 함께 써야한다.)               httpOnly: true,  // httpOnly : 'true'이기 때문에, JS에서는 쿠키에 접근이 불가하다.               secure: true           },       })   );                마찬가지로 server-session/index.js 파일에서 HTTPS 옵션 설정을 해주었다.         // TODO: CORS 설정이 필요합니다. 클라이언트가 어떤 origin인지에 따라 달리 설정할 수 있습니다.   // 메서드는 GET, POST, OPTIONS를 허용합니다.   app.use(cors({       origin: 'https://localhost:3000',  // 출처(origin)는 클라이언트 주소를 준다.       method: ['GET', 'POST', 'OPTIONS'],  // 메소드는 제시되어 있다.       credentials: true  // 인증서를 이용한 CORS 옵션.   }));           POST /users/login           controller/users/login.js에서 로그인에 관련 기능을 완성하자.         // 해당 모델의 인스턴스를 models/index.js에서 가져옵니다.   const { Users } = require('../../models');  // DB \t   post: async (req, res) =&gt; {       // userInfo는 유저정보가 데이터베이스에 존재하고, 완벽히 일치하는 경우에만 데이터가 존재합니다.       // 만약 userInfo가 NULL 혹은 빈 객체라면 전달받은 유저정보가 데이터베이스에 존재하는지 확인해 보세요       const userInfo = await Users.findOne({           where: { userId: req.body.userId, password: req.body.password },       });        // TODO: userInfo 결과 존재 여부에 따라 응답을 구현하세요.       // 결과가 존재하는 경우 세션 객체에 userId가 저장되어야 합니다.       if (!userInfo) {           res.json({message: 'not authorized'});       } else {           // HINT: req.session을 사용하세요.           req.session.save(function() {  // 세션 객체에 저장하는 방법               req.session.userId = userInfo.userId;               res.json({message: 'ok'});           });       }   }                req.session 사용방법은 GitHub: express-session 문서를 통해 확인하였다.       POST /users/logout           controller/users/logout.js에서 로그아웃에 관련된 기능을 완성하자.         post: (req, res) =&gt; {        // TODO: 세션 아이디를 통해 고유한 세션 객체에 접근할 수 있습니다.       // 앞서 로그인시 세션 객체에 저장했던 값이 존재할 경우, 이미 로그인한 상태로 판단할 수 있습니다.       // 세션 객체에 담긴 값의 존재 여부에 따라 응답을 구현하세요.        if (!req.session.userId) {           // 로그인 전에 로그아웃 요청           res.sendStatus(400); // 400번 에러코드       } else {           // TODO: 로그아웃 요청은 세션을 삭제하는 과정을 포함해야 합니다.           req.session.destroy(function(){  // 세션 객체 파괴               req.session;            });           /* 세션 삭제는 req.session = null 또한 가능한듯하다... 세션 객체를 null값으로 초기화 */           res.sendStatus(200);       }   }           POST /users/userinfo           controller/userinfo.js에서 마이페이지 관련된 기능을 완성하자.       const { Users } = require('../../models');  // DB \t   get: async (req, res) =&gt; {       // TODO: 세션 객체에 담긴 값의 존재 여부에 따라 응답을 구현하세요.       // HINT: 세션 객체에 담긴 정보가 궁금하다면 req.session을 콘솔로 출력해보세요        if (!req.session.userId) {           res.status(400).json({message: 'not authorized'});       } else {           // TODO: 데이터베이스에서 로그인한 사용자의 정보를 조회한 후 응답합니다.           Users.findOne({  // Users 테이블에서 조회 후               where: {                   userId: req.session.userId               }           })           .then((data)=&gt;{  // 응답에 조회값을 넘겨준다.               res.status(200).json({data:data, message: 'ok'})           })       }   }           1-3. 클라이언트 구현   Mypage      components/Mypage.js에서 마이페이지 관련된 기능을 완성하자.   서버의 API를 활용하기 위해서는 Axios 라이브러리를 사용해야 한다.            Axios는 브라우저, Node.js를 위한 Promise API를 활용하는 HTTP 비동기 통신 라이브러리이다.       자바스크립트에 내장되어 있는 fetch api와 유사한 기능이지만, url을 제공하는 등 차이점이 있다.                Mypage에서는 로그인 이후 userinfo가 보여지며, 로그아웃 버튼이 존재한다.         import axios from 'axios';    function Mypage(props) {       const handleLogout = () =&gt; {           // TODO: 서버에 로그아웃 요청을 보낸다음 요청이 성공하면 props.logoutHandler를 호출하여 로그인 상태를 업데이트 해야 합니다.           axios.post('https://localhost:4000/users/logout', null,  {withCredentials: true})  // url은 서버의 endpoint, data는 null값을 그리고 cors옵션중 Credential값이 'true'이므로 withCredentials 옵션을 준다.           .then(()=&gt;{               props.logoutHandler(); // post 요청 후 logoutHandler 함수 호출하여 isLogin 상태를 업데이트 한다.           }); \t\t       /* 생략 */   }           Login           components/Login.js 에서는 loginRequestHandler() 함수를 완성해주면 된다.         loginRequestHandler() {       // TODO: 로그인 요청을 보내세요. \t\t       // 로그인에 성공하면       // - props로 전달받은 함수를 호출해, 로그인 상태를 변경하세요.       // - GET /users/userinfo 를 통해 사용자 정보를 요청하세요 \t\t       //   // 사용자 정보를 받아온 후       // - props로 전달받은 함수를 호출해, 사용자 정보를 변경하세요. \t\t       axios.post('https://localhost:4000/users/login',{userId: this.state.username, password: this.state.password}, {withCredentials: true})  // 로그인 요청       .then(()=&gt;{           this.props.loginHandler();  // 로그인 요청에 성공하면, 전달받은 함수를 호출해 로그인 상태를 변경           return axios.get('https://localhost:4000/users/userinfo', {withCredentials: true})  // GET /users/userinfo 를 통해 사용자 정보를 요청       })       .then((data)=&gt;{  // 사용자 정보를 받아온 후           const {userId, email} = data.data.data; // 사용자 정보는 controller/userinfo.js에서 data: data 형식으로 보냈다.           this.props.setUserInfo({  // props로 전달받은 함수를 호출 (상태변경 함수)               userId,               email           });       });   }                 오늘 느낀 점   어렵다 어렵다 어렵다…   axios 의 등장.. node.js에서 브라우저, Node.js를 위한 Promise API를 활용하는 HTTP 비동기 통신 라이브러리 이다.  앞으로 자주 볼 듯 하다…   반복해서 해봐야 할 듯 하다…         내일 할 일     [인증/보안] 기초  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.20.til2/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 34. LCS",
        "excerpt":"  TOY 34. LCS  문제   두 문자열을 입력받아 다음의 조건을 만족하는 LCS 의 길이를 리턴해야 합니다.      LCS: 두 문자열에 공통으로 존재하는 연속되지 않는 부분 문자열(Longest Common Subsequence)   문자열 'abc'의 subseqeunce는 'a', 'b', 'c', 'ab', 'ac', 'bc', 'abc' 입니다.   입력   인자 1 : str1     string 타입의 알파벳 소문자와 숫자로 이루어진 문자열   str1.length는 50 이하   인자 2 : str2     string 타입의 알파벳 소문자와 숫자로 이루어진 문자열   str1.length는 50 이하   출력      number 타입을 리턴해야 합니다.   주의사항      LCS의 길이를 리턴해야 합니다.   LCS가 존재하지 않는 경우, 0을 리턴해야 합니다.   입출력 예시   let output = LCS('abcd', 'aceb'); console.log(output); // --&gt; 2 ('ab' or 'ac')  output = LCS('acaykp', 'capcak'); console.log(output); // --&gt; 4 ('acak')   Advanced      LCS를 계산하는 효율적인 알고리즘(O(M * N))이 존재합니다(두 문자열의 길이가 각각 M, N일 경우). 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.   LCS의 길이 대신 LCS 자체를 리턴하는 함수를 구현해 보시기 바랍니다.   LIS와 LCS를 변형하여 두 문자열 또는 배열을 입력받아 LCIS(Longest Common Increasing Subsequence)의 길이 또는 그 자체를 리턴하는 함수를 구현해 보시기 바랍니다.   TOY 34. Solution  수도코드   어제와 이하동문..   문제풀이        Reference Code  // naive solution: O(2^N) // 두 문자열의 길이(m, n)가 같다고 가정할 경우에 한함 // 최악의 경우는 일치하는 문자가 전혀 없을 경우이고 이때는 한쪽 문자열의 끝까지 비교해야 하므로 2^n 만큼의 시간이 걸린다. // const LCS = function (str1, str2) { //   // str1.slice 또는 str1.substring은 O(N)만큼의 오버헤드가 추가된다. //   // 비교는 인덱스만 알아도 충분하다. //   // left: str1의 인덱스, right: str2의 인덱스, len: 현재까지 만든 LCS의 길이 //   const compareOneByOne = (left, right) =&gt; { //     // base case //     // 더 이상 비교가 불가능한 경우 //     if (left === str1.length || right === str2.length) return 0;  //     // 일치하는 문자가 있는 경우 //     // 인덱스를 공통으로 이동하고, 길이를 1개 추가한다. //     if (str1[left] === str2[right]) { //       return 1 + compareOneByOne(left + 1, right + 1); //     }  //     // 일치하는 문자가 없는 경우 //     // 길이는 그대로고, str1과 str2 중에서 어느 쪽의 문자를 포기할지 정해야한다. //     // 양쪽다 가능성이 있으므로 양쪽을 모두 탐색하고 그 중 큰 값을 선택한다. //     return Math.max( //       compareOneByOne(left + 1, right), // //       compareOneByOne(left, right + 1) //     ); //   };  //   return compareOneByOne(0, 0); // };  // dynamic programming: O(M * N) // memoization을 활용해 중복 계산되는 문제를 제거한다. // LCS('ABCD', 'ACEB')의 경우 재귀 호출을 적어보면 아래와 같다. // =&gt; 1) LCS('BCD', 'CEB') //  =&gt; 1-1) LCS('CD', 'CEB'), 1-2) LCS('BCD', 'EB') //    =&gt; 1-1-1) LCS('D', 'CEB'), 1-1-2) LCS('CD', 'EB') //    =&gt; 1-2-1) LCS('CD', 'EB'), 1-2-2) LCS('BCD', 'B') // 더 볼 필요 없이 1-1-2)와 1-2-1)은 같은 문제임을 알 수 있다. const LCS = function (str1, str2) {   const M = str1.length;   const N = str2.length;   const memo = [];   // 중복 계산을 방지하기 위해 left, right   for (let i = 0; i &lt; M + 1; i++) memo.push(Array(N + 1).fill(-1));    const compareOneByOne = (left, right, len) =&gt; {     if (memo[left][right] !== -1) return memo[left][right];      if (left === str1.length || right === str2.length) return 0;      if (str1[left] === str2[right]) {       memo[left][right] = 1 + compareOneByOne(left + 1, right + 1, len + 1);       return memo[left][right];     }      memo[left][right] = Math.max(       compareOneByOne(left + 1, right, len), //       compareOneByOne(left, right + 1, len)     );     return memo[left][right];   };    return compareOneByOne(0, 0, 0); };  // dynamic programming: O(M * N) // tabulation(테이블에 정리)을 활용해 bottom-up 방식으로 해결 // const LCS = function (str1, str2) { //   const M = str1.length; //   const N = str2.length; //   // table[i][j]는 str1.slice(0, i)와 str2.slice(0, j)의 LCS를 저장 //   // str1.slice(0, i)는 0부터 i 바로 직전까지를 의미함 (i까지가 아님에 주의) //   const table = []; //   for (let i = 0; i &lt; M + 1; i++) table.push(Array(N + 1).fill(-1));  //   for (let i = 0; i &lt;= M; i++) { //     for (let j = 0; j &lt;= N; j++) { //       if (i === 0 || j === 0) { //         // i 또는 j가 0인 경우, 한쪽 문자열이 길이가 0이라는 의미이다. //         // LCS가 존재할 수 없으므로, 0을 저장한다. //         table[i][j] = 0; //       } else if (str1[i - 1] === str2[j - 1]) { //         // 두 문자가 같은 경우 //         // 양쪽 문자열의 인덱스가 한 개씩 이전인 상태에서 만들 수 있는 LCS의 길이보다 1만큼 더 길다. //         table[i][j] = 1 + table[i - 1][j - 1]; //       } else { //         // 두 문자가 같지 않은 경우 //         // 둘 중 한쪽을 포기하는 경우에 만들 수 있는 LCS의 길이를 따른다. //         table[i][j] = Math.max(table[i - 1][j], table[i][j - 1]); //       } //     } //   } //   return table[M][N]; // };   오늘 느낀 점  어제와 이하동문   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   내일 할 일     TOY 35. uglyNumbers  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.21.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. Part2 - Token",
        "excerpt":"  Today I Learnd  1. Part2 - Token           앞선 세션 인증 방식은 서버(혹은 DB)에 유저 정보를 담는 인증 방식이었다.       매 요청마다 데이터베이스를 살펴보는 것이 불편하고, 이 부담은 서버의 과부화를 초래할 수 있다.  부하를 줄이기 위해 인증 방식을 토큰 인증 방식을 사용해보자.            토큰 인증 방식의 인증 절차는 아래 그림과 같다              1-1. 사전 준비      Part1-Session의 준비단계와 동일한 진행은 생략하였다.        ACCESS_SECRET와 REFRESH_SECRET 변수명으로 2가지의 JWT(Json Web Token)을 사용한다.       accessToken은 보호된 정보들(유저의 이메일, 연락처, 사진 등)에 접근할 수 있는 권한부여에 사용된다. 클라이언트가 처음 인증을 받게 될 때(로그인 시), accessToken,refreshToken 두 가지를 다 받지만, 실제로 권한을 얻는 데 사용하는 토큰은 accessToken이다.       accessToken만 존재한다면, 해커나 악의적인 유저에게 탈취당할 경우 보안이 우려되므로 accessToken의 유효기간을 짧게 주고(탈취되더라도 피해 최소화), refreshToken으로 새로운 accessToken을 발급 받는 구조이다.       다른 사용자가 볼 수 없도록 .env 파일에 accessToken과 refreshToken 키값을 넣어준다(임의의 값을 넣어주어도 된다).   1-2. 서버 구현           우선 서버는 HTTPS 프로토콜 방식으로 구현된다. CORS 옵션을 보자면,         app.use(       cors({           origin: [\"https://localhost:3000\"],           credentials: true,           methods: [\"GET\", \"POST\", \"OPTIONS\"],       })   );           3000포트의 클라이언트를 출처로 받으며, 인증서를 사용하는 정보를 알 수 있다.       또한 서버는 4000번 포트로 인증서가 존재할 때만 서버가 구동되는 코드 또한 server-token/index.js 파일을 확인하면 볼 수 있다.       POST /login      controllers/login.js 파일을 확인 후 다음과 같은 기능을 완성시켜야 한다.            request로부터 받은 userId, password와 일치하는 유저가 DB에 존재하는지 확인합니다.       일치하는 유저가 없을 경우: 로그인 요청을 거절합니다.       일치하는 유저가 있을 경우:                    필요한 데이터를 담은 두 종류의 JWT(access, refresh)를 생성합니다.           생성한 JWT를 적절한 방법으로 반환합니다.                            access token은 클라이언트에서 react state로 다루고 있습니다.               refresh token은 클라이언트의 쿠키에서 다루고 있습니다.                                                     const { userId, password } = req.body; // req.body에 담긴 정보를 가져온다.    Users.findOne({       where: {           userId: userId,           password: password       }   }).then((data)=&gt;{  // request로부터 받은 userId, password와 일치하는 유저가 DB에 존재하는지 확인       if(!data){  // 1. 일치하는 유저가 없을 경우           res.json({message: 'not authorized'});// 로그인 요청을 거절('not authorized' 메세지가 응답에 포함)       } else {  // 2. 일치하는 유저가 있을 경우           // 일치하는 유저가 있을 경우: 필요한 데이터(id, userId, email, createdAt, updatedAt)를 payload에 담아 JWT token을 생성한다.           const payload = {  // payload에 필요한 데이터를 담는다.               id: data.dataValues.id,               userId: data.dataValues.userId,               email: data.dataValues.email,               createdAt: data.dataValues.createdAt,               updatedAt: data.dataValues.updatedAt,               iat: 151623391, // 토큰발급된시간.. format을 모르겠어서 더미값을 넣었다.               exp: Math.floor(Date.now() / 1000) + (60 * 60)           }            const accessToken = jwt.sign(payload, process.env.ACCESS_SECRET);  // access token, refresh token 생성           const refreshToken = jwt.sign(payload, process.env.REFRESH_SECRET);            res.set(\"Set-Cookie\", [`refreshToken=${refreshToken}; Domain=localhost; Path=/; Secure; HttpOnly; SameSite=None;`]); // refresh token을 쿠키에 담아 보낼 때 sameSite, secure, httpOnly 옵션을 알맞게 설정           res.json({data : { accessToken : accessToken }, message : 'ok'});  // 클라이언트에서 accessToken은 스테이트로 다뤄지기때문에 응답결과에 담아 반환한다.       }   })           GET /accesstokenrequest           controllers/accesstokenrequest.js에서는 authorization header에 담긴 토큰이 서버에서 생성한 JWT인지 확인후, 서버에서 생성한 유효한 토큰일 경우와 유효하지 않은 토큰일 경우 각각 다른 응답을 반환 해야한다.         const authorization = req.headers['authorization'];  // authorization header에 담긴 토큰을 변수에 저장    /* authorization header에 담긴 access token이 유효한지 검사 */   if (!authorization) {  // 유효하지 않는 경우: 클라이언트에 아래와 같은 JSON 객체를 반환한다.       res.json({data: null, message: 'invalid access token'});   } else {       const token = authorization.split(' ')[1];  // Bearer token 형식이므로 .split(' ')[1]; \t\t       jwt.verify(token, process.env.ACCESS_SECRET, (err, data) =&gt; {           Users.findOne({  // JWT를 해독하여 얻은 payload안의 값으로 DB에 유저를 조회               where: {  // payload엔 password가 안담겨있으므로, 다른 속성으로 유저를 조회한다.                   id: data.id,                    userId: data.userId,                    email: data.email                }           })           .then((data) =&gt; {               delete data.dataValues.password;  // 모든 데이터가 담겨있다보니, 민감한 정보인 pasword는 삭제한다.               res.json({ data: { userInfo: data.dataValues }, message: 'ok' });  // 클라이언트에서 userInfo(password는 제외)를 보여줘야 하므로 응답 결과에 담아 반환한다.           })       });   }           GET /refreshtokenrequest           controllers/refreshtokenrequest에서는 요청에 담긴 refresh token이 유효하다면 새로운 access token을 발급해 줌과 동시에 유저가 요청한 정보를 반환해줘야하며 요청에 담긴 refresh token이 유효하지 않거나, 조작된 토큰일 경우 각각 다른 응답을 반환해야 한다.       const refreshToken = req.cookies.refreshToken;  // cookie에 담겨있는 refreshToken을 변수에 담는다.  /* cookie에 담긴 refreshToken이 유효한지 검사. */ if (!refreshToken) {  // 토큰이 담겨있지 않다면 아래와 같은 JSON 객체를 반환한다.   res.json({ data: null, message: 'refresh token not provided' }); } else {   jwt.verify(refreshToken, process.env.REFRESH_SECRET, (err, data) =&gt; {  // refreshToken을이 서버가 가진 REFRESH_SECRET 으로 생성된 것인지 확인     if(err) {  // 해독한 토큰이 유효하지 않거나, 해독이 불가한 토큰이라면 아래와 같은 JSON 객체를 반환       res.status(200).json({ data: null, message: 'invalid refresh token, please log in again' });     }      Users.findOne({  // JWT를 해독하여 얻은 payload안의 값으로 DB에 유저를 조회       where: {          id: data.id, // data에는 JWT를 해독한 결과값이 담겨 있다         userId: data.userId,          email: data.email        }     })     .then((data) =&gt; {  // playload안의 값과 DB에 일치된 유저정보가 반환이 된다.       delete data.dataValues.password;  // 민감정보 삭제        const payload = {  // 새로 발급할 토큰 유효기간 재설정         ...data.dataValues,  // 기존 데이터 활용         iat: 151623391,         exp: Math.floor(Date.now() / 1000) + (60 * 60)  // refreshToekn은 상대적으로 accessToken보다 유효기간을 길게 설정해준다.       }        const accessToken = jwt.sign(payload, process.env.ACCESS_SECRET);  // refreshToekn을 사용하여 accessToken보다을 새로 발급        res.json({ data: { accessToken: accessToken, userInfo: data.dataValues }, message: 'ok' });     });   }); }           1-3. 클라이언트 구현   App           app.js 파일의 빈 핸들러 함수들을 완성시키고, 각 컴포넌트에 적절한 props를 전달해준다.         /* 생략 */ \t   loginHandler(data) {  // 로그인핸들러       this.setState({ isLogin: true });  // 로그인 버튼 클릭시 isLogin 상태 값을 true로 바꾸어준다.       this.issueAccessToken(data.data.accessToken);  // 응답 결과로 받은 accessToken을 issueAccessToken 함수로 전달한다.   }    issueAccessToken(token) {       this.setState({ accessToken: token });  // 전달받은 acessToken 상태 값으로 바꿔준다.   }    render() {       const { isLogin } = this.state;       return (           &lt;div className='App'&gt;               {/*                TODO: isLogin 상태에 따라 Mypage 혹은 Login 컴포넌트를 렌더해야합니다.               알맞은 컴포넌트를 렌더링하는것은 물론, 올바른 props전달하도록 작성하세요.               */               isLogin ? (  // isLogin 3항연산자를 사용하여 상태에 따라 다른 컴포넌트를 렌더한다.                   &lt;Mypage accessToken={this.state.accessToken} issueAccessToken={this.issueAccessToken} /&gt;               ) : (                   &lt;Login loginHandler={this.loginHandler} /&gt;               )}           &lt;/div&gt;       );   }           Login      components/Login.js Login 컴포넌트의 loginRequestHandler메소드를 사용하여 상위 컴포넌트인 App 컴포넌트의 state를 적절히 변경해 준다. (상태 끌어올림)       loginRequestHandler() {       /*       TODO: Login 컴포넌트가 가지고 있는 state를 이용해 로그인을 구현합니다.       로그인을 담당하는 api endpoint에 요청을 보내고, 받은 데이터로 상위 컴포넌트 App의 state를 변경하세요.       초기 App:       state = { isLogin: false, accessToken: \"\" }       로그인 요청 후 App:       state = { isLogin: true, accessToken: 서버에_요청하여_받은_access_token }       */ \t\t       const { userId, password } = this.state;    /* 서버 Login endpoint에 요청을 보낸다. 요청 옵션에 인증서 사용옵션과 json객체 형태로 데이터를 받는 옵션값 설정 */        axios.post(\"https://localhost:4000/login\",{ userId, password }, { headers: { \"Content-Type\": \"application/json\" }, withCredentials: true })       .then((data) =&gt; {           this.props.loginHandler(data.data);  // props로 전달받은 데이터로 App.js의 상태값을 변경해준다.       });   }           Mypage      components/Mypage.js Mypage 컴포넌트의 빈 부분을 완성시켜준다.     accessTokenRequest() {   /*    TODO: 상위 컴포넌트인 App에서 받은 props를 이용해 accessTokenRequest 메소드를 구현합니다.   access token을 처리할 수 있는 api endpoint에 요청을 보내고, 받은 데이터로 Mypage 컴포넌트의 state (userId, email, createdAt)를 변경하세요   초기 Mypage:   state = { userId: \"\", email: \"\", createdAt: \"\" }   accessTokenRequest 후 Mypage:   state = { userId: \"특정유저id\", email: \"특정유저email\", created: \"특정유저createdAt\" }   ** 주의사항 **   App 컴포넌트에서 내려받은 accessToken props를 authorization header에 담아 요청을 보내야 합니다.    */ \t\t   axios.get(\"https://localhost:4000/accesstokenrequest\", {     headers: {              Authorization: `Bearer ${this.props.accessToken}`,  // App 컴포넌트에서 내려받은 accessToken props를 authorization header에 담아 요청전달       \"Content-Type\": \"application/json\",  // json 객체 형태로 데이터를 취급 선언     },     withCredentials: true   })   .then((data) =&gt; {     if (data.data.message !== \"ok\") {  // 서버의 응답 메시지 확인       const message =\"refresh token이 만료되어 불러올 수 없습니다. 다시 로그인 해주시기 바랍니다.\";       return this.setState({ email: message, createdAt: message });     }     const { createdAt, userId, email } = data.data.data.userInfo;     this.setState({ userId, createdAt, email });   }); }  refreshTokenRequest() {   /*   TODO: 쿠키에 담겨져 있는 refreshToken을 이용하여 refreshTokenRequest 메소드를 구현합니다.   refresh token을 처리할 수 있는 api endpoint에 요청을 보내고, 받은 데이터로 2가지를 구현합니다.   1. Mypage 컴포넌트의 state(userId, email, createdAt)를 변경   2. 상위 컴포넌트 App의 state에 accessToken을 받은 새 토큰으로 교환   */ \t\t   axios.get(\"https://localhost:4000/refreshtokenrequest\", {       withCredentials: true,     })     .then((data) =&gt; {       if (data.data.message !== \"ok\") {         const message =           \"refresh token이 만료되어 불러올 수 없습니다. 다시 로그인 해주시기 바랍니다.\";         return this.setState({ email: message, createdAt: message });       }       const { createdAt, userId, email } = data.data.data.userInfo;       this.setState({ userId, createdAt, email });       this.props.issueAccessToken(data.data.data.accessToken);     }); }           1-4. 결과 확인   refreshToken은 쿠키에 담겨(암호화 되어서) 주고받는 걸 알 수 있으며, 클라이언트에서 서버로 보낸 accessToken이 유효한 토큰일 경우 jwt.veryfy로 해독된 결과값이 응답 결과로 반환되어 클라이언트에서 해독된 결과 값을 볼 수 있게 되는 구조이다.           쿠키를 확인해보면 refreshToken값(비밀키값을 사용하여 암호화된..) 을 확인 할 수 있다.                   chrome의 네트워크 결과값을 보면 클라이언트에서 보낸 accessToken 요청이 유효한 경우 서버에서 반환된 해독된 payload 값을 확인 할 수 있다.                    오늘 느낀 점  이제 HTTPS 로그인 로직 개념이 잡힌다.. 어렵다 어려워   axios 아직 미숙하다.. 스프린트는 끝났지만 공부할게 더 많이 남았다… 내일 oauth 인증/보안 방식까지 열심히 해야지         내일 할 일     [인증/보안] 기초  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.21.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 35. uglyNumbers",
        "excerpt":"  TOY 35. uglyNumbers  문제   아래와 같이 정의된 ugly numbers 중 n번째 수를 리턴해야 합니다.      ugly number는 2, 3, 5로만 나누어 떨어지는 수이다.   1은 1번째 ugly number 이다.   1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, …   입력   인자 1 : n     number 타입의 자연수 (n &gt;= 1)   출력      number 타입을 리턴해야 합니다.   주의사항      ugly numbers를 배열에 저장했을 때, n번째 ugly number의 위치는 인덱스 n-1 입니다.   입출력 예시   let result = uglyNumbers(1); console.log(result); // --&gt; 1  result = uglyNumbers(3); console.log(result); // --&gt; 3   Advanced   단순히 처음부터 끝까지 모든 수에 대해서 나눗셈 연산을 하는 대신 다른 방법(O(N))을 탐구해 보세요.   TOY 35. Solution  수도코드   어떤 수를 소인수분해를 했을때, 2,3,5 만 남는 숫자를 찾는 알고리즘이다.      어떤 수(Ugly Numbers)에 Ugly Numbers 를 이루는 소인수인 2 (3, 5 도 마찬가지로) 를 곱해서 그 결과가 추가되었다면, 그 다음 숫자(Ugly Numbers)에 소인수 2 (3, 5) 를 곱해야 한다.   이미 다음 숫자로 넘어가서 소인수를 곱한 수와, 기존에 아직 곱하지 못한 소인수가 남아있는 경우를 대조해서, 더 작은 것을 먼저 배열에 추가해주어야 한다.   문제풀이    (구글링 참조)  const uglyNumbers = function (n) {   const uglyNumbers = [1];      let idx2 = 0;   let idx3 = 0;   let idx5 = 0;      for(let i = 0; i &lt; n; i++) {     const mulBy2 = uglyNumbers[idx2] * 2;     const mulBy3 = uglyNumbers[idx3] * 3;     const mulBy5 = uglyNumbers[idx5] * 5;          let nextUglyNum = Math.min(mulBy2, mulBy3, mulBy5);          uglyNumbers.push(nextUglyNum);          if (nextUglyNum === mulBy2) idx2++;     if (nextUglyNum === mulBy3) idx3++;     if (nextUglyNum === mulBy5) idx5++;   }      return uglyNumbers[n - 1]; };    Reference Code  // naive solution // const uglyNumbers = function (n) { //   const isUgly = (num) =&gt; { //     num = decompose(num, 2); //     num = decompose(num, 3); //     num = decompose(num, 5); //     return num === 1; //   };  //   const decompose = (num, factor) =&gt; { //     while (num % factor === 0) num = num / factor; //     return num; //   };  //   let num = 0; //   let cnt = 0; //   while (n &gt; cnt) { //     num++; //     if (isUgly(num)) cnt++; //   } //   return num; // };  // O(N) const uglyNumbers = function (n) {   // 매번 나눗셈 연산을 하는 것이 비효율적이므로   // 이미 구한 수에서부터 구한다.    const uglyNumbers = [1];   let idx2 = 0,     idx3 = 0,     idx5 = 0;    for (let i = 0; i &lt; n; i++) {     // 1. 가장 작은 수인 1에 2, 3, 5를 곱한 수 중에 가장 작은 수를 구한다.     // 2. 2가 선택됨.     // 3. 2는 가장 작은 수 1에 곱해졌으므로     //   3.1 이제 2는 그 다음 작은 수인 2에 곱해지고     //   3.2 3, 5는 여전히 가장 작은 수에 곱해진다.     // 4. 3에서 가장 작은 수는 3. 3은 이제 다음으로 작은 수인 2에 곱혀진다.     // 5. 반복     const nextMultipleOf2 = uglyNumbers[idx2] * 2;     const nextMultipleOf3 = uglyNumbers[idx3] * 3;     const nextMultipleOf5 = uglyNumbers[idx5] * 5;     const nextUglyNum = Math.min(       nextMultipleOf2,       nextMultipleOf3,       nextMultipleOf5     );     uglyNumbers.push(nextUglyNum);      // 같은 수를 중복해서 저장할 수 있으므로,     // 각각 별도의 조건문으로 작성해야 한다.     //  2 * 3 = 6     //  3 * 2 = 6     if (nextUglyNum === nextMultipleOf2) idx2++;     if (nextUglyNum === nextMultipleOf3) idx3++;     if (nextUglyNum === nextMultipleOf5) idx5++;   }   return uglyNumbers[n - 1]; };   오늘 느낀 점  해당 문제도 이미 유명한 문제였다. 참조할 만 한 좋은 링크가 있어서 코드를 보며 이해하고, 출처를 남겨두었다  다시 풀어 볼 예정   내일 할 일     TOY 36. closestPairOfPoints  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.22.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. Part3 - OAuth",
        "excerpt":"  Today I Learnd  1. Part3 - OAuth   OAuth는 인증을 중개해 주는 메커니즘이다.   이미 사용자 정보를 가지고 있는 웹 서비스(GitHub, google, facebook 등)에서 사용자의 인증을 대신해 주고, 접근 권한에 대한 토큰을 발급한 후, 이를 이용해 내 서버에서 인증이 가능하게끔 구현해야한다.   1-1. 사전 준비      OAuth 2.0 문서를 참조하여 GitHub에 내 앱 등록을 해야한다.   내 앱 등록을 끝낸 뒤, GitHub App에서 제공하는 Client ID 및 Client Secret의 정보를 서버에서 접근하기 위해 .env 파일에 환경변수를 등록해 주자.(Client Secret은 Github 계정 보안을 위해 타인에게 알려지면 안되므로 .env 파일 내부에서 관리해줘야 한다.)   1-2. 서버 구현   oauth/access_token           인증을 웹 서비스(Github)에서 처리하므로, 인증서가 따로 필요하지가 않다. 우리가 구현해야 할 서버는 Github 웹에 접근하여 authorization code를 이용해 access token을 발급받기 위한 post 요청을 해주어야 한다.         // req의 body로 authorization code가 들어옵니다. console.log를 통해 서버의 터미널창에서 확인해보세요!   // console.log(req.body);    // TODO : 이제 authorization code를 이용해 access token을 발급받기 위한 post 요청을 보냅니다. 다음 링크를 참고하세요.   // https://docs.github.com/en/free-pro-team@latest/developers/apps/identifying-and-authorizing-users-for-github-apps#2-users-are-redirected-back-to-your-site-by-github    axios.post('https://github.com/login/oauth/access_token',      { client_id: clientID, client_secret: clientSecret, code : req.body.authorizationCode },        { headers: { accept: 'application/json'}} )   .then((data)=&gt;{       res.status(200).json({accessToken : data.data.access_token});           accessToken 생성을 우리가 구현할 서버에서 하는 것이 아니라 OAuth에서 대신 해주고 있기때문에 authorization code를 이용해서 Github App api endpoint로 post 요청을 보내준다.       1-3. 클라이언트 구현   Login           components/Login.js에서 할 일은 Github App에 요청을 보내 Authorization code를 받아오는 일이다.         // TODO: GitHub로부터 사용자 인증을 위해 GitHub로 이동해야 합니다. 적절한 URL을 입력하세요.   // OAuth 인증이 완료되면 authorization code와 함께 callback url로 리디렉션 합니다.   // 참고: https://docs.github.com/en/free-pro-team@latest/developers/apps/identifying-and-authorizing-users-for-github-apps    this.GITHUB_LOGIN_URL = `https://github.com/login/oauth/authorize?client_id=${client가 들어간다.}`           App           Login 컴포넌트에서 Github App에 접속하여 인증 후 Authorization code를 받아왔다면 해당 코드를 server(server &gt; index.js)에 전달해 accessToken을 받아와야 한다.       받아온 accessToken은 App 컴포넌트의 state에 저장한 후, Mypage 컴포넌트에서 props로 내려받아 활용해야 한다.         /* 생략 */ \t   constructor() {       super();       this.state = {           isLogin: false,           // TODO:           accessToken: '',  // 받아온 accessToken을 state에 저장해야 한다.       };       this.getAccessToken = this.getAccessToken.bind(this);   }    async getAccessToken(authorizationCode) {       // 받아온 authorization code로 다시 OAuth App에 요청해서 access token을 받을 수 있습니다.       // access token은 보안 유지가 필요하기 때문에 클라이언트에서 직접 OAuth App에 요청을 하는 방법은 보안에 취약할 수 있습니다.       // authorization code를 서버로 보내주고 서버에서 access token 요청을 하는 것이 적절합니다.       // TODO: 서버의 /callback 엔드포인트로 authorization code를 보내주고 access token을 받아옵니다.       // access token을 받아온 후       //  - 로그인 상태를 true로 변경하고,       //  - state에 access token을 저장하세요        const data = await axios.post('http://localhost:8080/callback', { authorizationCode: authorizationCode });  // 클라이언트 -&gt; 서버로 authorization code를 보내준 뒤 서버에서 Github App으로 요청을 한다.        this.setState({           isLogin: true,           accessToken: data.data.accessToken  // 받아온 accessToken을 App 컴포넌트의 state에 저장한다.       });   }           Mypage           받아온 accessToken으로 리소스에 대한 API 요청을 할 수 있다.       accessToken을 전달하는 방식은 앞서 토큰에서 배웠던 Bearer Token 을 headers에 담아 주어 전달한다.         constructor(props) {       super(props);       this.state = {           images: [],           // TODO: GitHub API 를 통해서 받아올 수 있는 정보들 중에서           // 이름, login 아이디, repository 주소, public repositoty 개수를 포함한 다양한 정보들을 담아주세요.           name: '',           login: '',           html_url: '',           public_repos: null       }   }    async getGitHubUserInfo() {       // TODO: GitHub API를 통해 사용자 정보를 받아오세요.       // https://docs.github.com/en/free-pro-team@latest/rest/reference/users#get-the-authenticated-user        const data = await axios.get('https://api.github.com/user', {           headers: {               authorization: `token ${this.props.accessToken}`  // token이 필요한 API 요청 시 header authorization token 담아서 보내기           }       });        this.setState({  // Github API를 통해 받아온 정보 갱신           name: data.data.name,           login: data.data.login,           html_url: data.data.html_url,           public_repos: data.data.public_repos       })   }           1-4. 결과 확인         클라이언트의 Login 컴포넌트를 통하여 Github에 로그인 하여 authorization code를 받아 온 뒤, App 컴포넌트를 통해서 서버 controller/callback.js로 authorization code를 전달해 준다.   서버에서는 Github API (https://github.com/login/oauth)에 유효한 authorization code를 보내 accessToken을 발급 받은 뒤, 응답 결과에 토큰을 담아 다시 클라이언트로 전달 해준다.   Mypage 컴포넌트에서는 전달 받은 accessToken을 headers의 authorization에 담아서 GET 메소드로 Gihub API (https://api.github.com/user) 에서 사용자정보를 받아온다.   GET 메소로 전달 받은 결과값을 현재 클라이언트에서 보여준다.         오늘 느낀 점  후~ 드디어 [인증/보안 ] 일정을 모두 마쳤다..   우선 학습 할 양이 너무 많다.  아직은 레퍼런스코드를 보며 이해하는 수준이기 때문에, 진짜 내것으로 만드는게 중요하다.   세션은 잘 안쓰일 듯 하고… 토큰 방식 &amp; OAuth 2.0 방식의 백엔드 로직은 눈에 더 익어야 바로바로 쓸 수 있을거 같다..   평소에 별 생각 없이 “구글로 로그인” 을 눌러댔는데, 앞으로 유심히 볼 듯 하다.         내일 할 일     [컴퓨터 공학] 기초  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.22.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 36. closestPairOfPoints",
        "excerpt":"  TOY 36. closestPairOfPoints  문제   좌표평면 상의 다양한 점들을 입력받아 가장 가까운 두 점 사이의 거리를 리턴해야 합니다.   입력   인자 1: points     배열을 요소로 갖는 배열   points.length는 20,000 이하   points[i]는 number 타입을 요소로 갖는 배열   points[i].length는 2   points[i]의 요소는 차례대로 좌표평면 위의 y좌표, x좌표   points[i][j]는 0 이상 10,000 이하의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      points는 y좌표나 x좌표 등으로 정렬되어 있지 않습니다.   두 점 사이의 거리를 계산하는 함수 calculateDistance가 주어집니다. 두 점 간 거리는 반드시 이 함수를 이용해서 계산해야 합니다.   함수 calculateDistance는 소수점 계산을 피하기 위해 두 점 사이의 거리에 100을 곱한 후 정수 부분만 취합니다. 최단 거리도 이 기준으로 판단합니다.   입출력 예시   let points = [   [0, 0],   [1, 3],   [2, 2], ]; let output = closestPairOfPoints(points); console.log(output); // --&gt; 141 ([1, 3], [2, 2]) /* 3 |  2 |     x 1 |       x 0 | x  ------------     0 1 2 3  */  points = [   [0, 0],   [0, 1],   [0, 3],   [0, 5], ]; output = closestPairOfPoints(points); console.log(output); // --&gt; 100 ([0, 0], [0, 1]) /* 5 | x 4 |  3 | x 2 |      1 | x      0 | x  ------------     0 1 2 3  */   Advanced      가장 가까운 두 점 사이의 거리를 구하는 효율적인 알고리즘(O(N * logN))이 존재합니다.   힌트      효율적인 알고리즘은 병합 정렬(merge sort)과 비슷하게 분할 정복(divide and conquer) 알고리즘을 사용해야 합니다. 어떻게 나눠야 할 지, 나누었을 때 놓치는 부분은 없는 지 유의하면서 고민해 보시기 바랍니다.   TOY 36. Solution  수도코드    문제풀이        Reference Code  // 좌표평면 위의 두 점 사이의 거리를 계산하는 함수입니다. function calculateDistance(p1, p2) {   const yDiffSquared = Math.pow(p2[0] - p1[0], 2);   const xDiffSquared = Math.pow(p2[1] - p1[1], 2);   const dist = Math.sqrt(yDiffSquared + xDiffSquared);   return Math.round(dist * 100); }  // naive solution: O(N^2) // 모든 쌍을 비교하는 방법 // const closestPairOfPoints = function (points) { //   let min = Number.MAX_SAFE_INTEGER; //   for (let src = 0; src &lt; points.length; src++) { //     for (let dst = src + 1; dst &lt; points.length; dst++) { //       const dist = calculateDistance(points[src], points[dst]); //       min = Math.min(min, dist); //     } //   } //   return min; // };  const merge = function (left, right, comparator = (item) =&gt; item) {   let merged = [];   let leftIdx = 0,     rightIdx = 0;   const size = left.length + right.length;    for (let i = 0; i &lt; size; i++) {     if (leftIdx &gt;= left.length) {       merged.push(right[rightIdx]);       rightIdx++;     } else if (       rightIdx &gt;= right.length ||       comparator(left[leftIdx]) &lt;= comparator(right[rightIdx])     ) {       merged.push(left[leftIdx]);       leftIdx++;     } else {       merged.push(right[rightIdx]);       rightIdx++;     }   }    return merged; };  const mergeSort = function (arr, comparator) {   const aux = (start, end) =&gt; {     if (start &gt;= end) return [arr[start]];     const mid = Math.floor((start + end) / 2);     const right = aux(start, mid);     const left = aux(mid + 1, end);     return merge(left, right, comparator);   };   return aux(0, arr.length - 1); };  // divide and conquer: O(N * logN) const closestPairOfPoints = function (points) {   const bruteForce = (start, end, sorted) =&gt; {     // naive solution과 동일한 로직     // 모든 쌍을 비교한다. 3개 이하에 대해서만 호출되므로 크게 비효율적이지 않다.     let min = Number.MAX_SAFE_INTEGER;     for (let src = start; src &lt;= end; src++) {       for (let dst = src + 1; dst &lt;= end; dst++) {         const dist = calculateDistance(sorted[src], sorted[dst]);         min = Math.min(min, dist);       }     }     return min;   };    const closestCrossing = (mid, sorted, min) =&gt; {     // 가운데(mid)를 기준으로     const strip = [];     const midX = sorted[mid][1];     let lIdx = mid - 1;     let rIdx = mid + 1;      // 왼쪽과 오른쪽 부분에서 가장 가까운 두 점 사이의 거리가 min으로 주어진다.     // 가운데를 기준으로 오직 x좌표만을 기준으로 min보다 가까운 좌표만 고려한다.     // y좌표가 같다고 가정하면, 최소한 이 조건(x좌표 기준 min 이하)을 만족해야하기 때문이다.     // y좌표가 같을 경우 두 점 사이의 거리는 x축 좌표 간의 거리다.     // 단, 소수점 계산을 피하기 위해 두 점 사이의 거리에 100을 곱하고 있으므로 동일한 기준을 적용해야 한다.      // sorted는 x축을 기준으로 정렬되어 있기 때문에,     // mid를 기준으로 가까운 거리부터 최소 기준(min보다는 가까워야 함)을 만족할 때까지만 탐색을 하면 된다.     while (       rIdx &lt; sorted.length &amp;&amp;       Math.abs(midX - sorted[rIdx][1]) * 100 &lt; min     ) {       rIdx++;     }     while (lIdx &gt;= 0 &amp;&amp; Math.abs(midX - sorted[lIdx][1]) * 100 &lt; min) {       lIdx--;     }      // while 탈출하기 위한 조건을 보면,     // lIdx는 1을 더해야 하고, rIdx는 1을 줄여야 한다.     // 아래 구간에 대해서 brute force를 적용한다.     for (let i = lIdx + 1; i &lt; rIdx; i++) {       for (let j = i + 1; j &lt; rIdx; j++) {         min = Math.min(min, calculateDistance(sorted[i], sorted[j]));       }     }     return min;   };    const closestFrom = (start, end, size, sorted) =&gt; {     if (size &lt;= 3) {       // 최소 두 개 이상의 점이 있어야 거리를 계산할 수 있다.       //  1) 모든 점의 개수가 4개일 경우, 각각 2개로 나눌 수 있다.       //  2) 모든 점의 개수가 5개일 경우, 각각 2, 3개로 나눌 수 있다. 3개인 경우 더 나눌 수 없다.       return bruteForce(start, end, sorted);     }     // 가운데를 기준으로 분할한 뒤 재귀적으로 문제를 해결한다.     const mid = Math.floor((start + end) / 2);     // 왼쪽, 오른쪽으로 나뉜 부분에서 각각 가장 가까운 두 점 사이의 거리를 구한다.     const minLeft = closestFrom(start, mid, mid - start + 1, sorted);     const minRight = closestFrom(mid + 1, end, end - mid, sorted);      // 전체 영역에서 가장 가까운 두 점 사이의 거리는 아래 중 하나다.     //  1) 위에서 구한 두 거리(minLeft, minRight)     //  2) 가운데를 가로지르는 두 점 사이의 거리     // 먼저 1)중에서 더 짧은 거리를 구한다. 최종 정답은 이보다 작거나 같아야 한다.     let min = Math.min(minLeft, minRight);     return closestCrossing(mid, sorted, min);   };    // x좌표를 기준으로 정렬한다.   const sorted = mergeSort(points.slice(0), (item) =&gt; item[1]);   return closestFrom(0, sorted.length - 1, sorted.length, sorted); };   오늘 느낀 점  우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   점점 코드를 짜기보다는 보고 이해하는 수준에서 진전이 안되고있다. 정규 과정이 끝나면 다시 풀어봐야겠다.   내일 할 일     TOY 37. coinChange  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.25.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. 컴퓨터 공학 기초 2. 운영체제 3. 가비지 컬렉션 4. 캐시",
        "excerpt":"  Today I Learnd  1. 컴퓨터 공학 기초    1-1. 문자열   유니코드          2010년도 이후, 유니코드라고 불리우는 인코딩 방식이 통일된 시대를 살아가고 있다. 유니코드(Unicode) 란 유니코드 협회(Unicode Consortium)가 제정하는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이다. 이 표준에는 ISO 10646 문자 집합, 문자 인코딩, 문자 정보 데이터베이스, 문자를 다루기 위한 알고리즘 등을 포함하고 있다.       유니코드가 탄생하기 이전에는 같은 한글이 적힌 텍스트 파일이라도 표현하는 방법이 제각각이었기에, 어떤 파일이 지원하지 않는 다른 인코딩 형식으로 저장되어 있는 경우에는 파일을 제대로 불러올 수 없는 문제가 발생했었다. 기본적으로 유니코드의 목적은 현존하는 문자 인코딩 방법을 모두 유니코드로 교체하는 것이다.              인코딩(부호화)란?         인코딩이란 어떤 문자나 기호를 컴퓨터가 이용할 수 있는 신호로 만드는 것이다. 이 신호를 입력하는 인코딩과 문자를 해독하는 디코딩을 하기 위해서는 미리 정해진 기준을 바탕으로 입력과 해독이 처리되어야 한다. 이렇게 인코딩과 디코딩의 기준을 문자열 세트 또는 문자셋(charset)이라고 하며, 이 문자셋의 국제 표준이 유니코드이다.             ASCII 문자          American Standard Code for Information Interchange 의 약자이며, 영문 알파벳을 사용하는 대표적인 문자 인코딩으로 7 비트로 모든 영어 알파벳을 표현할 수 있다. 52개의 영문 알파벳 대소문자와, 10개의 숫자, 32개의 특수 문자, 그리고 하나의 공백 문자를 포함한다.       그런데 쓰다보니 7비트 128개만으로는 표현하기에 부족하였다. 그렇게 탄생한 문자가 2^8개의 문자를 표현하는 8비트 아스키코드가 나왔다. 이 녀석을 ANSI 코드라고 한다. 이렇게 1 바이트만으로 표현되는 방식을 SBCS(Single Byte Character Set) 라고 한다.       반면, 유니코드는 ASCII, ANSI 외에 한자, 한글 등 모든 언어를 취급하는 16비트 2바이트의 크기로 확장한 형태이다.        UTF-8     UTF-8과 UTF-16은 인코딩 방식의 차이를 의미한다. UTF-8은 Universal Coded Character Set + Transformation Format – 8-bit의 약자로, UTF- 뒤에 등장하는 숫자는 비트(bit)이다.   UTF-8 은 유니코드 한 문자를 나타내기 위해 1 byte(= 8 bits) 에서 4 bytes까지 가변 길이 인코딩을 사용한다.        예를 들어, 코 라는 문자의 유니코드는 U+CF54 (16진수, HEX)로 표현되며, 이 문자를 이진법(binary number)으로 표시하면, 1100-1111-0101-0100 이 된다. 이 문자를 UTF-8로 표현하면, 다음과 같이 3byte 의 결과로 표현된다.       1110xxxx 10xxxxxx 10xxxxxx # x 안에 순서대로 값을 채워넣습니다. 11101100 10111101 10010100                다른 예로 b라는 ASCII 코드는 7비트로 표현되고, UTF-8 에서는 다음과 같이 1 byte의 결과로 만들 수 있다       0xxxxxxx 01100010                 이처럼, UTF-8은 1 byte에서 4 bytes까지의 가변 길이를 가지는 인코딩 방식이다. 네트워크를 통해 전송되는 텍스트는 주로 UTF-8로 인코딩되며 그 이유는 사용된 문자에 따라 더 작은 크기의 문자열을 표현할 수 있기 때문이다. ASCII 문자는 1 바이트만으로 표현 가능한 것처럼 효율적이다.       UTF-8은 ASCII 코드의 경우 1 byte, 영어 외 글자는 2byte, 3byte, 보조 글자및 특수문자는 4byte를 차지한다. ex) 이모지는 보조 글자에 해당하기 때문에 4byte가 필요하다.        UTF-16     UTF-16은 유니코드 코드 대부분(U+0000부터 U+FFFF; BMP) 을 16 bits로 표현한다.            대부분에 속하지 않는 기타문자는 32 bit(4 bytes)로 표현하므로 UTF-16도 가변길이라고 할 수 있으나, 대부분은 2 바이트로 표현한다           U+ABCD라는 16진수를 있는 그대로 이진법으로 변환하면 1010-1011-1100-1101 이다. 이 이진법으로 표현된 문자를 16 bits(2 bytes)로 그대로 사용하며, 바이트 순서(엔디언)에 따라 UTF-16의 종류도 달라진다.   UTF-8에서는 한글은 3 바이트, UTF-16에서는 2 바이트를 차지한다.     1-2. 그래픽   비트맵(래스터)과 벡터 이미지의 차이점                            비트맵(래스터)       벡터                       기반 기술       픽셀 기반       수학적으로 계산된 Shape 기반                 특징       사진과 같이 색상의 조합이 다양한 이미지에 적합       로고, 일러스트와 같이 제품에 적용되는 이미지에 적합                 확대       확대에 적합하지 않음, 보다 큰 사이즈의 이미지가 필요할 때 사용하려는 크기 이상으로 생성하거나 스캔해야 함       품질 저하없이 모든 크기로 확대 가능하며, 해상도의 영향을 받지 않음                 크기(dimension)에 따른 파일 용량(file size)       큰 크기의 이미지는, 큰 파일 사이즈를 가짐       큰 크기의 벡터 그래픽은 작은 파일 사이즈를 유지할 수 있음                 상호 변환       이미지의 복잡도에 따라 벡터로 변환하는 것에 오랜 시간이 걸림       쉽게 래스터 이미지로 변환 가능                 대표적인 파일 포맷       jpg, gif, png, bmp, psd       svg, ai                 웹에서의 사용성       jpg, gif, png 등이 널리 쓰임       svg 포맷은 현대의 브라우저에서 대부분 지원            2. 운영체제   2-1. 운영체제 개요   컴퓨터나 스마트폰의 기기 그 자체(하드웨어)는 스스로 할 수 있는 일이 없다. 하드웨어의 설계를 바탕으로 하드웨어에게 일을 시켜야만 그 의미가 있으며 하드웨어에게 일을 시키는 주체가 바로 운영체제이다.    시스템 자원 관리     운영체제가 없다면, 응용 프로그램이 실행될 수 없다. 응용 프로그램은 컴퓨터를 이용해 다양한 작업을 하는 것이 목적이고, 운영체제는 응용 프로그램이 하드웨어에게 일을 시킬 수 있도록 도와준다. 하드웨어를 구성하는 일을 하는 CPU, 자료를 저장하는 RAM, 디스크 등의 시스템 자원을 관리하는 주체가 바로 운영체제이다.            프로세스 관리(CPU)       메모리 관리       I/O(입출력) 관리 (디스크, 네트워크 등)                   응용 프로그램 관리          모든 응용 프로그램이 시스템의 자원을 마음대로 사용한다면, 해커에 의한 응용프로그램 공격에 무방비한 상태가 된다. 악의적인 목적을 가진 프로그램이 디스크의 모든 민감한 정보에 접근하거나, 내 스마트폰의 특정 앱이 카메라를 아무때나 실행해서 촬영한다고 생각하면 어떨까?       따라서, 응용 프로그램은 권한에 대한 관리가 필요하다. 또한 여러 사람이 하나의 기기를 사용하는 경우에는 사용자를 관리하는 일도 매우 중요하다. 이를 관리하는 주체는 운영체제이다.            응용 프로그램이 운영체제와 소통하기 위해서는 운영체제가 응용 프로그램을 위해 인터페이스(API)를 제공해야 한다. 응용 프로그램이 시스템 자원을 사용할 수 있도록, 운영체제 차원에서 다양한 함수를 제공하는 것을 시스템 콜(System call)이라고 부른다.  ex) 스마트폰에서 사용자에게 어떤 디바이스(카메라 등)의 사용권한 묻는 창        2-2. 프로세스, 스레드, 멀티 스레드    프로세스(Process)     운영체제에서는 실행 중인 하나의 애플리케이션을 프로세스라고 부른다.        사용자가 애플리케이션을 실행하면, 운영체제로부터 실행에 필요한 메모리를 할당 받아 애플리케이션의 코드를 실행한다. 이때 실행되는 애플리케이션을 프로세스라고 부른다.       ex) Chrome 브라우저를 두 개 실행하면, 두 개의 프로세스가 생성된다.       이렇게 하나의 애플리케이션은 여러 프로세스(다중 프로세스)를 만들기도 한다.        스레드(Thread)     프로세스 내에서 실행되는 흐름의 단위이다.   일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드(멀티 스레드)를 동시에 실행할 수 있으며 각각의 스레드는 다른 스레드와 독립적으로 동작한다.    멀티 스레드(Multi-Thread)     멀티 태스킹은 두 가지 이상의 작업을 동시에 처리하는 것을 의미한다. 운영체제는 멀티 태스킹을 할 수 있도록, 프로세스마다 CPU 및 메모리 자원을 적절히 할당하고 병렬로 실행한다. ex)워드로 문서작업을 하면서, 동시에 Chrome 브라우저에서 음악을 들을 수 있다.   하나의 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 애플리케이션도 있기에 멀티 태스킹은 꼭 멀티 프로세스를 의미하는 것은 아니다. 하나의 프로세스가 두 가지 이상의 작업을 처리하는 경우는 멀티 스레드가 가능한 프로세스인 경우이기 때문이다.        멀티 프로세스가 애플리케이션 단위의 멀티 태스킹이라면, 멀티 스레드는 애플리케이션 내부에서의 멀티 태스킹이라고 할 수 있다.              프로세스를 이용하여 동시에 처리하던 일을 멀티 스레드로 구현할 경우, 메모리 공간과 시스템 자원의 소모가 줄어든다(각각의 프로세스는 스레드와 달리 실행시 필요한 메모리를 운영체제로 부터 할당 받는다). 그러므로 자연스럽게 프로그램의 응답 시간이 단축된다는 장점이 있다.   멀티 프로세스 기반으로 프로그래밍할 때에는 프로세스 간 공유하는 자원이 없기에 동일한 자원에 동시에 접근하는 일이 없었지만, 멀티 스레딩을 기반으로 프로그래밍할 때에는 공유하는 자원에 대하여  서로 다른 스레드가 같은 데이터에 접근하고 힙 영역을 공유하기 때문에, 서로 다른 스레드가 서로 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정을 하는 얘기치 않은 사이드이펙트가 발생할 수 있다는 단점이 있다.    3. 가비지 컬렉션(Garbage Collection, GC)       가비지 컬렉션은 메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능이다.   대표적인 가비지 컬렉션의 방법            트레이싱 : 한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후 삭제하는 mark and sweep 방법이다.       레퍼런스 카운팅 : 한 객체를 참조하는 변수의 수를 추적하는 방법이다.            4. 캐시       많은 시간이나 연산이 필요한 작업의 결과를 저장해두는 것을 의미한다.        컴퓨팅에서 캐시는 일반적으로 일시적인(temporarily) 데이터를 저장하기 위한 목적으로 존재하는 고속의 데이터 저장공간(일반적으로 RAM과 같이 빠르게 액세스할 수 있는 하드웨어)이다.       첫 작업 이후에 이 데이터에 대한 요청이 있을 경우, 데이터의 기본 저장공간에 접근할 때보다 더 빠르게 요청을 처리할 수 있게되며, 캐싱을 사용하면 이전에 검색하거나 계산한 데이터를 효율적으로 재사용할 수 있다.       속도를 위해 용량을 절충하는 캐시는 일반적으로 데이터의 하위 집합을 일시적으로 저장한다. 완전하고 영구적인 데이터가 있는 데이터베이스와는 대조적이다.         오늘 느낀 점  컴퓨터 이론에 대해 학습하였다. 사실 공학에 관련된 내용이기에, 기재된 내용은 굉장히 빙산의 일각만도 못한 굉장히 적은 영역에서의 컴퓨터 공학 개론이다.   앞으로 알아갈 혹은 배웠던 내용들이 비전공자여도 내용중 이정도는 짚고넘어가야 이해가 원활하기때문에 이런 챕터가 있다 생각된다.         내일 할 일     [네트워크] 심화  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.25.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 37. coinChange",
        "excerpt":"  TOY 37. coinChange  문제   다양한 동전들을 가지고 특정 금액을 만들 수 있는 모든 경우의 수를 리턴해야 합니다.      예를 들어, 100원, 500원짜리 동전을 가지고 1,000원을 만들 수 있는 방법은 총 3가지 입니다.   100원 10개, 100원 5개 + 500원 1개, 500원 2개   입력   인자 1 : total     number 타입의 이하의 자연수   인자 2 : coins     number 타입을 요소로 갖는 배열   coins.length는 10,000 이하   coins[i]는 20 이하의 양의 정수   출력      number 타입을 리턴해야 합니다.   주의사항      동전의 금액은 다양하게 주어집니다.   coins는 오름차순으로 정렬되어 있습니다.   각 동전의 개수는 무수히 많다고 가정합니다.   입출력 예시   let total = 10; let coins = [1, 5]; let output = coinChange(total, coins); console.log(output); // --&gt; 3  total = 4; coins = [1, 2, 3]; output = coinChange(total, coins); console.log(output); // --&gt; 4 ([1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3])   Advanced      coinChange를 계산하는 효율적인 알고리즘(O(M * N))이 존재합니다(total과 coins.length가 N, M일 경우). 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.   TOY 37. Solution  수도코드    문제풀이        Reference Code  // naive solution: O(2^M * N)) // 6을 만드는 방법 중 [1, 5]와 [5, 1]을 중복해서 세면 안 되기 때문에. // 동전을 순서대로 사용한다. // const coinChange = function (total, coins) { //   const makeChageFrom = (left, idx) =&gt; { //     if (left === 0) return 1;  //     let cnt = 0; //     // 지금 사용하고 있는 동전부터만 고려한다. //     for (let i = idx; i &lt; coins.length; i++) { //       if (left - coins[i] &gt;= 0) { //         cnt = cnt + makeChageFrom(left - coins[i], i); //       } //     }  //     return cnt; //   }; //   // 0번째 동전부터 사용한다. //   return makeChageFrom(total, 0); // }; /* 동전을 하나씩 빼는 메커니즘(재귀로 구현), 횟수가 진행될수록 거듭제곱으로 시간복잡도가 증가한다. */  // simpler recursion // and dynamic programming with memoization: O(M * N) const coinChange = function (total, coins) {   // memo[i][j]는 i만큼의 금액을 coins[j]부터 ~ coins[coins.length - 1]까지 사용하여 만들 수 있는 경우의 수를 저장   const memo = [];   for (let i = 0; i &lt; total + 1; i++) memo.push(Array(coins.length).fill(-1));   const makeChageFrom = (left, idx) =&gt; {     // 0을 만드는 방법은 1가지이다. 아니면 목표 금액을 만들었다고 생각해도 된다.     if (left === 0) return 1;     // 금액이 마이너스가 되는 경우는 불가능하므로 0을 리턴     if (left &lt; 0) return 0;     // 동전을 전부 검토해서, 남아있는 새로운 동전은 없는데 목표 금액을 만들지 못한 경우 (실패)     if (idx &gt;= coins.length &amp;&amp; left &gt; 0) return 0;     // 이미 해결한 적이 있는 문제는 다시 풀지 않는다.     if (memo[left][idx] !== -1) return memo[left][idx];      // left만큼의 금액을 coins[idx]부터 사용하여 만들 수 있는 경우의 수는     //  1) coins[idx]는 그만 사용하고, 다음 동전으로 넘어가거나 (목표 금액은 그대로이고, idx가 증가한다.)     //  2)) coins[idx]를 한번 더 사용한다. coins[idx]를 또 사용할 수 있으므로, idx는 그대로이고, 목표 금액은 coins[i]만큼 줄어든다.     memo[left][idx] =       makeChageFrom(left, idx + 1) + makeChageFrom(left - coins[idx], idx);     return memo[left][idx];   };    return makeChageFrom(total, 0); };  // dynamic programming with tabulation: O(M * N) // const coinChange = function (total, coins) { //   // table[i][j]는 coins[j]까지 사용해서 i만큼의 금액을 만들 수 있는 경우의 수를 저장 //   const table = []; //   for (let i = 0; i &lt; total + 1; i++) table.push(Array(coins.length).fill(0)); //   // 모든 경우에 0을 만들 수 있는 경우는 1 (base case) //   for (let i = 0; i &lt; coins.length; i++) table[0][i] = 1;  //   for (let amount = 1; amount &lt;= total; amount++) { //     // 작은 금액부터 차례대로 경우의 수를 구한다. (bottom-up) //     for (let idx = 0; idx &lt; coins.length; idx++) { //       let coinIncluded = 0; //       if (amount - coins[idx] &gt;= 0) { //         coinIncluded = table[amount - coins[idx]][idx]; //       }  //       let coinExcluded = 0; //       if (idx &gt;= 1) { //         // 동전을 순서대로 검사하고 있기 때문에, 바로 직전의 경우만 고려하면 된다. //         // 단, 0번째 동전은 직전이 없으므로 제외한다. //         coinExcluded = table[amount][idx - 1]; //       }  //       table[amount][idx] = coinIncluded + coinExcluded; //     } //   }  //   return table[total][coins.length - 1]; // }; /* 값이 나올때마다 저장하여 배열에 저장하여 꺼내쓰는 방식 */   오늘 느낀 점   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   내일 할 일     TOY 38. decompression  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.26.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. 인터넷 프로토콜 2. HTTP 헤더 3. 웹 캐시",
        "excerpt":"  Today I Learnd  1. 인터넷 프로토콜    1-1. IP와 IP Packet           IP 패킷에서 패킷은 pack과 bucket이 합쳐진 단어로 소포로 비유할 수 있다. IP 패킷은 우체국 송장처럼 전송 데이터를 무사히 전송하기 위해 출발지 IP, 목적지 IP와 같은 정보가 포함되어 있으며 데이터를 전달하는 통신의 단위이다.              클라이언트 패킷 전달 과정을 살펴보면 다음과 같다.            클라이언트가 IP 패킷을 인터넷 상의 노드에 던진다.       인터넷 상의 노드(컴퓨터)들은 모두 IP 프로토콜을 따르기 때문에 해당 패킷의 정보(출발지, 목적지)를 이해할 수 있다.       중간 노드들은 목적지 노드가 어디있는지 서로 물어가면서 해당 패킷을 전달한다. (라우팅 과정)           위 과정을 통해 복잡한 인터넷 망 사이에서도 정확한 목적지로 패킷을 전송할 수 있다.                   서버 패킷 전달 과정또한 클라이언트와 마찬가지로 이뤄지며, 패킷 단위 데이터로 통신이 이뤄진다.               IP 프로토콜 한계     정확한 출발지와 목적지를 파악할 수 있다는 점에서 IP 프로토콜은 적절한 통신 방법으로 보이지만 단점도 명확하다.            비연결성 : 만약 패킷을 받을 대상이 없거나 서비스 불능 상태여도 클라이언트는 서버의 상태를 파악할 방법이 없기 때문에 패킷을 그대로 전송하게 된다.                        비신뢰성 : 중간에 있는 서버가 데이터를 전달하던 중 장애가 생겨 패킷이 중간에 소실되더라도 클라이언트는 이를 파악할 방법이 없다.                                 비신뢰성(패킷 전달 순서 문제) : 전송하려는 패킷의 용량이 매우 큰 경우 (대략 1500Byte 정도가 넘으면 해당 내용을 끊어서 보낸다), 이러한 경우 전송하려는 패킷들의 순서가 중요하다.           그러나 IP프로토콜에서는 하나의 데이터에 연관된 패킷들이 각각 다른 경로로 전송될 수 있다. 따라서 도착하는 순서도 보장되지 않는다.                               1-2. TCP / UDP          네트워크 프로토콜 계층은 다음과 같이 OSI 7계층과 TCP/IP 4 계층으로 나눌 수 있다.              IP 프로토콜 보다 더 높은 계층에 TCP 프로토콜이 존재하기 때문에 앞서 다룬 IP 프로토콜에서 발생했던 수많은 문제들(패킷의 순서가 꼬이고, 유실되는 등의 문제)을 TCP 프로토콜이 해결해준다.            우선 FLOW CHART를 보면 다음과 같다.                     응용프로그램이 HTTP 프로토콜을 통하여 ‘Hello World’ 메시지 생성함.       SOCKET 라이브러리를 통해 OS계층에 HTTP 메시지 전달됨.       TCP Layer 에서는 Hello, world 메시지에 TCP 세그먼트를 씌운다.       TCP 세그먼트가 씌워진 HTTP 메세지를 IP 계층으로 전달(받은 메시지 위에 또 IP와 관련된 데이터들을 씌운다). ➡ TCP/IP 패킷이 생성됨.       이렇게 생성된 TCP/IP 패킷은 LAN 카드와 같은 물리적 계층을 지나기 위해 이더넷 프레임 워크에 포함되어 서버로 전송함.                  TCP 세그먼트란?                  TCP 세그먼트에는 IP 패킷의 출발지 IP와 목적지 IP 정보를 보완할 수 있는 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등을 포함한다. ➡ IP에서 해결이 안되었던 순서 제어문제 등이 해결된다.             TCP 특징     전송 제어 프로토콜(Transmission Control Protocol) 이다. 다음과 같은 특징을 갖기 때문에 TCP는 같은 계층에 속한 UDP에 비해 상대적으로 신뢰할 수 있는 프로토콜이며, 현재 대부분 TCP를 사용한다.            연결 지향 - TCP 3 way handshake (가상 연결) : 링크 참조.       데이터 전달 보증 (패킷 소실 문제 해결) : TCP는 데이터 전송이 성공적으로 이루어진다면 이에 대한 응답을 돌려주기 때문에 IP 패킷의 한계인 비연결성을 보완이 가능하다.       순서 보장 (패킷 순서 문제 해결) : TCP는 패킷이 순서대로 도착하지 않는다면 TCP 세그먼트에 있는 정보를 토대로 다시 패킷 전송을 요청할 수 있다. 이를 통해 IP 패킷의 한계인 비신뢰성(순서를 보장하지 않음)을 보완할 수 있게된다.            UDP 특징     사용자 데이터그램 프로토콜(User Datagram Protocol) 이다. UDP는 IP 프로토콜에 PORT, 체크섬 필드 정보만 추가된 단순한 프로토콜이다.            비 연결 지향 : 3 way handshake 방식을 사용하지 않기 때문에 TCP와 비교해 빠른 속도를 보장한다.                  체크섬(checksum)은 중복 검사의 한 형태로, 오류 정정을 통해, 공간(전자 통신)이나 시간(기억 장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법이다.            HTTP3는 UDP를 사용하며, 이미 여러 기능이 구현된 TCP 보다는 하얀 도화지처럼 커스터마이징이 가능하다는 장점이 있다.    1-3. HTTP     HTTP(HyperText Transfer Protocol)는 W3 상에서 정보를 주고받을 수 있는 프로토콜이다. 주로 TCP를 사용하고 HTTP/3 부터는 UDP를 사용하고 있다.   HTTP는 다음과 같은 특징을 갖는다.                     클라이언트 서버 구조 : 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조이다.                          무상태 프로토콜(Stateless) : HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜이다. (무상태성을 보완하기 위하여 나온게 브라우저 상태를 유지할 수 있게 하는 쿠키, 세션, 토큰.. 등 이다.)       비연결성(Connectionless) : 비 연결성을 가지는 HTTP에서는 실제로 요청을 주고 받을 때만 연결을 유지하고, 응답을 주고나면 TCP/IP 연결을 끊는다. 이를 통해 최소한의 자원으로 서버 유지를 가능하게 한다.            2. HTTP 헤더    HTTP 헤더는 HTTP 전송에 필요한 모든 부가정보를 (메시지 바디의 내용, 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보 등) 넣는 영역이다.    2-1. 표현 헤더(Representation Headers)     과거의 헤더는 위와 같이 분류하였다. 하지만 이런 엔티티 헤더 스펙은 1999년 RFC2616 스펙에서 나온 스펙인데, 이 스펙은 2014년 RFC7230~7235가 등장하면서 폐기된다. 그 이후 엔티티라는 표현은 표현이라는 용어가 사용된다.      Entity 헤더:  엔티티 바디 정보로 컨텐츠 타입이나 길이같은 메세지 바디에 들어가는 내용에 관련된 헤더가 들어가는 헤더       현재의 헤더는 왜 엔티티를 표현이라고 바꿔서 말하는 것일까? 예를들어 회원 조회 내역을 응답할 때 이를 HTML로 표현할 수도 있고, JSON으로 표현해 전달할 수도 있다. 그래서 이렇게 실제 전달하는 것을 표현이라고 용어를 정의했다.    표현       회원이라는 리소스가 있을 때 이를 HTML 혹은 JSON으로 전달할 것인지는 클라이언트와 서버간에 송/수신할 때 이 리소스를 무엇으로 표현할지 알려주고, 표현한다.        다음은 표현 데이터의 형식, 압축 방식, 자연 언어, 길이등을 설명하는 헤더이다.                              Cotent-Type : 표현 데이터의 형식                                   Cotent-Encoding : 표현 데이터의 압축 방식                                   Cotent-Language : 표현 데이터의 자연 언어                                   Cotent-Length : 표현 데이터의 길이                                   표현 헤더는 요청, 응답 둘 다 사용한다.                    2-2. HTTP 주요 헤더        요청(Request)에서 사용되는 헤더      From : 유저 에이전트의 이메일 정보.            일반적으로 잘 사용하지 않는다.       검색 엔진에서 주로 사용한다.           Referer (referrer의 오탈자이지만 스펙으로 굳어짐): 현재 요청된 페이지의 이전 웹 페이지 주소.            A → B로 이동하는 경우 B를 요청할 때 Referer: A 를 포함해서 요청한다.       Referer 를 사용하면 유입경로 수집 가능하다.           User-Agent : 유저 에이전트 애플리케이션 정보(웹 브라우저 정보, 등등).            통계 정보를 나타낼 수 있다.       어떤 종류의 브라우저에서 장애가 발생하는지 파악이 가능하다.           Host : 요청한 호스트 정보(도메인).            하나의 서버가 여러 도메인을 처리해야 할 때 호스트 정보를 명시하기 위해 사용한다.       하나의 IP 주소에 여러 도메인이 적용되어 있을 때 호스트 정보를 명시하기 위해 사용한다.           Origin : 서버로 POST 요청을 보낼 때, 요청을 시작한 주소를 나타냄            여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 발생한다.       응답 헤더의 Access-Control-Allow-Origin와 관련있다.           Authorization : 인증 토큰(ex) JWT)을 서버로 보낼 때 사용하는 헤더.    응답(Response)에서 사용되는 헤더     Server : 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보.   Date : 메시지가 발생한 날짜와 시간.   Location : 페이지 리디렉션.            웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 리다이렉트(자동 이동)       201(Created): Location 값은 요청에 의해 생성된 리소스 URI.       3xx(Redirection): Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킨다.           Allow : 허용 가능한 HTTP 메서드. ex) Allow: GET, HEAD, PUT   Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간.    2-3. 콘텐츠 협상 헤더     클라이언트가 선호하는 표현 요청   클라이언트와 서버간에 클라이언트가 원하는 우선순위대로 맞춰서 서버에서 되는대로 표현 데이터를 만들어 주는 것,  클라이언트에서 요청시에만 작성하는 것이기에 요청에만 사용한다.            Accept : 클라이언트가 선호하는 미디어 타입 전달.       Accept_Charset : 클라이언트가 선호하는 문자 인코딩.       Accept-Encoding : 클라이언트가 선호하는 압축 인코딩.       Accept-Language : 클라이언트가 선호하는 자연 언어.            콘텐츠 협상 예시    Accept-Language 적용 전         한국어 브라우저에서 특정 웹사이트에 접속했을 때 콘텐츠 협상(Accept-Language)이 안되있을 경우, 서버에서는 딱히 우선순위같은게 없기에 기본언어로 설정된 영어로 응답한다.   Accept-Language 적용 전         클라이언트에서 Accept-Language로 KO를 작성해 요청하면 서버에서는 해당 우선순위 언어를 지원할 수 있기 때문에 해당 언어인 한국어로 된 응답을 작성해 반환해준다.     Accept-Language 복잡한 예시   위처럼 지원하는 언어를 요청하는 단순한 경우라면 문제가 없다. 하지만, 서버에서 지원하는 언어가 여러개인데 내가 최우선으로 선호하는 언어는 적용되지 않는다면 어떻게 해야하는가?         클라이언트에서는 한국어를 선호하기에 Accept-Language에 한국어를 요청했다.   하지만 서버에서는 한국어를 지원하지 않는상황이고 기본 언어는 독일어로 되어있다.   클라이언트에서는 독일어는 너무 어렵기 때문에 한국어가 안되면 영어라도 나오길 바란다면? ➡ 우선순위를 사용해야 한다.     협상과 우선순위   Quality Values(q)         Quality Values(q) 값 사용   0~1, 1에 가까울수록(클수록) 높은 우선순위를 가진다.   생략하면 1   Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7            ko-KR;q=1 (q생략)       ko;q=0.9       en-US;q=0.8       en:q=0.7             Accept-Language 복잡한 예시 ➡ 우선 순위 적용 후         1순위인 한국어를 서버에서는 지원하지 않는다.   2순위인 영어를 서버에서는 지원한다.   서버에서는 우선순위에있는 영어를 독일어보다 선호하기에 영어로 응답한다.     3. 웹 캐시   3-1. 캐시의 기본 원리 및 적용   캐시가 없을 때    첫번째 요청         클라이언트에서 star.jpg 이미지를 요청한다.   서버에서는 해당 이미지가 있으면 응답을 줘야하는데, 이미지의 HTTP 헤더+바디를 합쳐 대략 1.1M정도 용량의 데이터를 응답한다.   클라이언트에서는 해당 이미지를 응답 받아 사용한다.    두번째 요청         클라이언트에서는 star.jpg 이미지를 다시 한 번 요청한다.   서버에서는 동일한 이미지를 다시 1.1M정도 용량의 데이터를 응답해준다.        클라이언트에서는 해당 이미지를 응답 받아 사용한다.              동일한 이미지를 요청하는데 네트워크를 통해 같은 데이터를 또 다운받아야 한다. 용량이 클 수록 비용이 커지고 브라우저의 로딩속도가 느려진다.             캐시가 적용되었을 때   첫번째 요청         헤더에 cache-controll 속성을 넣어주어 캐시가 유효한 시간을 넣어준다.   위에서는 60초로 설정해 60초 동안은 해당 캐시가 유효하다는 의미다.    두번째 요청         두 번째 요청할때는 우선 캐시를 조회한다.        캐시가 존재하고 아직 60초 이내이기에 유효한 캐시가 있어서 해당 캐시에서 자료를 가져온다.            유효시간이 초과된다면? ➡ 이 경우에는 다시 서버에 요청을하고 60초간 유효한 star.jpg 이미지를 응답받아서 캐시를 업데이트 해준다. 이때 다시 네트워크 다운로드는 발생한다.              캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 되어서 비싼 네트워크 사용량을 줄일 수 있다.         또한 브라우저 로딩 속도가 매우 빠르므로 사용자는 매우 빠른 경험을 할 수 있다.             3-2. 캐시 검증 헤더와 조건부 요청       캐시 유효 시간이 초과해 서버에 다시 요청하면 다음과 같은 상황이 생긴다.            서버에서 기존 데이터를 변경한 경우 (노란색 별이 초록색 별이 된 경우)       서버에서 기존데이터가 변경되지 않은 경우           캐시 만료후에도 서버에서 데이터를 변경하지 않은 경우 서버에서 동일한 데이터를 요청해서 응답받는 것은 여러모로 비용낭비다.   이럴때는 저장해 둔 캐시를 재사용 할 수 있는지 검증(클라이언트의 데이터와 서버의 데이터가 동일한지)하는 작업이 필요하다. 그래서 검증 헤더가 들어가게 된다.    Last-Modify &amp; If-Modified-Since    첫번째 요청           검증 헤더 Last Modified를 이용해 캐시의 수정시간을 알 수 있다.              Last Modified는 데이터가 마지막으로 수정된 시간정보를 헤더에 포함하므로, 이로 인해 응답 결과를 캐시에 저장할 때 데이터 최종 수정일도 저장된다.         두번째 요청           캐시 시간이 초과해서 다시 요청을 해야하는데, 캐시에 최종 수정일 정보(Last-Modified)가 있다면 요청 헤더에 if-modified-since에 해당 날짜를 담아서 서버에 보낸다.                   서버의 해당 자료의 최종 수정일과 비교해서 데이터가 수정이 안되었을 경우 응답 메세지에 이를 담아서 알려준다.                     HTTP Body는 응답 데이터에 없다.       상태코드는 304 Not Modified로 변경된것이 없다는 것을 알린다.       그래서 전송 데이터는 바디가 빠졌기에 헤더만 포함된 0.1M만 전송된다.       클라이언트에서는 해당 응답을 받은 뒤 캐시를 갱신해주고 다시 일정시간(60초) 유효하게 된다.            Last-Modify &amp; If-Modified-Since 정리      캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면   304 Not Modified + 헤더 메타 정보만 응답한다.   클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신한다.   클라이언트는 캐시에 저장되어 있는 데이터 재활용   결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드받으면 된다.   매우 실용적인 해결책    Last-Modify &amp; If-Modified-Since 단점      1초 미만(0.x초)단위로 캐시 조정이 불가능하다.   날짜 기반의 로직을 사용한다.   데이터를 수정해 날짜가 다르지만, 같은 데이터를 수정해 데이터 결과가 똑같은 경우            test.txt 파일의 내용을 A→B로 수정했지만, 다시 B→ A로 수정한 경우           서버에서 별도의 캐시 로직을 관리하고 싶은 경우 ex) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우    ETag &amp; If-None-Match    서버에서 완전히 캐시를 컨트롤하고 싶은 경우 ETag 를 사용하면 된다.      ETag(Entity Tag)   캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다            ETag: \"v1.0\", ETag: \"a2jiodwjekjl3\"           데이터가 변경되면 이 이름을 바꾸어서 변경한다(Hash를 다시 생성).            ETag:\"aaaa\" → ETag:\"bbbb\"           단순하게 ETag만 보내서 같으면 유지하고 바르면 다시 받는다.     첫번째 요청         헤더에 ETag 를 작성해서 응답해준다.   클라이언트의 캐시에선 ETag 값을 저장한다.     두번째 요청         캐시시간이 초과되서 다시 요청을 해야하는 경우이다.   이때 If-None-Match를 요청 헤더에 작성해서 보낸다.         서버에서 데이터가 변경되지 않았을 경우 ETag는 동일하다. 그래서 If-None-Match는 실패다.   이 경우 서버에서는 304 Not Modified를 응답하며 이때 역시 HTTP Body는 없다.   브라우저 캐시에서는 응답 결과를 재사용하고 헤더 데이터를 갱신한다.    ETag &amp; If-None-Match 정리      ETag만 서버에 보내 동일하면 유지하고 다르면 다시 받는다.   캐시 제어 로직을 서버에서 관리한다.   클라이언트는 단순하게 이 값을 서버에 제공한다   캐시 매커니즘을 알 필요가 없다.   ex) 서버는 베타 오픈 기간 3일간 파일이 변경되어도 ETag를 동일하게 유지, ex) 애플리케이션 배포 주기에 맞춰서 ETag를 모두 갱신     3-3. 프록시 캐시   프록시 서버란?          프록시란, 클라이언트와 서버 사이에 대리로 통신을 수행하는 것을 가리켜 ‘프록시(Proxy)’, 그 중계 기능을 하는 서버를 프록시 서버라고 한다.   클라이언트, 혹은 반대로는 서버가 다른 네트워크에 간접적으로 접속 할 수 있기 때문에, 보안, 캐싱을 통한 성능, 트래픽 분산 등의 장점을 가진다.    프록시 캐시          한국에있는 클라이언트에서 별 이미지가 필요한상황인데 해당 이미지의 원서버가 미국에 있다고 가정해보자.   한국에서 미국까지 직접 접근하여 이미지를 가져오는데 0.5초가량 걸린다고하면 여러 클라이언트는 모두 0.5초 가량을 기다려야 해당 이미지를 받을 수 있다. 이것도 매우 긍정적인 상황이고 실제로는 더 많은 시간이 걸릴 수 있다.   하지만 우리는 유튜브와 같은 해외 사이트에서 위와 같은 불편한 없이 빠르게 영상을 시청할 수 있다. 그러한 불편함을 프록시 캐시가 해소해주기 때문이다.         한국에 프록시 캐시서버를 두고 한국의 클라이언트는 프록시 캐시서버를 통해 자료를 가져오도록 한다.        여러 사람이 찾은 자료일수록 이미 캐시에 등록되어있기에 빠른 속도로 자료를 가져올 수 있다.       클라이언트에서 사용되고 저장되는 캐시를 private 캐시라 하고 프록시 캐시서버의 캐시를 public 캐시라 한다.    캐시 무효화    클라이언트가 캐시를 적용하지 않아도 임의로 브라우저가 캐시를 적용하는 경우, 특정 페이지에서 캐시가 되면 안되는 정보 ex) 통장 잔고가 있다면 캐시 무효화를 통해 이를 무효화 할 수 있다.   Cache-Control: no-cache, no-store, must-revalidate Pragma: no-cache         오늘 느낀 점  어제 배운보다 더욱 더 공학스러운.. 내용이었다. 짧은 학습과정에 OSI 7 Layer 라던지 TCP/IP 프로토콜을 모두 이해하며 HTTP 메시지를 패킷으로 주고받으며 .. 등등 내용을 모두 이해하긴 불가능에 가깝다 생각한다.   일단 내가 설계하는 프로그램이 어떠한 구조로 데이터들을 주고받으며 그 주고받을때 쓰이는 통신규약은 어떠한 구조로 이뤄져 있는지 살펴본 느낌이다. 어제와 같은 맥락으로 공학이기 때문에 어떠한 한 학문이다 생각한다. 이러한 지식이 밑바탕 된 후 프로그램을 설계한다면 더욱더 효율적이고 잘 설계된 프로그래밍을 할 수 있을거란 생각은 든다.         내일 할 일     [GIT] 브랜치 관리와 고급기능  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.26.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 38. decompression",
        "excerpt":"  TOY 38. decompression  문제   한 변의 길이가 2의 제곱수인 정사각형의 흑백 이미지가 2차원 배열로 주어집니다. 각 좌표에는 0(백) 또는 1(흑)이 저장되어 있습니다. 이미지에 포함된 데이터가 모두 1이면 '1', 모두 0이면 '0' 한 글자로 압축할 수 있습니다. 그렇지 않은 경우, 이를 대문자 X로 표시하고 전체를 4등분하여 재귀적으로 압축합니다. 4등분한 영역의 순서는 좌측 상단, 우측 상단, 좌측 하단, 우측 하단입니다.   입력   인자 1 : image     배열을 요소로 갖는 배열   image.length, image[i].length는 1,024 이하   image[i]는 number 타입을 요소로 갖는 배열   image[i][j]는 세로로 i, 가로로 j인 지점의 정보를 의미   image[i][j]는 0 또는 1   출력      string 타입을 리턴해야 합니다.   주의사항      두 배열의 길이의 합은 1,000,000 이하입니다.   어떤 배열 arr의 k번째 요소는 arr[k-1]을 의미합니다.   입출력 예시   let image = [   [1, 0, 1, 1],   [0, 1, 1, 1],   [0, 0, 1, 1],   [0, 0, 0, 0], ]; let result = decompression(image); console.log(result); // --&gt; 'XX100110X1100​'  image = [   [0, 0, 0, 0, 1, 1, 0, 0],   [0, 0, 0, 0, 1, 1, 0, 0],   [0, 0, 0, 0, 1, 1, 1, 0],   [0, 0, 0, 0, 1, 1, 1, 0],   [1, 1, 1, 1, 0, 0, 0, 0],   [1, 1, 1, 1, 0, 0, 0, 0],   [1, 1, 1, 1, 1, 0, 1, 1],   [1, 1, 1, 1, 0, 1, 1, 1], ]; result = decompression(image); console.log(result); // --&gt; 'X0X101X10101X00X10011'   Advanced      decompression과 반대로 정사각형으로 표현된 데이터를 압축한 문자열을 입력받아 원래의 사각형을 리턴하는 함수 compression을 작성해 보세요. 레퍼런스 코드는 따로 제공하지 않습니다.   TOY 38. Solution  수도코드    문제풀이        Reference Code  /* const image = [   [1, 0, 1, 1],   [0, 1, 1, 1],   [0, 0, 1, 1],   [0, 0, 0, 0], ];  1. 전체 사각형(길이 4)에 0과 1이 섞여 있으므로 X가 첫 압축 정보가 됩니다.  2. 그 뒤에는 차례대로 좌측 상단, 우측 상단, 좌측 하단, 우측 하단의 사각형이 압축된 정보가 나와야 합니다.     =&gt; X[좌상][우상][좌하][우하] 3. 좌측 상단 사각형(길이 2)은 0과 1이 섞여 있으므로 X가 첫 압축 정보가 됩니다.     그리고 나머지 좌상, 우상, 좌하, 우하 사각형은 최소단위 이므로 차례대로 1, 0, 0, 1 을 그대로 적습니다.     =&gt; X1001    좌측 상단 사각형의 정보를 반영하면 전체 데이터의 압축 정보는 아래와 같습니다.     =&gt; XX1001[우상][좌하][우하] 4. 우측 상단 사각형(길이 2)은 전부 1이므로 1이 곧 압축 정보입니다.      =&gt; XX10011[좌하][우하] 5. 좌측 히단 사각형(길이 2)은 전부 0이므로 0이 곧 압축 정보입니다.      =&gt; XX100110[우하] 6. 우측 하단 사각형(길이 2)은 0과 1이 섞여 있으므로 X가 첫 압축 정보가 됩니다.     그리고 나머지 좌상, 우상, 좌하, 우하 사각형은 최소단위 이므로 차례대로 1, 1, 0, 0 을 그대로 적습니다.     =&gt; XX100110X1100 */ const decompression = function (image) {   // 재귀를 위한 보조 함수   // 파라미터는 차례대로 y좌표의 시작(Row Start), y좌표의 끝(Row End), x좌표의 시작(Col Start), x좌표의 끝(Col End)   const aux = (rs, re, cs, ce, image) =&gt; {     // base case     // 각 좌표에는 number 타입이 저장되어 있다.     if (rs === re) return String(image[rs][cs]);      // 좌상, 우상, 좌하, 우하로 구분한다.     const midRow = Math.floor((rs + re) / 2);     const midCol = Math.floor((cs + ce) / 2);     const leftUpper = aux(rs, midRow, cs, midCol, image);     const rightUpper = aux(rs, midRow, midCol + 1, ce, image);     const leftDown = aux(midRow + 1, re, cs, midCol, image);     const rightDown = aux(midRow + 1, re, midCol + 1, ce, image);      // 주어진 사각형 전체를 순회하고 나서 재귀를 하거나     // 4등분한 각 사각형을 각각 순회하고 나서 재귀를 하는 방식은 데이터를 중복 조회하게 된다.     // 재귀적으로 각 결과를 합치면서 계산하면 모든 좌표를 한 번씩만 검토하면 된다.     const result = leftUpper + rightUpper + leftDown + rightDown;     if (result === '1111') return '1';     else if (result === '0000') return '0';     else return 'X' + result;   };    return aux(0, image.length - 1, 0, image.length - 1, image); };   오늘 느낀 점   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정 하지만 해당 코드로도 시간복잡도 문제 때문인지 테스트케이스는 통과하지 못하는 현상이 나타난다.   내일 할 일     TOY 39. jobAllocation  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.27.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. Git Branch 2. 프로젝트 workflow",
        "excerpt":"  Today I Learnd  1. Git Branch   1-1. 브랜치(Branch)란?   브랜치란 독립적으로 어떤 작업을 진행하기 위한 개념이다.  개발을 하다 보면 한 페이지 안의 여러 기능을 따로 구현하기 위해, 코드를 여러 개로 복사해야 하는 일이 필연적으로 생긴다. 브랜치 기능을 활용하면, 코드를 통째로 복사한 후 원래 코드가 변경될 우려 없이 독립적으로 개발할 수 있다.   다시 말해, 각각의 브랜치는 다른 브랜치의 영향을 받지 않기 때문에, 여러 작업을 동시에 진행할 수 있다.   그러므로 브랜치가 갖는 기능의 장점은 다음과 같다.      한 소스코드에서 동시에 다양한 작업을 할 수 있게 해준다.   소스코드의 한 시점과 동일한 상태를 만들고, 브랜치를 넘나들며 작업을 수행할 수 있다.   각각의 브랜치에서 생긴 변화가 다른 브랜치에 영향을 주지 않고 독립적으로 코딩을 진행할 수 있다.      hotfix, release, develop, feature 등 다양한 개발과정 브랜치를 만들고 작업을 하다 보면, 다음 이미지와 비슷한 Git graph가 형성된다.           이렇게 나누어진 브랜치에서는 각자 독립적인 작업 영역(저장소) 안에서 마음대로 소스코드를 변경할 수 있다. 분리된 작업 영역(브랜치)에서 변경된 내용들은 다른 브랜치와 병합(Merge)함으로써 다시 새로운 하나의 브랜치로 병합 또한 가능하다.      독립적인 저장소에서 navigation bar, footer 소스코드 구현 후 master 브랜치와 병합하는 과정         여러 명이서 동시에 작업을 할 때에 다른 사람의 작업에 영향을 주거나 받지 않도록, 먼저 통합 브랜치에서 자신의 작업 전용 브랜치를 만든 후 각자의 브랜치에서 맡은 영역에 대한 작업을 진행한다.   작업이 끝난 브랜치는 통합 브랜치에 병합해서 변경 사항을 적용하는 과정을 반복하여 이를 통해 다른 브랜치의 작업에 영향을 받지 않고 독립적으로 특정 작업을 수행하고 그 결과를 하나로 모아 나가게 된다.   이렇게 작업을 진행하게 되면 ‘작업 단위’, 즉 브랜치로 그 작업의 내용들이 모두 기록되기 때문에 문제가 발생했을 때 원인이 되는 작업을 찾아내거나 그에 따른 대책을 세우기 쉬워진다.    브랜치 종류       통합 브랜치 (Integration Branch) : 배포될 소스 코드가 기록되는 브랜치.            Github Repository를 생성하게 되면 기본적으로 main 브랜치가 생성되어 있다. (기존 Repository의 경우 master로 되어 있는 경우도 있다.)       해당 프로젝트의 모든 기능이 정상적으로 작동하는 상태의 소스코드가 담겨 있다.           피처 브랜치 (Feature Branch) : 기능 추가, 버그 수정과 같이 단위 작업을 위한 브랜치.            통합 브랜치로부터 만들어내며, 피처 브랜치에서 하나의 작업이 완료가 되면 다시 통합 브랜치에 병합하는 방식으로 진행된다. 토픽 브랜치라고도 부르기도 한다.             1-2. 브렌치 주요 명령어      새로운 브랜치 생성            $ git branch 새로운 브랜치 이름           새로운 브랜치 생성 후 해당 브랜치로 전환            $ git switch -c 새로운 브랜치 이름       $ git checkout -b 새로운 브랜치 이름           브랜치 목록 확인            $ git branch           브랜치 목록과 각 브랜치의 최근 커밋 확인            $ git branch -v           브랜치 삭제            $ git branch -d 삭제할 브랜치 이름       $ git branch -D : 해당 명령어는 병합하지 않은 브랜치를 강제 삭제하는 방법.           브랜치 전환            $ git switch 브랜치 이름       $ git checkout 브랜치 이름           브랜치 병합 (master 브랜치로 dev 브랜치를 병합할 때 (master ← dev))            $ git checkout master ➡ $ git merge dev           로그에 모든 브랜치를 그래프로 표현            $ git log --branches --graph --decorate           아직 commit 하지 않은 작업을 스택에 임시로 저장            $ git stash            2. 프로젝트 workflow        Remote에 생성한 프로젝트 Repository를 Fork를 하여 각자의 Repository로 가져온다.   Local 영역에서 작업하기 위해 clone을 하여 Repository를 Local에 가져와 세팅한다.         Local 영역에서의 개발 진행은 main 브랜치가 아닌 dev 브랜치를 만들어서 해당 브랜치로 이동한다.         git checkout -b dev 명령어를 통해서 dev 브랜치를 생성&amp;이동. (git switch -c dev 명령어도 가능하다.)   나의 Origin Repository 에도 생성한 브랜치를 반영하기 위해 git push origin dev 명령어를 입력해 준다.         작업을 진행하기전 하나의 기능을 구현할 때는 ‘feature/기능이름’ 이라는 브랜치를 만들어서 작업하기로 정했다면, 로그인 기능을 구현하기 위해서 feature/login 이라는 브랜치를 생성 후 해당 브랜치에서 로그인 기능을 구현한다.   git checkout -b feature/login 명령어를 통해서 feature/login 브랜치를 생성&amp;이동. (git switch -c feature/login 명령어도 가능하다.)         feature/login 브랜치에서 로그인 기능이 완성 후, 소셜 로그인(oauth) 기능을 추가해 보고 싶다면 이미 완성된 로그인 코드에서 작업하기보다는, 새로운 브랜치를 하나 더 만들어서 기존 완성된 기능은 보존하며 작업하는게 코드를 유지보수하기 용이하다.   git checkout -b feature/login-ouath 명령어를 통해서 feature/login-ouath 브랜치를 생성&amp;이동한다.         소셜 로그인 기능까지 구현이 완료되었다면, 이 feature/login-oauth 브랜치에 있는 코드를 feature/login 브랜치로 병합(merge) 해준다.   먼저 병합의 주체가 될 브랜치(feature/login)로 git checkout -b feature/login 명령어로 이동을 한다.         git merge feature/login-oauth 명령어로 feature/login-oauth 브랜치를 병합해준다.        브랜치가 병합되기 전 feature/login 브랜치에 추가적인 커밋이 없으므로, 브랜치가 분기될 필요가 없다. 그러므로 자동적으로 fast-forward 방식으로 병합이 이뤄진다.              fast-forward 방식이란 별도의 커밋을 생성하지 않고 feature/login 브랜치가 가리키는 커밋을 feature/login-oauth 가 생성한 커밋으로 바꾸는 작업을 말한다.         만약, feature/login 브랜치에 별도의 커밋이 있었다면, fast-forward가 아닌 merge commit 방식으로 병합되었을 것이다. 이는 각 브랜치가 줄기처럼 분기한 후, 병합의 모양새를 가진다.                           로컬의 작업한 내용(Login기능)을 Remote Repository 에 업로드하기 위해서는 push를 해야 한다.   ` git push origin feature/login` 명령어로 Remote Repository로 업로드 한다.   feature/login 브랜치의 변경 사항을 다른 팀원들과 함께 코드 리뷰를 하고 dev 브랜치에 적용하고 싶다면, Github의 Pull Request 기능을 활용해 dev 브랜치로의 반영을 요청할 수 있다.    2-1. 전체 흐름 workflow     프로젝트를 진행하는 전체 흐름은 다음과 같다.      Local에서 새로운 브랜치를 생성한다.   Local 영역에서 작업이 끝나면 Remote Repository 로 Push 한다.   그리고 Project Upstream Repository에 반영(merge)될 수 있도록 Pull Request 한다.      만약 작업하던 중간에 Remote upstream 에 업데이트가 생긴다면 Local 로 pull 받아주어야 한다.         오늘 느낀 점  깃을 아직 2%도 쓰지 못했던거 같다. 개인 Repository만 활용한 수준….  이러한 협업을 할 때 진짜 깃의 실용성이 나타나는 듯 하다.   프로젝트 플로우는 더미 프로젝트로 직접 스터디 팀원들과 함께 실습하는 시간을 꼭 가져야겠다. 뭔가 협업이 실시간으로 이뤄지는거 같아서 신기하다.          내일 할 일     [배포] Amazon Web Service  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.27.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 39. jobAllocation",
        "excerpt":"  TOY 39. jobAllocation  문제   공장의 조립 기계가 고장이 나 수리를 위해 여러 명의 수리공들이 왔습니다. 조립 기계는 일자 형태로 길게 배치되어 있기 때문에 수리공들 또한 나란히 위치해서 수리를 진행해야 합니다. 기계의 각 부품은 한 명의 수리공만 수리할 수 있고, 이동을 최소화하기 위해 각 수리공들은 서로 연속해서 있는 부품만 수리해야 합니다. 각 부품을 수리하는 데 걸리는 작업량은 제각각이고, 수리 시간은 작업량에 비례합니다. 작업량과 수리공들의 수가 주어질 때, 전체 수리가 가장 빠르게 끝나는 시간을 리턴해야 합니다.   문제를 다르게 표현하면 아래와 같습니다.      자연수 배열을 n개의 연속 구간으로 나눌 때, 합이 가장 큰 구간의 합을 sum이라고 합시다. sum이 가장 작아지는 분배에서의 sum을 구해야 합니다.    입력   인자 1 : jobs     number 타입을 요소로 갖는 배열   jobs[i]는 1,000 이하의 양의 정수   jobs.length는 1,000 이하   인자 2 : workersNum     number 타입의 1,000 이하의 자연수   출력      number 타입을 리턴해야 합니다.   입출력 예시   let jobs = [1, 2, 3, 4, 5, 6, 7]; let workersNum = 3; let output = jobAllocation(jobs, workersNum); console.log(output); // --&gt; 11 (1, 2, 3, 4 / 5, 6 / 7)  jobs = [10, 2, 3, 4, 16, 10, 10]; workersNum = 4; output = jobAllocation(jobs, workersNum); console.log(output); // --&gt; 19 (10, 2, 3, 4 / 16 / 10 / 10  TOY 39. Solution  수도코드    문제풀이        Reference Code  // 총 5개의 작업을 3명이서 작업한다고 가정한다. // 첫번째 작업자는 최대 3개의 작업을 할 수 있다. // (jobs, workersNum)으로 표기하면, (jobs는 작업량이 아닌 작업의 인덱스만 표기한다고 한다) // 처음은 ([0, 1, 2, 3, 4], 3)인 상태이다. //  1) 첫번째 작업자가 1개의 작업을 하고 나머지 작업을 2명이 작업 //    =&gt; ([1, 2, 3, 4], 2) //  2) 첫번째 작업자가 2개의 작업을 하고 나머지 작업을 2명이 작업 //    =&gt; ([2, 3, 4], 2) //  3) 첫번째 작업자가 3개의 작업을 하고 나머지 작업을 2명이 작업 //    =&gt; ([3, 4], 2) // 아래 두 가지 경우를 통해, 문제가 중복되어 계산된다는 것을 알 수 있다. //  1-1) 첫번째 작업자가 1개의 작업을 하고, 그 다음 작업자가 2개의 작업을 한 경우 //    =&gt; ([3, 4], 1) //  2-1) 첫번째 작업자가 2개의 작업을 하고, 그 다음 작업자가 1개의 작업을 한 경우 //    =&gt; ([3, 4], 1) // 메모이제이션을 통해 중복 계산을 피한다.  const jobAllocation = function (jobs, wokersNum) {   // memo[i][j]는 i번째 worker가 j번째 job부터 작업한다고 할 때,   // 최대 작업량이 최소가 되는 분배에서의 최대 작업량을 저장한다.   // i, j 모두 인덱스이므로 0부터 시작   const memo = [];   for (let i = 0; i &lt; wokersNum; i++) memo.push(Array(jobs.length).fill(-1));   // 마지막 작업자는 남아있는 모든 작업을 다 해야하므로 쉽게 계산이 가능하다.   // 마지막 작업자는 최대 나머지 작업자의 수만큼을 제외한 일만 할 수 있다.   let workload = 0;   for (let i = jobs.length - 1; i &gt;= wokersNum - 1; i--) {     workload = workload + jobs[i];     memo[wokersNum - 1][i] = workload;   }    const aux = (workerIdx, jobIdx, jobs, left) =&gt; {     // 이미 계산한 적이 있는 경우, 다시 풀지 않는다     // 마지막 작업자의 작업량을 전부 계산했으므로, 탈출 조건을 굳이 작성하지 않아도 된다.     if (memo[workerIdx][jobIdx] !== -1) return memo[workerIdx][jobIdx];      let workload = 0;     let min = Number.MAX_SAFE_INTEGER;     for (let i = jobIdx; i &lt; jobs.length - left; i++) {       workload = workload + jobs[i];       // 가장 많이 일하는 사람의 작업량을 구한다.       const hardest = Math.max(         workload,         aux(workerIdx + 1, i + 1, jobs, left - 1)       );       // 그 작업량이 최소화되는 분배에서 최대 작업량을 구한다.       min = Math.min(min, hardest);     }     memo[workerIdx][jobIdx] = min;     return min;   };    return aux(0, 0, jobs, wokersNum - 1); };   오늘 느낀 점   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   내일 할 일     TOY 40. longestPalindrome  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.28.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 40. longestPalindrome",
        "excerpt":"  TOY 40. longestPalindrome  문제   문자열을 입력받아 부분 문자열 중 가장 긴 (palindrome) 의 길이를 리턴해야 합니다.      palindrome: 데이터를 앞에서 뒤로 또는 뒤에서 앞으로 조회한 결과가 동일한 경우   입력   인자 1 : str     string 타입의 공백이 있는 알파벳 소문자 문자열   출력      number 타입을 리턴해야 합니다.   주의사항      문자열 str의 부분 문자열은 자기 자신을 포함합니다.   공백도 회문에 포함될 수 있습니다.   입출력 예시   let str = 'My dad is a racecar athlete'; let result = longestPalindrome(str); console.log(result); // --&gt; 11 ('a racecar a')  str = ' dad '; result = longestPalindrome(str); console.log(result); // --&gt; 5 (' dad ')   Advanced      부분 문자열 중 가장 긴 회문을 계산하는 효율적인 알고리즘(O(N^2))이 존재합니다. 쉽지 않기 때문에 바로 레퍼런스 코드를 보고 이해하는 데 집중하시기 바랍니다.   TOY 40. Solution  수도코드    문제풀이        Reference Code  // naive solution: O(N^3) // function longestPalindrome(str) { //   if (str.length &lt;= 1) return str.length;  //   const checkPalindrome = function (str) { //     const half = parseInt(str.length / 2); //     for (let i = 0; i &lt; half; i++) { //       if (str[i] !== str[str.length - 1 - i]) return false; //     } //     return true; //   };  //   // 길이가 긴 순서대로 부분 문자열을 만들어 검사한다. //   for (let len = str.length; len &gt;= 1; len--) { //     // 길이 len인 부분 문자열들의 시작 인덱스를 구한다. //     // 예. 전체 길이가 100이고, 부분 문자열의 길이가 10인 경우, //     // 부분 문자열 (시작인덱스 ~ 마지막 인덱스) //     //  90 ~ 99, 89 ~ 98, 88 ~ 97, ..., 1 ~ 10, 0 ~ 9 //     for (let startIdx = str.length - len; startIdx &gt;= 0; startIdx--) { //       // slice의 특성을 고려한 마지막 인덱스 + 1 을 저장 //       const endIdx = startIdx + len; //       const subStr = str.substring(startIdx, endIdx); //       const result = checkPalindrome(subStr); //       if (result === true) return len; //     } //   } // }  function longestPalindrome(str) {   if (str.length &lt; 2) return str.length;    const LENGTH = str.length;   const isPalindrome = Array(LENGTH)     .fill(false)     .map((_) =&gt; Array(LENGTH).fill(false));   // 언더바는 잘못된 코드가 아닙니다.   // 언더바는 어떤 매개변수는 전달되어도 무시하겠다는 의미로 사용됩니다.    let maxLen = 1;   // 길이가 1인 회문   for (let i = 0; i &lt; LENGTH; i++) isPalindrome[i][i] = true;    // 길이가 2인 회문   for (let i = 0; i &lt; LENGTH - 1; i++) {     if (str[i] === str[i + 1]) {       isPalindrome[i][i + 1] = true;       maxLen = 2;     }   }    // 길이가 3 이상인 회문   for (let len = 3; len &lt;= LENGTH; len++) {     for (let startIdx = 0; startIdx &lt;= LENGTH - len; startIdx++) {       const endIdx = startIdx + len - 1;       if (         isPalindrome[startIdx + 1][endIdx - 1] === true &amp;&amp;         str[startIdx] === str[endIdx]       ) {         isPalindrome[startIdx][endIdx] = true;         maxLen = len;       }     }   }    return maxLen; }   오늘 느낀 점   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   내일 할 일     TOY 41. countIslands  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.10.29.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. Amazon Web Service 2. AWS 배포 실습",
        "excerpt":"  Today I Learnd  1. Amazon Web Service      웹 서비스 배포를 위한 방법으로 가상화 기술(가상의 컴퓨터를 대여)을 사용하는 클라우드 컴퓨팅을 사용할 수 있다.   클라우드 컴퓨팅 서비스 중 가장 유명한 것이 Amazon Web Service(AWS)이다.     1-1. Cloud Computing                 클라우드 등장 이전의 방식은 흔히 말하는 전산실 등에 컴퓨터를 배치하고 인터넷을 연결하여 서비스를 제공했다.                    하지만 이러한 경우 서버가 요청에 대한 수용 능력이 한계에 도달한다면 같은 공간에 서버를 추가하거나 서버의 성능을 업그레이드하는 방식을 채택해야한다.       이러한 방식의 문제는 몇가지 문제점을 가지고 있다.                     주기적인 관리가 필요 : 흔히 말하는 서버실에는 종종 고장이 나거나 인터넷과 연결이 되지 않는 얘기치 못한 문제가 생기기도 한다.    이런 상황이 발생한다면 규모가 작은 서버라도 이를 해결하기 위한 인력 및 비용이 불가피하게 투입되어야 문제 해결이 가능하다.                        공간의 한계 : 둘째로 발생하는 문제점은 물리적인 공간의 문제점이다. 서버실이라는 공간에 컴퓨터를 배치해 두고 발생하는 트래픽에따라 서버를 추가하는 방식으로 서버의 수용 능력을 향상해야하지만, 트래픽이 매우 많아지는 경우 물리적인 공간에 제약이 생길수가 있다.                   이러한 물리적인 문제점들을 극복하기 위하여 나온 개념이 서버의 자원과 공간, 및 네트워크 환경을 외부로 부터 제공을 빌려 받아 사용하는 클라우드 컴퓨팅이다.   1-2. 클라우드의 등장           앞서 말한 서버의 자원과 공간, 및 네트워크 환경을 빌려주는 곳을 데이터 센터라 일컫는다. (이러한 환경을 온프레미스라 부르며, 반대 개념인 오프프레미스는 위에서 말한 서버실같은 환경을 말한다.)              클라우드 컴퓨팅은 앞서 설명한 데이터센터같은  온프레미스 환경과 비슷한 역할을 하지만, 물리적인 컴퓨터가 아닌 가상 컴퓨터를 대여한다는 점이 다르다.   온프레미스 환경과 다르게 가상화(Virtualization) 기술을 가진 클라우딩 컴퓨터가 갖는 이점은 다음과 같다.            사용이 필요할 때마다 컴퓨팅 능력을 유연하게 조절할 수 있다.       이용기간에 따라 고정적인 비용이 들어가는 온프레미스(정액제)와는 달리 사용한 만큼의 요금(정량제)만 지불이 가능하다.           1-3. 클라우드의 단점      앞서 말한 장점이 뚜렷한 클라우드 컴퓨팅이지만, 이러한 환경에도 단점은 존재한다.        클라우드 제공자(AWS,Google 등..)의 환경에 문제가 있을 경우 해당 서비스 사용자들이 모두 영향을 받는다.              클라우드 서비스에 100% 의존하는 경우, 운영 환경 자체가 클라우드 제공자에게 종속되어 버리므로 클라우드 서비스에 문제가 생기면 내가 배포하고 관리하는 환경에도 영향이 미친다.       1-4. 클라우드의 목표           이러한 클라우드의 목표는 모든 것을 서비스화하는 것을 목표로 한다.              대표적인 클라우드 서비스의 형태는 SaaS, IaaS, PaaS 세 가지이다.              SaaS (Software as a Service)                    클라우드 제공자가 당장 사용 가능한 소프트웨어를 제공하는 경우 대부분 SaaS에 해당한다.           드롭박스, 구글드라이브, 넷플릭스 등                       PaaS (Platform as a Service)                    클라우드 제공자가 데이터베이스, 개발 플랫폼까지 제공하는 경우 대부분 PaaS에 해당한다.           Oracle Cloud 플랫폼 등                       IaaS (Infrastructure as a Service)                    클라우드 제공자가 가상 컴퓨터까지 제공하는 경우 대부분 IaaS에 해당한다.           AWS 등                           2. AWS 배포 실습      클라우드 컴퓨팅의 개념에 대해서는 학습했으니, 실제 웹 애플리케이션을 배포하는 과정을 간단히 실습해보자.     2-1. 백엔드 배포            AWS에서 서버 배포시 다음과 같은 과정이 필요하다.            EC2 콘솔을 통해 EC2 인스턴스를 생성해야 한다.       간단한 서버 애플리케이션을 생성하고 EC2 인스턴스에 코드를 배포해야 한다.       서버를 실행시키고 브라우저에서 서버에 접속할 수 있어야 한다.           EC2 인스턴스 생성           AWS 메뉴에서 EC2 서비스를 검색하고 접속하여 인스턴스 시작 버튼을 클릭하여 인스턴스 생성을 시작하자.                   용도에 맞게 AMI를 선택하는 과정이다. 호환성 이슈 및 프리티어 지원여부를 고려하여 ubuntu 18.04 버전을 선택해주자.                   인스턴스 유형을 선택하는 과정이다. 생성하는 인스턴스의 CPU, RAM, 용량에 대한 선택이 가능하지만.. 프리티어가 지원되는 유형을 선택하자. (램 1GB실화..??)                   검토 및 시작 버튼을 클릭하면 이제 인스턴스를 원격으로 제어하기 위해서 보안키를 선택하거나(기존의 키가 있는 경우) 새로 생성하라는 안내화면이 나온다.              키 페어 다운로드를 해준뒤 내 로컬 PC환경에 보관해주자.       해당 과정으로 생성되는 키로 인스턴스를 SSH* 연결을 통해 원격으로 제어할 수 있다.              SSH 프로토콜이란?         SSH는 서로 다른 PC가 인터넷과 같은 Public Network를 통해 통신을 할 때 보안상 안전하게 통신을 하기 위한 통신 규약이다.         주고받는 데이터를 암호화해서 해당 키 페어를 가지지 않은 사람은 통신되는 데이터를 알아볼 수 없기 때문에 보안상 안전한 통신 방법이다.                 인스턴스 생성 마지막 단계에서 다운로드 한 파일은 SSH 통신을 위한 키 페어 중 프라이빗 키가 기록된 파일이다. (.pem 확장자를 가지고 있다.)       해당 키 페어 파일은 EC2 인스턴스에 원격으로 연결을 할때 사용하는 암호가 담긴 파일이므로 외부에 노출안되게 관리에 유념해야한다.            이제 해당 키를 이용하여 SSH 원격 연결로 생성한 인스턴스로 들어가 보자.  생성한 인스턴스의 아이디를 누르면 인스턴스 상세정보를 볼 수 있다.              그 뒤 연결 탭을 누르면 인스턴스에 접속하는 옵션들을 선택할 수 있게된다.              우린 SSH 방식으로 연결할 예정이므로 SSH 클라이언트 탭을 눌러 준다.                   SSH프로토콜을 이용하면 로컬 터미널 환경으로 클라우드 컴퓨팅 인스턴스와 연결이 가능하다.  다만, 다운로드했던 키 페어 파일(.pem)이 누구나 접근할 수 있는 권한이 부여되어 있다면 인스턴스는 연결을 거부한다.       그러므로 다운로드 했던 키 페어 파일이 위치의 디렉토리 위치에서 터미널 환경으로 해당 키 페어 파일의 권한을 수정해준다.              키 페어 파일(.pem)의 권한을 수정하지 않은 경우, 권한이 너무 open 되어 있다는 경고 메시지와 함께 접속이 거절된다.            이제 키 페어를 알맞은 권한으로 사용하여 SSH 프로토콜 환경으로 EC2 인스턴스로 원격 접속이 가능하게 모두 설정이 완료되었다.              위 명령어를 통해 내 로컬 디렉토리(키페어가 들어있는 디렉토리)에서 터미널 환경에서 인스턴스로 접속을 시도하면 아래와 같은 인스턴스 원격 접속 화면을 볼 수 있다.              VSCode를 이용한 SSH 원격 접속           위와 같이 터미널 환경으로도 인스턴스에 접속하여 충분히 조작이 가능하지만 불편하다.       아무래도 GUI를 통한 사용자에게 편한 조작방식과는 거리가먼 명령어로만 작동하는 방식이기때문이다.            VSCode 확장 툴인 Remote Development를 이용하면, 편리하게 SSH 원격 접속이 가능하다.              위의 두 확장 툴을 받아주면, VSCode 좌측 툴에 다음과 같은 원격 탐색기 아이콘이 생성된 걸 확인할 수 있다.                  이제 SSH Configure 로 가서 원격접속을 위한 설정을 해주자                     Host : 원하는 아무 Host 명을 입력해주자, VSCode에서 구분하기 위한 이름이다.       HostName : EC2  퍼블릭 DNS, 원격 접속할 EC2 인스턴스의 주소이다.       User : 서버 접속 계정명을 입력해주자.       IdentityFile : .pem 키 페어가 담긴 디렉토리 위치를 입력해주자.                올바르게 SSH 환경 설정이 완료되면 VSCode에서 EC2 인스턴스로 원격 접속이 가능하게 된다.              로컬 터미널 환경보다는 훨씬 편하게 폴더 및 파일 수정을 할 수 있게 된다.       EC2 인스턴스 상에서 서버 실행      이제 생성된 EC2 인스턴스는 ubuntu 18.04 운영체제가 탑제된 텅텅 빈 가상 PC이다.  해당 인스턴스를 서버가 구동될 수 있는 개발환경을 구성하여 인스턴스에서 서버를 구동시키는 방식은 로컬 개발환경을 구축하는 방식과 동일하므로 생략하도록 하겠다.   Github Repository에서 가져올 서버환경을 간략히 설명하자면, HTTP 방식으로 80번 포트를 사용하는 서버이며, 각 엔드포인트로의 요청은 다음과 같이 처리된다.                     /  : GET 요청           app.get('/', (req, res) =&gt; {     res.status(201).send('Hello World'); });                   응답코드 201번으로 ‘Hello World’ 응답 메세지를 보내주는 간단한 구조이다.                        /signin : POST 요청           app.post('/signin', (req, res) =&gt; {     const { username, password } = req.body;     if (username === '김코딩' &amp;&amp; password === '1234') {         const accessToken = jwt.sign({ username }, 'secretKey', { expiresIn: '1days' });         res.status(201).send(accessToken);     } else {         res.status(401).send('Login Failed');     } });                  req.body에 담긴 username, password가 각각 ‘김코딩’, ‘1234’인 경우 accessToken을 생성하여 (유효기간 1일) 응답코드에 토큰을 담아 전달해주는 구조이다.                        /status : GET 요청           app.get('/status', authToken, (req, res) =&gt; {     if (req.username) { // jwt 토큰이 존재할 경우 데이터베이스 연결 여부 조회         db.query('use test', (err) =&gt; {             if (err) {                 return res.status(200).send({                     isLogin: true,                     isConnectedToDatabase: false                 });             }             return res.status(200).send({                 isLogin: true,                 isConnectedToDatabase: true             });         });     } });                   로그인에 성공시 DB 연결 여부에따라 다른 결과를 보여주는 마지막 엔드포인트이다.                   위 accessToken은 로컬 스토리지에 담기며, 인증서 없이 80번 포트에서 HTTP 방식으로 서버가 구동되는 구조를 확인하였다.   Security Group           이제 서버를 VSCode SSH 원격 접속환경에서 실행시켜주면 80번 포트로 작동하는 걸 확인 할 수 있다.              AWS EC2 인스턴스로 접속하여 부여된 퍼블릭 IPv4 DNS 주소로 접근을 하면 다음과 같은 도메인 접속 불가 에러코드를 확인 할 수 있다.              아직 인스턴스 외부 접근을 위한 보안 그룹 설정을 하지 않았기 때문이다.            보안 그룹(Security Group)은 우리가 AWS에서 임대한  인스턴스의 가상 방화벽이다.       인스턴스로 들어가는 트래픽을 제어하는 인바운드 설정과 인스턴스에서 나가는 트래픽을 제어하는 아웃바운드 설정 두가지 보안그룹 설정이 존재한다.            아웃바운드의 default값은 EC2 인스턴스에서 외부로 나가는 모든 트래픽이 허용되므로, 우리는 외부에서 접근하는 인바운드 설정만 해주면된다.       현재 인스턴스의 보안그룹으로 들어가주자.              인바운드/ 인바운드 규칙 편집을 클릭 후 다음과 같이 80번 포트의 인바운드 규칙을 설정해준다.              이제 인스턴스에서 서버가 켜진 상태에서 다시 퍼블릭 IPv4 DNS 주소로 접속시 ‘Hello World’ 문구를 확인 할 수 있다.              서버 백그라운드 실행           SSH 프로세스는 강제 종료 시(로컬 환경 터미널 종료시), EC2 상의 프로세스도 같이 종료된다.       그러므로 우리는 SSH 프로세스가 종료되더라도 서버가 EC2 백그라운드에서 작동하게끔 프로그램을 실행해줘야 한다.            Linux/Unix 계열 운영체제에서는 &amp;라는 키워드를 붙여서 프로그램 실행시 백그라운드 실행으로 만들어줄 수 있다.       $ node index.js &amp;           위 명령어를 사용하여 서버를 작동시켜주자              반대로 서버를 종료하고 싶다면 kill 명령을 통해 백그라운드에서 실행중인 프로세스를 종료할 수도 있다.           2-2. 프론트엔드 배포      프론트엔드는 S3 버킷을 이용하여 클라이언트가 담긴 정적 웹 사이트를 호스팅 해주어야 한다.     S3 버킷 생성                 이제 AWS 홈페이지의 S3 버킷으로 접속 후, 버킷만들기로 버킷을 생성해 주자.              버킷이름을 설정해줘야한다.  다만, 한 리전에는 하나의 버킷이름만 생성이 가능하다. 중복이 불가능하므로 고유한 버킷명을 적어주고 별다른 설정없이 인스턴스와 같은 리전에서 버킷을 생성해 주자.            이제 만들어진 버킷의 이름을 클릭하여 속성 메뉴로 진입 후, 정적 웹 사이트 호스팅 메뉴로 들어가 아래와 같이 수정해 준다.              정적 웹사이트 호스팅을 활성화를 버튼을 눌러주면, 인덱스 문서등 여러 옵션 선택창이 나온다.       해당 버킷 웹 사이트 주소에 처음 접속했을 때 보일 기본 페이지를 지정해주는 옵션과 혹시 모를 오류 발생 시 메인 페이지를 반환하기 위해서 index.html을 기입해 준다.            이제 클라이언트를 담을 S3 버킷이 완성되었다. 버킷 속성 메뉴 진입 후 버킷 웹 사이트 엔드포인트로 접속하면 이제 우리가 만든 버킷 영역으로 접속이 가능하다.       –       이제 버킷에 정적 웹 페이지 파일을 아직 업로드 하고, 퍼블릭 액세스 설정 변경과 정책 생성을 해주면 클라이언트가 웹 상에 호스팅되게 된다.       버킷에 웹 페이지 파일 업로드      우선 im-sprint-practice-deploy/client/.env.example 파일을 VSCode SSH 환경으로 접속하여 서버의 주소(퍼블릭 IPv4 DNS 주소)로 환경변수 설정을해준다.        환경 변수 관련 설정이 완료 후, client 디렉토리에서 터미널 npm run build 명령어를 통해 빌드 파일을 생성해주자.                    빌드가 성공하면, 위와 같은 폴더가 생성된다.       이 빌드된 파일들을 버킷에 올려주어야 한다.            이전에 생성한 S3 버킷의 ID 클릭 후 객체 메뉴의 업로드를 선택해 준다.              위와 같은 화면이 나오면 방금 빌드된 폴더를 업로드 해준다.       EC2 인스턴스에서 빌드된 파일을 로컬환경으로 가져오려면 VSCode SSH 연결이 되어있다면 이동할 디렉토리 우클릭 후 다운로드하여 로컬환경으로 가져올 수 있다.             이제 버킷에 웹 페이지 파일까지 모두 완료되었으니, 버킷으로 접근 권한 설정과 버킷 정책 생성을 해주어야 한다.   버킷 권한 설정           이제 버킷 메뉴중 권한 메뉴로 들어 간 뒤, 퍼블릭 액세스 차단(버킷 설정) 편집을 해 준다.              모든 퍼블릭 액세스 차단 옵션의 체크 박스를 해제해 준다.       그리고 이제 버킷 정책을 설정해 주어야 한다.  버킷 정책 편집 버튼으로 들어 간 뒤 버킷 ARN을 복사 후 버킷 정책 생성기로 들어간다.              정책 생성기에 접속 후 아래 사진과 같이 정책을 생성해 준다.              위에서 부터 차례대로 S3 Bucket Policy 선택 후 Effect는 Allow로 기본으로 체크되어 있다.       Principal은 *을 입력 해 준 뒤, Actions에서는 GetObject1가지 액션만 선택한다.       마지막으로 Amazon Resource Name (ARN)은 미리 복사한 내 버킷 ARN을 복사 후 /*를 뒤에 붙여서 입력해 준뒤 정책을 생성해준다.            생성된 정책을 내 버킷 정책에 붙여넣기로 넣어 준 뒤,              EC2 인스턴스에서 서버가 접속중인 상태에서 버킷 엔드포인트로 접속해 주면 다음과 같은 화면을 확인 할 수 있다.               2-3. 데이터베이스 연결      MySQL 데이터베이스 엔진을 사용하는 DB 인스턴스를 생성한 뒤 EC2 인스턴스와 해당 DB를 연결하는 과정으로 완성된다.   RDS 인스턴스 생성           AWS RDS 메뉴로 진입 후 데이터베이스를 생성해주자.              엔진옵션은 MySQL을 선택 후 프리티어로 선택한다.              자격증명 옵션에서는 마스터 사용자 이름 설정과 8자리 이상의 사용자 비밀번호를 설정해 주자. (마스터 사용자 이름과 비밀번호는 나중에 데이터베이스를 연결할 때 쓰이는 정보이다.)              연결 옵션에서는 퍼블릭 액세스를 “예”로 변경해 준 뒤,              추가구성으로 가서 포트번호를 13306번으로 변경해 주었다. (흔히 사용되는 3306번 포트 대신, 포트번호 노출을 방지하려는 목적으로 13306번 포트를 사용하였다.)              마지막으로 서버에서 연결된 DB 초기값이 test 이름이므로 초기 데이터베이스 명칭을 test로 주었다. (생략 후 MySQL 접속 후 CREATE DATABASE test를 실행해 주어도 된다.)            위 과정을 마치면 DB 생성이 진행된다.       생성이 모두 완료되는데 시간은 2~30분정도 소요되는듯 하다.            생성이 완료되면 DB 인스턴스 아이디 클릭 후 연결&amp;보안의 DB 엔드포인트 주소를 복사해준다.              MySQL이 설치된 환경에서 mysql -u [마스터 이름] --host [엔드포인트 주소] -P 13306(포트번호) -p 명령어를 입력 후 마스터 사용자 이름과 비밀번호를 입력하면 DB 인스턴스로 접속이 가능하다.              초기 데이터베이스인 test가 확인되면 완료이다.       RDS 인스턴스 연결           EC2 인스턴스에서 실행되고 있는 서버는, 그 자체로는 작동하고 있지만, 아직 데이터베이스에 연결은 안되어 있다.       서버의 환경 설정을 통해서 위에서 생성한 RDS 인스턴스에 접속 하면 클라우드 데이터베이스 test DB를 사용할 수 있다.            im-sprint-practice-deploy/server/db/connection.js 파일을 확인 하면 아래와 같은 코드를 확인 할 수 있다.         const mysql = require('mysql');   const dotenv = require('dotenv');   dotenv.config();    const con = mysql.createConnection({       host: process.env.DATABASE_HOST,       user: process.env.DATABASE_USER,       password: process.env.DATABASE_PASSWORD,       port: process.env.DATABASE_PORT   });    con.connect((err) =&gt; {       if (err) {           con.end();       }   });    module.exports = con;           다시 VSCode SSH 로 접속하여 im-sprint-practice-deploy/server/.env.example를 알맞게 수정해 준 뒤 서버를 재시작하자. (host는 생성한 DB 인스턴스의 엔드포인트 주소를 넣어준다.)        서버를 다시 구동한 뒤, 클라이언트에서 로그인 하면 다음과 같은 화면을 확인 할 수 있다.                   오늘 느낀 점          배포…생각보다 어렵다. 아직 AWS에서 무료로 제공하는 도메인에 호스팅만 해보았다.       우선 스프린트 내용대로 잘 따라는 해서 문제는 딱히 없었다만, 그 과정을 편하게 하기 위해서 VSCode에서 지원하는 SSH 원격 접속방식을 선택했다.       확실히 터미널에서만 조작하는 방식보다 마우스를 이용해서 편리하게 조작할 수 있는 GUI 환경이 사람이 쓰기엔 훨씬 편한건 어쩔 수 없는듯하다.       원하는 도메인을 구매 후 배포하는 것과 HTTPS 인증방식을 사용하는 배포방식은 나중에 다시 해봐야겠다.              내일 할 일     [배포] Docker  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.10.29.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 41. countIslands",
        "excerpt":"  TOY 41. countIslands  문제   세로와 가로의 길이가 각각 R, M인 2차원 R X M 배열 grid가 주어졌을 때, '1'은 땅을 의미하고 '0' 은 물을 의미합니다. 주어진 2차원 배열에 존재하는 섬의 개수를 리턴해야 합니다.   입력   인자 1 : grid     세로와 가로의 길이가 각각 R, M인 2차원 배열   arr.length는 R   arr[i].length는 M   arr[i][j]는 0 또는 1   출력      number 타입을 리턴해야 합니다.   주의사항      섬이란 물로 둘러싸여 있는 땅을 말합니다.   가로 혹은 세로로 땅이 연결되어 있는 경우 하나의 섬으로 간주합니다.   2차원 배열의 범위 밖은 물로 둘러싸여 있다고 가정합니다.   입출력 예시   let grid = [   ['0', '1', '1', '1'],   ['0', '1', '1', '1'],   ['1', '1', '0', '0'], ]; let result = countIslands(grid); console.log(result); // --&gt; 1  grid = [   ['0', '1', '1', '1', '0'],   ['0', '1', '0', '0', '0'],   ['0', '0', '0', '1', '0'],   ['1', '1', '0', '1', '0'],   ['1', '1', '0', '1', '0'], ]; result = countIslands(grid); console.log(result); // --&gt; 3  TOY 41. Solution  수도코드    문제풀이        Reference Code  const countIslands = function (grid) {   // dfs solution   const HEIGHT = grid.length;   const WIDTH = HEIGHT &amp;&amp; grid[0].length;   let count = 0;    for (let row = 0; row &lt; HEIGHT; row++) {     for (let col = 0; col &lt; WIDTH; col++) {       if (grid[row][col] === '0') continue;       count++;       searchIsland(row, col);     }   }    function searchIsland(row, col) {     if (row &lt; 0 || col &lt; 0 || row &gt;= HEIGHT || col &gt;= WIDTH) return;     if (grid[row][col] === '0') return;      grid[row][col] = '0';     searchIsland(row - 1, col);     searchIsland(row + 1, col);     searchIsland(row, col - 1);     searchIsland(row, col + 1);   }    return count; };   오늘 느낀 점   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   “이정도는 직접 풀어봤어야했는데..” 생각이 들었다. 최근 바쁜 일정때문에 알고리즘 자체를 소홀히 하고있다. 정규일정이 끝난 뒤 다시 TOY 정주행 해야할듯하다.   내일 할 일     TOY 42. gossipProtocol2  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.01.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 42. gossipProtocol2",
        "excerpt":"  TOY 42. gossipProtocol2  문제   세로와 가로의 길이가 모두 N인 마을지도가 배열로 주어졌을 때, '1'은 주민이 있는 집을 의미하고 '0'은 주민이 없는 땅을 의미합니다. 이 마을의 비상연락망 시스템을 구축하려고 합니다. 최초에 정보를 알고 있는 주민의 집들이 '2'로 표시됩니다. 이 중에 일부를 비상 상황 시 비상 연락 요원으로 임명하려고 합니다. 각 담당자들은 정보를 상하좌우 한 칸 바로 옆에 있는 집으로 정보를 전달하기 시작합니다. 정보를 전달받은 주민 역시 한 시간에 상하좌우 한 칸 바로 옆에 있는 집으로 해당 정보를 전달합니다. 비상 연락 요원으로 지정할 수 있는 최대수(num)가 주어질 때, 마을 전체로 정보가 전달되는 데 가장 빠른 시간을 리턴해야 합니다.   입력   인자 1 : village     string 타입을 요소로 갖는 배열   village.length와 village[i].length는 50 이하   village[i]는 string 타입   village[i][j]는 세로로 i, 가로로 j인 지점의 정보를 의미   village[i][j]는 '0', '1' 또는 '2'   인자 2: num     number 타입의 10 이하의 양의 정수   비상 연락 요원으로 지정가능한 최대 수   출력      number 타입을 리턴해야 합니다.   주의사항      모든 집이 전부 연결되어 있는 것은 아닙니다.   요원으로 선택되지 않아도 정보를 전달받은 이상 똑같은 규칙을 따라 정보를 전달해야 합니다.   최초에 정보를 알고 있는 주민('2')의 수는 10 이하입니다.   village를 그래프로 구현하는 함수가 주어집니다.   입출력 예시   let village = [   '0022', // 첫 번째 줄   '0020',   '0020',   '0220', ]; let num = 1; let output = gossipProtocol2(village, num); console.log(output); // --&gt; 0 (이미 모든 주민이 정보를 알고 있는 상태)  village = [   '1001212',   '1201011',   '1102001',   '2111102',   '0012111',   '1111101',   '2121102', ]; num = 5; output = gossipProtocol2(village, num); console.log(output); // --&gt; 3   TOY 42. Solution  수도코드    문제풀이        Reference Code  const createMatrix = (village) =&gt; {   const matrix = [];   village.forEach((line) =&gt; {     const row = [];     for (let i = 0; i &lt; line.length; i++) row.push(line[i]);     matrix.push(row);   });   return matrix; };  const getAgents = (village) =&gt; {   const agents = [];   for (let row = 0; row &lt; village.length; row++) {     for (let col = 0; col &lt; village.length; col++) {       if (village[row][col] === '2') agents.push([row, col]);     }   }   return agents; };  const gossipProtocol2 = function (village, num) {   // bfs 구현을 위해 큐를 선언한다.   const N = village.length;   const MOVES = [     [-1, 0], // UP     [1, 0], // DOWN     [0, 1], // RIGHT     [0, -1], // LEFT   ];   const MAX_SIZE = N * N;   const isValid = (row, col) =&gt; row &gt;= 0 &amp;&amp; row &lt; N &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; N;   let front, rear;   const isEmpty = (queue) =&gt; front === rear;   const enQueue = (queue, pos) =&gt; {     // 실행 중에 큐가 가득차지는 않기 때문에 별도의 조건문을 작성할 필요가 없다.     queue[rear++] = pos;   };   const deQueue = (queue) =&gt; {     const pos = queue[front++];     return pos;   };    // num개의 시작점이 주어졌을 때, bfs 탐색을 하는 함수   const bfs = (sources) =&gt; {     const matrix = createMatrix(village);     const queue = Array(MAX_SIZE);     front = 0;     rear = 0;      sources.forEach((src) =&gt; {       const [row, col] = src;       matrix[row][col] = 0;       enQueue(queue, src);     });      let cnt = 0;     while (isEmpty(queue) === false) {       const [row, col] = deQueue(queue);       cnt = matrix[row][col];        MOVES.forEach((move) =&gt; {         const [rDiff, cDiff] = move;         const nextRow = row + rDiff;         const nextCol = col + cDiff;         if (isValid(nextRow, nextCol) &amp;&amp; matrix[nextRow][nextCol] === '1') {           enQueue(queue, [nextRow, nextCol]);           matrix[nextRow][nextCol] = matrix[row][col] + 1;         }       });     }      for (let row = 0; row &lt; matrix.length; row++) {       for (let col = 0; col &lt; matrix.length; col++) {         // 정보가 다 전달되지 않을 수 있다.         if (matrix[row][col] === '1') return Number.MAX_SAFE_INTEGER;       }     }     return cnt;   };    // 정보를 알고 있는 주민들을 따로 저장한다.   const agents = getAgents(village);   // 최대 num명의 요원을 선정하고, 각각에 대해서 bfs를 수행한다.   // 가장 작은 값을 리턴한다.    // size개 중에서 num개를 선택하는 모든 조합을 리턴하는 함수   // 인덱스를 리턴한다.   const getCombinations = (idx, size, num, result) =&gt; {     // base case1: 선택해야 개수가 남아있는 개수 이상일 경우     // =&gt; 남아있는 모든 걸 선택한다.     if (size - idx &lt;= num) {       for (let i = idx; i &lt; size; i++) result.push(i);       return [result];     }      // base case2: 선택이 완료되었을 경우     if (num === 0) {       return [result];     }      // 현재 idx부터 num개를 뽑는 방법은     // 1) 현재 요소를 선택하고 num-1개를 뽑는 방법     const picked = getCombinations(idx + 1, size, num - 1, result.concat(idx));     // 2) 현재 요소를 선택하지 않고 num개를 뽑는 방법     const notPicked = getCombinations(idx + 1, size, num, result);     return picked.concat(notPicked);   };    const combs = getCombinations(0, agents.length, num, []);   let min = Number.MAX_SAFE_INTEGER;   combs.forEach((c) =&gt; {     const sources = c.map((idx) =&gt; agents[idx]);     const result = bfs(sources);     min = Math.min(min, result);   });   return min; };   오늘 느낀 점   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   내일 할 일     TOY 43. shadowOfPapers  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.02.algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 1. Docker 2. 컨테이너와 VM의 비교",
        "excerpt":"  Today I Learnd  1. Docker      도커(Docker)는 쉽게 애플리케이션을 추상화 하고, 컨테이너 방식으로 실행할 수 있게 해주는 리눅스 컨테이너기반의 오픈소스 가상화 플랫폼중 가장 대표적인 종류 중 하나이다     1-1. 리눅스 컨테이너        개발자들은 개별적인 로컬 환경에서 작업하며 특정하게 설정된 환경을 사용하고 있으며, 현재 개발 중인 애플리케이션은 특정 라이브러리, 종속성 및 파일에 의존하고 있다. 이러한 애플리케이션을 배포할때 임의의 환경에서도 애플리케이션이 작동되게 하고, 품질 검사를 통과하고, 큰 문제나 수정 없이 애플리케이션을 배포하려면 리눅스 컨테이너(LXC) 를 사용해야 한다.   컨테이너는 다음 세가지의 자원을 독립적으로 격리하며 소유하고 있다.            프로세스                    특정 컨테이너에서 작동하는 프로세스는 기본적으로 그 컨테이너 안에서만 액세스할 수 있다.                            컨테이너 안에서 실행되는 프로세스는 다른 컨테이너의 프로세스에게 영향을 줄 수 없다.                                               네트워크                    기본으로 컨테이너 하나에 하나의 IP 주소가 할당되어 있다.                       파일 시스템                    컨테이너 안에서 사용되는 파일 시스템은 구획화되어 있다. 그래서 해당 컨테이너에서의 명령이나 파일 등의 액세스를 제한할 수 있다.                           요약하자면, 리눅스 컨테이너란 애플리케이션이 의존성, 네트워크 환경, 파일 시스템에 구애받지 않고 실행될 수 있도록 만든 애플리케이션 상자이다.    1-2. 이미지      실행되는 모든 컨테이너는 이미지로부터 생성된다.   이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있으며, 상태값을 가지지 않고 변하지 않는다(Immutable).     1-3. Docker CLI           공식문서를 통해 Docker Image 및 Container를 다루는 방법을 학습하였다.            danielkraic이 올린 이미지 asciiquarium 예시.       docker container run -it --rm danielkraic/asciiquarium:latest                    2. 컨테이너와 VM의 비교            컨테이너 기술과 가상 머신(VM)은 둘 다 프로세스, 네트워크, 파일 시스템을 격리할 수 있다는 장점을 공유하지만, 이 둘의 작동원리는 많이 다르다.       VM(가상머신 ex.에뮬레이터)을 만들고 실행하는 과정이 많은 컴퓨팅 자원을 필요로 하지만, 도커는 한 호스트 컴퓨터에 여러 개의 컨테이너를 띄워도 크게 컴퓨터에 무리가 가지 않는 장점이 있다.              VM의 구성 요소에 OS가 존재하는데 비해, 오른쪽의 도커 컨테이너에는 OS를 포함하고 있지 않다. 도커라는 플랫폼 위에 컨테이너들이 올라가 있고, 그 아래 호스트 OS가 존재하고있다.       이를 통해, 각 컨테이너는 호스트 OS의 커널(Kernel, 시스템 콜과 같이 OS의 핵심 기능을 구현한 프로그램)을 공유하고 있음을 짐작할 수 있다. 즉, 도커는 애플리케이션을 컨테이너화해서 실행하는 데에 주 목적이 있으므로, VM과 다르게 컨테이너에 OS를 올려서 사용하지 않기에 리소스가 적다. 호스트 OS의 입장에서 본다면 컨테이너 하나는 프로세스 하나에 불과하다.            오늘 느낀 점  도커를 왜 쓰는지 이유는 확실히 알았다. 서로 다른 배포환경에서 특정 환경에 종속되지 않고 개발과 배포를 원활히 이뤄질 수 있게 해주는 하나의 생태계이다.          내일 할 일     [배포] 배포 자동화  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.11.02.til/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 43. shadowOfPapers",
        "excerpt":"  TOY 43. shadowOfPapers  문제   좌표평면 위에 존재하는 수많은 직사각형에 대한 정보가 2차원 배열로 주어집니다. 이 직사각형들은 서로 겹처 있을(overlapping) 수 있습니다. 이 직사각형들이 이루는 면적을 리턴해야 합니다.   문제를 다르게 표현하면 아래와 같습니다.      밑이 투명한 좌표평면 위에 직사각형 모양의 종이을 여러 개 올려놓고 위에서 빛을 비출 때 생기는 그림자의 넓이를 구해야 합니다.    입력   인자 1 : papers     배열을 요소로 갖는 배열   papers.length는 30 이하   papers[i]는 number 타입을 요소로 갖는 배열   papers[i]는 차례대로 직사각형의 좌측 하단 모서리의 x좌표, y좌표, 너비(width), 높이(height)   papers[i][j]는 10,000 이하의 양의 정수   출력      number 타입을 리턴해야 합니다.   입출력 예시   let result = shadowOfPapers([[0, 1, 4, 4]]); console.log(result); // --&gt; 16  /* 4 | x x x x 3 | x x x x  2 | x x x x  1 | x x x x  0 |    --------------     0 1 2 3 4  */  result = shadowOfPapers([   [0, 0, 4, 4],   [2, 1, 2, 6],   [1, 5, 5, 3],   [2, 2, 3, 3], ]); console.log(result); // --&gt; 36 /* 7 |   x x x x x 6 |   x x x x x 5 |   x x x x x 4 |     x x x 3 | x x x x x 2 | x x x x x 1 | x x x x 0 | x x x x ------------------     0 1 2 3 4 5 6 7 */  힌트       인접 행렬로 좌표 평면을 생성하면 10,000 x 10,000의 2차원 행렬, 즉 1억개의 데이터를 생성해야 합니다. 대부분의 코딩 테스트에서 이는 공간 복잡도 요구 조건을 만족하지 못 합니다. 보통 코딩 테스트에서 메모리 사용량을 128MB ~ 512MB로 제한합니다. 64비트 정수(자바스크립트 number 타입)는 8바이트이므로, 전체 크기가 1천만개인 데이터들의 크기는 약 80MB 입니다. 메모리 사용량이 128MB라면 데이터가 2천만개만 넘어가도 테스트를 통과하지 못 합니다. 따라서 이 문제는 단순히 인접 행렬로 푸는 문제가 아니라는 것을 문제의 크기를 통해 추측할 수 있어야 합니다.   코딩 테스트의 입력 크기에 따른 시간 복잡도와 공간 복잡도 요구 사항에 대해서 학습하시기 바랍니다.   스위핑(sweeping) 알고리즘에 대해서 학습하시기 바랍니다.   TOY 43. Solution  수도코드      최대 컬럼의 길이를 구한다.   papers 배열을 탐색 시작.            최대컬럼만큼의 배열을만들고 0을 넣는다. col       papers의 길이만큼만 탐색 시작.                    구조분해할당으로 x, y, 너비, 높이를 할당한다.           row값이 0부터 세로로 넓이를 구할것이므로 rIdx와 x가 같다면 높이만큼 1을 찍어준다. 이후 x의 너비가 남았으면 다음 탐색에도 해당하는 높이를 찍어줘야하기 때문에 x + 1, 너비는 - 1을 해준다.           만일 해당 요소의 너비만큼 사용이 됐다면 버려주고, 그렇지 않으면 다시 2-2-3의 값을 papers에 넣어둔다.           papers의 길이만큼 탐색이 끝났다면 1의 개수를 sum에 더해주고 다음 row를 탐색해야 하기때문에 rIdx를 + 1 해준다.                           최종 값이된 sum을 리턴.   문제풀이    function shadowOfPapers(papers) {   let maxC = 0;    for (let i=0; i&lt;papers.length; i++) {     let [x, y, ox, oy] = papers[i];     maxC = Math.max(maxC, y + oy);   }    let rIdx=0;   let sum=0;    while(papers.length){     let col = new Array(maxC).fill(0);     let len = papers.length;          for (let i=0; i&lt;len; i++){       let [x, y, ox, oy] = papers.shift();              if (x===rIdx){         for(let j=y; j&lt;y+oy; j++){           col[j]=1;         }         if (ox===1) continue;         else papers.push([x+1, y, ox-1, oy]);                  } else{         papers.push([x, y, ox, oy]);       }     }          let count=0;      for (let i=0; i&lt;col.length; i++) {       if (col[i]===1) count++;     }     sum += count;     rIdx++;   }   return sum; }    Reference Code  const merge = function (left, right, comparator = (item) =&gt; item) {   let merged = [];   let leftIdx = 0,     rightIdx = 0;   const size = left.length + right.length;    for (let i = 0; i &lt; size; i++) {     if (leftIdx &gt;= left.length) {       merged.push(right[rightIdx]);       rightIdx++;     } else if (       rightIdx &gt;= right.length ||       comparator(left[leftIdx]) &lt;= comparator(right[rightIdx])     ) {       merged.push(left[leftIdx]);       leftIdx++;     } else {       merged.push(right[rightIdx]);       rightIdx++;     }   }    return merged; };  const mergeSort = function (arr, comparator) {   const aux = (start, end) =&gt; {     if (start &gt;= end) return [arr[start]];     const mid = Math.floor((start + end) / 2);     const right = aux(start, mid);     const left = aux(mid + 1, end);     return merge(left, right, comparator);   };   return aux(0, arr.length - 1); };  /* 모든 좌표가 아닌 높이가 변하는 부분만 계산한다. 색종이에 대한 정보가 아래와 같이 주어졌을 때, 전체 면적을 구하는 알고리즘 const papers = [   [0, 0, 4, 4],   [2, 1, 2, 6],   [1, 5, 5, 3],   [2, 2, 3, 3], ];  각 사각형의 시작과 끝을 범위(range) 표기로 각각 s(start), e(end)로 표시한다. e는 사각형이 끝나느 x좌표의 다음 좌표에 표기한다. 7 |   x x x x x 6 |   x x x x x 5 |   s x x x x e 4 |     x x x 3 | x x x x x 2 | x x s x x e 1 | x x s x e 0 | s x x x e ------------------     0 1 2 3 4 5 6 7  새로운 변화(시작 또는 끝)가 있을 때마다 면적을 계산하여 더한다.  1) 4를 더한다. (면적은 4) 7 |    6 |    5 |    4 |    3 | x  2 | x  1 | x  0 | s  ------------------     0 1 2 3 4 5 6 7  2) 7을 더한다. (면적은 11) 7 |   x  6 |   x  5 |   s  4 |      3 |   x  2 |   x  1 |   x  0 |   x  ------------------     0 1 2 3 4 5 6 7  3) 16을 더한다. (면적은 27) 7 |     x x  6 |     x x  5 |     x x  4 |     x x  3 |     x x  2 |     s x  1 |     s x  0 |     x x  ------------------     0 1 2 3 4 5 6 7  4) 6을 더한다. (면적은 33) 7 |         x  6 |         x  5 |         x  4 |         x 3 |         x 2 |         x  1 |          0 |          ------------------     0 1 2 3 4 5 6 7  4) 3을 더한다. (면적은 36) 7 |            x 6 |            x 5 |            x  4 |          3 |          2 |          1 |          0 |          ------------------     0 1 2 3 4 5 6 7 */ function shadowOfPapers(papers) {   // 주어진 사각형의 정보를 각 좌표의 시작과 끝을 나타내는 좌표로 변경하여 저장한다.   const coordinates = [];   papers.forEach((p) =&gt; {     const [x, y, width, height] = p;     // 사각형의 시작점의 x좌표, 하단 y좌표, 상단 y좌표, 사각형의 시작을 알리는 flag     coordinates.push([x, y, y + height - 1, 1]);     // 사각형의 마지막점의 x좌표, 하단 y좌표, 상단 y좌표, 사각형의 마지막을 알리는 flag     // x좌표는 너비 계산에 누락을 방지하기 위해 범위로 저장한다.     coordinates.push([x + width, y, y + height - 1, -1]);   });    // x축을 기준으로 정렬한다.   const sorted = mergeSort(coordinates, (c) =&gt; c[0]);   // 좌표 평면을 좌측에서 우측으로 순회하면서 매좌표까지 사각형이 차지하는 y좌표를 저장한다.   const height = Array(10000 + 1).fill(0);   for (let y = sorted[0][1]; y &lt;= sorted[0][2]; y++) height[y] = 1;   let sum = 0;   for (let i = 1; i &lt; sorted.length; i++) {     // 겹치는 부분을 제외하고 순수하게 높이만 구한다.     const h = height.reduce((acc, cur) =&gt; acc + (cur === 0 ? 0 : 1), 0);     const x2 = sorted[i][0];     const x1 = sorted[i - 1][0];     sum = sum + (x2 - x1) * h;      const y1 = sorted[i][1];     const y2 = sorted[i][2];     // 사각형은 서로 겹칠 수 있으므로, 누적값을 저장해야 한다.     for (let y = y1; y &lt;= y2; y++) height[y] += sorted[i][3];   }   return sum; }   오늘 느낀 점   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   내일 할 일     TOY 44. TSP (travelling salesman problem)  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.03.algorithm/",
        "teaser": null
      },{
        "title": "[Algorithm] TOY 44. TSP",
        "excerpt":"  TOY 44. TSP (travelling salesman problem)  문제   외판원 문제(travelling salesman problem, 이하 TSP)는 아래와 같이 정의됩니다.      여러 도시들의 위치가 주어졌을 때, 모든 도시들을 단 한번씩 방문하는 최단 거리를 구하세요.   각 도시의 위치를 나타내는 좌표평면 위의 점들을 입력받아, TSP의 최단 거리를 리턴해야 합니다.   입력   인자 1: places     배열을 요소로 갖는 배열   places[i]는 number 타입을 요소로 갖는 배열   places[i].length는 2   places[i]의 요소는 차례대로 좌표평면 위의 y좌표, x좌표   출력      number 타입을 리턴해야 합니다.   주의사항      외판원이 출발하는 도시와 도착해야 하는 도시는 정해져 있지 않습니다. 모든 도시를 빠짐없이 한번씩 방문하는 경로 중 최단 거리를 리턴해야 합니다.   두 점 사이의 거리를 계산하는 함수 calculateDistance가 주어집니다. 도시 간 거리는 반드시 이 함수를 이용해서 계산해야 합니다.   함수 calculateDistance는 소수점 계산을 피하기 위해 두 점 사이의 거리에 100을 곱한 후 정수 부분만 취합니다. 최단 거리도 이 기준으로 판단합니다.   입출력 예시   let placesToVisit = [   [0, 0],   [1, 1],   [1, 3],   [2, 2], ]; let output = TSP(placesToVisit); console.log(output); // --&gt; 423 // 방문 순서: [0, 0], [1, 1], [2, 2], [1, 3]  placesToVisit = [   [0, 0],   [3, 3],   [-3, 3],   [2, 3],   [1, 3], ]; output = TSP(placesToVisit); console.log(output); // --&gt; 940 // 방문 순서: [-3, 3], [1, 3], [2, 3], [3, 3], [0, 0]   Advanced       아래 내용에 유념하여 TSP에 대해 학습해 보세요.            TSP 처럼 모든 꼭지점을 한 번씩 지나는 경로를 해밀턴 경로(Hamiltonian path)라고 합니다.       TSP는 조합 최적화 문제의 일종으로 NP-hard라는 것이 증명되었습니다.       완전탐색(exhaustive search) 외의 방법이 존재하지 않습니다.           TOY 44. Solution  수도코드    문제풀이        Reference Code  // 좌표평면 위의 두 점 사이의 거리를 계산하는 함수입니다. function calculateDistance(p1, p2) {   const yDiffSquared = Math.pow(p2[0] - p1[0], 2);   const xDiffSquared = Math.pow(p2[1] - p1[1], 2);   const dist = Math.sqrt(yDiffSquared + xDiffSquared);   return Math.round(dist * 100); }  const TSP = function (places) {   let currentMinDist = Number.MAX_VALUE;   const LENGTH = places.length;   function traverse(lastVisited, visited, totalDist, visitNum) {     if (visitNum === LENGTH) {       if (currentMinDist &gt; totalDist) {         currentMinDist = totalDist;       }       return;     }      visited.forEach((value, idx) =&gt; {       if (value === false) {         // 아직 방문하지 않은 도시와         // 마지막으로 방문한 도시와의 거리를 구한다.         const distToNext = calculateDistance(places[lastVisited], places[idx]);         visited[idx] = true;         traverse(idx, visited, totalDist + distToNext, visitNum + 1);         visited[idx] = false;       }     });   }    // 각 도시의 현재 방문 여부를 관리하는 배열   const visited = Array(LENGTH).fill(false);   places.forEach((_, idx) =&gt; {     // 각 도시에서 출발하는 경우를 구분한다.     visited[idx] = true;     traverse(idx, visited, 0, 1);     visited[idx] = false;   });    return currentMinDist; };   오늘 느낀 점   우선은 Reference Code를 보고 이해하는 수준에서 마무리하였다.  다시 풀어 볼 예정   내일 할 일     오늘 오후부터 HA3 시작이다. 이후 프로젝트 진행 예정이므로, 당분간 TOY 알고리즘은 미뤄 둘 예정이다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.04.algorithm/",
        "teaser": null
      },{
        "title": "[Retrospect] 코드스테이츠 Section3 HA 기수이동",
        "excerpt":"   Retrospect   잘 다니던 은행권 회사를 그만두고 개발자로 전향하기로 마음 먹은 21년 05월 이후, 7월 19일 부터 시작한 코드스테이츠 33기 생활이 오늘 종료되고 34기로 이동하였다.  적지않은 나이에 시작하는거라 나름 열심히 노력하고있다 생각했지만, 번아웃..이라말하긴 창피하고 시작하였을때의 열정중 일정부분이 고갈되었다라 생각이 들곤하였다.      어느 순간부터 매일 두뇌회전을 위해 쓰여야하는 TOY 알고리즘 문제풀이 시간은 부족한 챕터 진행을 위해 쓰이곤 하였고, 정규 학습시간 이후 개인학습시간을 갖고 내것으로 소화시키며 하루하루 배운점을 기록으로 남기기보다는 그저 제출에 급급하고 다음날 뒤쳐질 챕터과정이 걱정되어서 선행학습을 우선시하며 겨우겨우 따라가는 내 모습을 보며, “스스로 부족하지않은가?” 라는 의심이 요즈음엔 확신으로 바뀌었다.    변론을 조금 하자면, HA 이번 과제형 문제는 로직 구현(포스트맨을 통한 JWT 토큰 방식의 회원가입, 로그인, 로그아웃.. 기능구현)은 모두 다 하였지만, 테스트 케이스를 충족할 만큼의 간결한 코드 구현은 하지못하여서 탈락을 하였다. 회고글 작성 후 다시한번 천천히 문제가 무었이었는지 시간에 쫓기지않는 상황에서 다시 복습할 예정이다.   사실 내 실력에 대한 의심은 오래전부터 가지고 있었기에, 오히려 잘 됐다라는 생각마저도 든다.   다만, 학습할 기간이 늘어나서 마음이 조급해진게 아니라 마음이 잘 맞는 스터디 팀원(4명중 2명 탈락, 2명 합격..) 들과 생이별을 한다는게 마음이 아프다.   지나간 일을 계속 후회하기보다는 이번 기수이동으로 인하여, 부족했던 나를 돌아 볼 기회가 생겼다고 생각한다.   7월 중순부터 달려온 일정에서 스스로 부족한 부분은 무엇인지 뼈저리게 느꼈고, 이번 한번의 시험 낙방으로 내 자신이 바닥까지 떨어졌다 생각하지도 않는다.   애초에 반년가량되는 이 짧은시간 동안 현업에서 필요한 모든 실무기술을 습득할 수 없다 생각한다.   마음 다잡고 다음주 부터 진행 될 34기의 일정을 잘 따라가며, 수료까지 후회없이 노력해야겠다.  ","categories": ["Retrospect"],
        "tags": [],
        "url": "/retrospect/21.11.06.retrospect/",
        "teaser": null
      },{
        "title": "[Blog] Minimal mistakes Sidebar Category",
        "excerpt":"   Minimal mistakes Sidebar Category   Jekyll 블로그 환경설정    글쓰기 앞서서 나와 같은 삽질을 하지않길 바라며 기록으로 남긴다.             Minimal mistakes jekyll theme 의 기본 레이아웃은 다음과 같다.              메뉴들이 최상단 부분에 고정되어 있기 때문에, 스크롤에 반응하는 왼쪽 SideBar 영역에 Category를 추가하고 싶었다.            Minimal mistake에서 제공하는 Quick-Start Guide에서 Custom sidebar navigation menu 를 참고하면 작성법을 알 수 있다.        Jekyll 변경점             우선 /_data/navigation.yml 에서 다음과 같이 수정하였다.         docs: - title: \"CodeStates\"   children:     - title: \"TIL\"       url: /category/#til     - title: \"TOY\"       url: /category/#toy     - title: \"Retrospect\"       url: /category/#retrospect  - title: \"Dev Tool\"   children:     - title: \"Git\"       url: /category/#git - title: \"About\"   url: /* Notion 경로 */                이제 이 수정한 내용을 모든 페이지 경로, 모든 포스트에서 보이게끔 설정해주면 된다. 우선 /_config.yml에서 Defaults 영역을 수정해서 앞으로 생성할 모든 포스트와, 페이지가 위에서 만든 사이드바를 포함시킬 수 있게끔 환경설정만 해주면 된다.         defaults: # _docs - scope:     path: \"\"     type: docs   values:     sidebar:       nav: \"docs\"                여기까지 해준다면 우선 기본적인 환경설정은 모두 마쳤기에 앞으로 생성하는 글이나 페이지에서는 저 사이드바가 잘 보일테지만 기존 블로그에 이미 쓰여진 포스트와, 페이지들은 적용안될것이다. 뭐지???…싶었다            기존 글과 페이지들이 소급 적용이 안되기때문에 아래와 같이 기존 페이지와 포스트 .md 파일들을 모두 수정해주면 적용되는 걸 볼 수 있다.       --- title:  category:  excerpt:  sidebar:   nav: docs ---          ","categories": ["Blog"],
        "tags": [],
        "url": "/blog/21.11.08.Blog/",
        "teaser": null
      },{
        "title": "[Algorithm] 짐 나르기 (Greedy)",
        "excerpt":"  짐 나르기 (Greedy)  문제   김코딩과 박해커는 사무실 이사를 위해 짐을 미리 싸 둔 뒤, 짐을 넣을 박스를 사왔다. 박스를 사오고 보니 각 이사짐의 무게는 들쭉날쭉한 반면, 박스는 너무 작아서 한번에 최대 2개의 짐 밖에 넣을 수 없었고 무게 제한도 있었다.   예를 들어, 짐의 무게가 [70kg, 50kg, 80kg, 50kg]이고 박스의 무게 제한이 100kg이라면 2번째 짐과 4번째 짐은 같이 넣을 수 있지만 1번째 짐과 3번째 짐의 무게의 합은 150kg이므로 박스의 무게 제한을 초과하여 같이 넣을 수 없다.   박스를 최대한 적게 사용하여 모든 짐을 옮기려고 합니다.   짐의 무게를 담은 배열 stuff와 박스의 무게 제한 limit가 매개변수로 주어질 때, 모든 짐을 옮기기 위해 필요한 박스 개수의 최소값을 return 하도록 movingStuff 함수를 작성하세요.   입력   인자 1: stuff     Number 타입의 40 이상 240 이하의 자연수를 담은 배열            ex) [70, 50, 80, 50]           인자 2: limited     Number 타입의 40 이상 240 이하의 자연수   출력      Number 타입을 리턴해야 합니다.   모든 짐을 옮기기 위해 필요한 박스 개수의 최솟값을 숫자로 반환합니다.   주의사항      옮겨야 할 짐의 개수는 1개 이상 50,000개 이하입니다.   박스의 무게 제한은 항상 짐의 무게 중 최대값보다 크게 주어지므로 짐을 나르지 못하는 경우는 없습니다.   입출력 예시   let output = movingStuff([70, 50, 80, 50], 100); console.log(output); // 3  let output = movingStuff([60, 80, 120, 90, 130], 140); console.log(output); // 4   Solution  수도코드    박스에는 최대 2개의 물건을 넣을 수 있으며, 조건중 짐을 나르지 못하는 경우는 없으므로 박스에는 1~2개의 물건이 무조건 들어간다.   옮겨야 할 짐의 개수는 1~50,000의 범위를 갖고있으므로, 연산의 횟수를 줄이기 위해 인덱스로 접근한다.   Greedy 알고리즘으로 접근한다면, 미래는 생각하지 않고 지금 현재의 최적의 경우만 고려하면 되므로 간단하게 풀이 할 수 있다.      물건들을 무게가 큰 순서대로 내림차순으로 정렬한다.   가장 무게가 큰 물건 + 가장 작은 물건의 합이 limit보다 작다면 박스에 물건을 2개를 넣고, 아니면 현재 가장 무거운 물건 1개만 박스에 넣는다. 너무 Greedy 에 충실하긴하다..   박스의 갯수를 세어가며 모든 물건 인덱스를 탐색하면 반복문을 종료하여 결과값을 반환한다.   문제풀이    function movingStuff(stuff, limit) {   const sortedStuff = stuff.sort((a, b) =&gt; b - a); // 물건의 무게를 내림차순으로 정렬    let maxIdx = 0;  // 가장 무거운 짐의 인덱스   let minIdx = sortedStuff.length - 1 ;  // 가장 가벼운 짐의 인덱스   let count = 0;  // 박스의 갯수      while(maxIdx &lt;= minIdx) {  // 반복문 탈출 조건     if( (sortedStuff[maxIdx] + sortedStuff[minIdx]) &gt; limit ) {         // 두 짐의 합이 limit 보다 클 경우에는 무거운 짐만 박스에 넣으므로 maxIdx만 증가한다       maxIdx++;       count++;     } else if ( (sortedStuff[maxIdx] + sortedStuff[minIdx]) &lt;= limit ){       // 두 짐의 합이 limit 보다 작을 경우에는 두짐 모두 박스에 넣으므로 두 idx값 모두 조정한다       maxIdx++;       minIdx--;       count++;     }   }    return count; }    Reference Code  function movingStuff(stuff, limit) {   let twoStuff = 0;   // 짐을 무게순으로 오름차순 정렬   let sortedStuff = stuff.sort((a, b) =&gt; a - b);   // 가장 가벼운 짐의 인덱스   let leftIdx = 0;   // 가장 무거운 짐의 인덱스   let rightIdx = sortedStuff.length - 1;   while(leftIdx &lt; rightIdx) {       // 가장 가벼운 짐과 무거운 짐의 합이 limit 보다 작거나 같으면 2개를 한번에 나를 수 있다       if(sortedStuff[leftIdx] + sortedStuff[rightIdx] &lt;= limit) {       // 다음 짐을 확인하기 위해 가장 가벼운 짐과 무거운 짐을 가리키는 인덱스를 옮겨주고       // 한번에 2개 옮길 수 있는 개수를 +1 해준다              leftIdx++;           rightIdx--;           twoStuff++;       } else {           // 위 조건에 맞지 않는 경우는 한번에 한 개만 나를 수 있는 경우이기 때문에           // 가장 무거운 짐의 인덱스만 옮겨준다               rightIdx--;       }   }   // 전체 짐의 개수에서 한번에 2개를 나를 수 있는 경우를 빼 주면 총 필요한 박스의 개수를 구할 수 있다   return stuff.length - twoStuff; }   느낀 점   Reference Code와 비슷하게 접근하였다. 우선 박스를 하중(limit)을 모두 채워 쓰는걸 고려하는 알고리즘은 아니기때문에 효율적인 알고리즘은 아님이 확실하다…  다만 결과를 도출하기 가장 명쾌하게 접근이 가능한 알고리즘인 듯 하다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.09.algorithm1/",
        "teaser": null
      },{
        "title": "[Algorithm] 편의점 알바 (Greedy)",
        "excerpt":"  편의점 알바 (Greedy)  문제   편의점에서 아르바이트를 하고 있는 중에, 하필이면 피크 시간대에 손님에게 거스름돈으로 줄 동전이 부족하다는 것을 알게 되었습니다.  현재 가지고 있는 동전은 1원, 5원, 10원, 50원, 100원, 500원으로 오름차순으로 정렬되어 있고, 각 동전들은 서로 배수 관계에 있습니다.  동전 개수를 최소화하여 거스름돈 K를 만들어야 합니다. 이때, 필요한 동전 개수의 최솟값을 구하는 함수를 작성해 주세요.   입력   인자 1: k     number 타입의 k   1 &lt;= k &lt;= 100,000,000   출력      number 타입의 거스름돈 K원을 만드는데 필요한 동전 개수의 최솟값을 반환해야 합니다.   입출력 예시   // 4000원을 받았을 때 500원짜리 동전 8개를 반환합니다. const output1 = test1(4000); console.log(output1); // --&gt; 8  // 4972원을 받았을 때 500원짜리 동전 9개, 100원짜리 동전 4개, 50원짜리 동전 1개, 10원짜리 동전 2개, 1원짜리 동전 2개, 총 18개를 반환합니다. const output2 = test1(4972); console.log(output2); // --&gt; 18   Solution  수도코드    가장 가치가 높은 동전인 500원 1개를 먼저 거슬러 주고 잔액을 확인한 뒤, 이후 100원 4개, 50원 1개, 10원 1개의 순서대로 거슬러 준다. Greedy 알고리즘의 모토이다.   간단하게 입력받은 인자 k를 500원, 100원, … , 1원 으로 각각 나눈 몫들의 합은 동전의 갯수의 합과 같다.   문제풀이    function partTimeJob(k) {   let totalCoinNum = 0; // 동전의 갯수   let idx = 0;  // 코인 배열을 탐색할 idx   const coins = [500, 100, 50, 10, 5, 1];  // 거스름돈 배열 모음      while(k &gt; 0) {  // 거슬러줄 잔돈이 없어질때까지 반복     const coinNum = Math.floor(k/coins[idx]);  // 각 동전들의 갯수 (몫이 곧 갯수이므로, 나눈 값에 소숫점은 버림해준다)     totalCoinNum += coinNum;  // 총 동전의 갯수에 현재 동전갯수를 더해준다          k = k % coins[idx];  // 남은 잔액을 현재 동전으로 나눈 뒤 나머지값으로 대체한다     idx++;  // 다음 동전으로 이동한다   }    return totalCoinNum; }     Reference Code  function partTimeJob(k) {   let result = 0;   const wallet = [500, 100, 50, 10, 5, 1];   for(let i = 0; i &lt; wallet.length; i++) {     if(k &gt; 0) {       const sum = Math.floor(k / wallet[i]);       result += sum;       k = k - (wallet[i] * sum);     }   }   return result; }   느낀 점   Reference Code와 비슷하게 접근하였다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.09.algorithm2/",
        "teaser": null
      },{
        "title": "[Algorithm] 보드 게임",
        "excerpt":"  보드 게임  문제   N * N의 크기를 가진 보드판 위에서 게임을 하려고 합니다. 게임의 룰은 다음과 같습니다.      좌표 왼쪽 상단(0, 0)에 말을 놓는다.   말은 상, 하, 좌, 우로 이동할 수 있고, 플레이어가 조작할 수 있다.   조작의 기회는 딱 한 번 주어진다.   조작할 때 U, D, L, R은 각각 상, 하, 좌, 우를 의미하며 한 줄에 띄어쓰기 없이 써야 한다.            예시: UDDLLRRDRR, RRRRR           한 번 움직일 때마다 한 칸씩 움직이게 되며, 그 칸 안의 요소인 숫자를 획득할 수 있다.   방문한 곳을 또 방문해도 숫자를 획득할 수 있다.   보드 밖을 나간 말은 OUT 처리가 된다.   칸 안의 숫자는 0 또는 1이다.            단, 좌표 왼쪽 상단(0, 0)은 항상 0이다.           획득한 숫자를 합산하여 숫자가 제일 큰 사람이 이기게 된다.   보드판이 담긴 board와 조작하려고 하는 문자열 operation이 주어질 때, 말이 해당 칸을 지나가면서 획득한 숫자의 합을 구하는 함수를 작성하세요.   입력   인자 1: board     number 타입의 2차원 배열   2 &lt;= board.length &lt;= 1,000   예: [ [0, 0, 1], [1, 0, 1], [1, 1, 1] ]   인자 2: operation     string 타입의 대문자 영어가 쓰여진 문자열   1 &lt;= operation.length &lt;= board.length * 2   U, L, D, R 이외의 문자열은 없습니다.   출력      Number 타입을 반환해야 합니다.            board와 operation이 입력값의 예시 ([ [0, 0, 1], [1, 0, 1], [1, 1, 1] ], DDR)일 때, (0, 0) -&gt; (1, 0) -&gt; (2, 0) -&gt; (2, 1) 순서로 이동하게 되고, 각 0, 1, 1, 1을 얻어 3을 반환합니다.           주의사항      만약, 말이 보드 밖으로 나갔다면 즉시 OUT 을 반환합니다.   입출력 예시   const board1 = [   [0, 0, 0, 1],   [1, 1, 1, 0],   [1, 1, 0, 0],   [0, 0, 0, 0] ] const output1 = boardGame(board1, 'RRDLLD'); console.log(output1); // 4   const board2 = [   [0, 0, 1],   [1, 1, 1],   [1, 0, 0] ] const output2 = boardGame(board2, 'UUUDD'); console.log(output2); // 'OUT'  const board3 = [   [0, 0, 0, 0, 0],   [0, 0, 1, 0, 0],   [0, 0, 0, 0, 0],   [0, 0, 0, 1, 0],   [0, 0, 0, 0, 0] ] const output3 = boardGame(board3, 'DDRRRUDUDUD'); console.log(output3); // 0   Solution  수도코드    정사각형 2차원 배열에서 길찾기 문제이다.   x,y 좌표값으로 operation에 따라 상하좌우로 움직이는 로직을 구현하면 되며, 문제의 조건처럼 보드를 나가는 경우를 설정하여 OUT을 반환하면 되는 문제이다.   2차원 배열 특성상 board[y][x]로 인지하고 있어야, 평면도의 xy축과 같은 개념으로 구현이 가능하다.   const board1 = [   [0, 1, 0, 0],   [0, 0, 0, 0],   [0, 0, 0, 0],   [0, 0, 0, 0] ]      1의 위치는 평면도 개념으로는 (1,0) 이지만, 2차원 배열 특성상 해당 1의 위치는 board1[0][1]이다.    문제풀이    function boardGame(board, operation) {   let result = 0;   let x = 0;   let y = 0;  // 배열의 인덱스 문제로, board[y][x] 로 인지해야한다.    for(let move of operation){  // operation 문자열을 순회     if(move === 'U'){  // UP       y-=1;     }     else if(move === 'D'){  // DOWN       y+=1;     }     else if(move === 'L'){  // LEFT       x-=1;     }     else if(move === 'R'){  // RIGHT       x+=1;     }      if(x&lt;0 || x&gt;board.length || y&lt;0 || y&gt;board.length) return 'OUT';          result += board[y][x];   }    return result; };    Reference Code  // LOOK UP TABLE을 사용한다면 조건문을 추상화시킬 수 있습니다. function boardGame(board, operation) {   // TODO: 여기에 코드를 작성하세요.   const DIR = {     'U': [-1, 0],     'D': [1, 0],     'L': [0, -1],     'R': [0, 1]   }   const LEN = board.length;   const isValid = (y, x) =&gt; 0 &lt;= y &amp;&amp; y &lt; LEN &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; LEN;    let Y = 0;   let X = 0;   let score = 0;   for (let i = 0; i &lt; operation.length; i++) {     const [dY, dX] = DIR[operation[i]];     Y += dY;     X += dX;     if (isValid(Y, X) === false) return 'OUT';     score += board[Y][X];   }   return score; };   느낀 점   Reference Code와 비슷하게 접근하였지만, 나와 다르게 UDLR 테이블을 만들어 간결히 추상화를 시켰으며 OUT 판별 로직또한 함수화 하여 간결히 사용하였다.   코드를 생각의 흐름대로 짜는 습관도 좋지만, 저렇게 작은 단위로 나눠 모듈화하는 과정또한 중요해보인다. (만약 코드가 크다면, 내가 짠 코드보다  Reference Code가 가독성, 재사용성이 뛰어나다.)  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.09.algorithm3/",
        "teaser": null
      },{
        "title": "[Algorithm] 금고를 털어라 (DP)",
        "excerpt":"  금고를 털어라 (DP)  문제   자신이 감옥에 간 사이 연인이었던 줄리아를 앤디에게 빼앗겨 화가 난 조지는 브레드, 맷과 함께 앤디 소유의 카지노 지하에 있는 금고를 털기로 합니다. 온갖 트랩을 뚫고 드디어 금고에 진입한 조지와 일행들. 조지는 이와중에 감옥에서 틈틈이 공부한 알고리즘을 이용해 target 금액을 훔칠 수 있는 방법의 경우의 수를 계산하기 시작합니다.   예를 들어 $50 을 훔칠 때 $10, $20, $50 이 있다면 다음과 같이 4 가지 방법으로 $50을 훔칠 수 있습니다.      $50 한 장을 훔친다   $20 두 장, $10 한 장을 훔친다   $20 한 장, $10 세 장을 훔친다   $10 다섯 장을 훔친다   훔치고 싶은 target 금액과 금고에 있는 돈의 종류 type 을 입력받아, 조지가 target 을 훔칠 수 있는 방법의 수를 리턴하세요.   입력   인자 1: target     Number 타입의 100,000 이하의 자연수   인자 2: type     Number 타입을 요소로 갖는 100 이하의 자연수를 담은 배열   출력      Number 타입을 반환해야 합니다.   조지가 target을 훔칠 수 있는 방법의 수를 숫자로 반환합니다.   주의사항      모든 화폐는 무한하게 있다고 가정합니다.   입출력 예시   let output = ocean(50, [10, 20, 50]); console.log(output); // 4  let output = ocean(100, [10, 20, 50]); console.log(output); // 10  let output = ocean(30, [5, 6, 7]); console.log(output); // 4   Hint!   해당 문제는 냅색 알고리즘(Knapsack Problem)을 활용하여 풀 수 있습니다. 검색해 보시고, 연구해 보세요!   Solution  수도코드    정말 문제를 받자마자 도저히 감이 잡히질 않았다.. 기수이동 전에는 Advanced라고 풀어보지도 않았다…   Reference Code를 참조하였다.   문제풀이        Reference Code  function ocean(target, type) {   // bag 이라는 배열에 금액을 만들 수 있는 경우의 수를 기록   // 각 인덱스 no# = 만드려는 금액 을 의미   // ex) target = 5, type = [1, 2, 5] 면   // bag[3] = 2  =&gt; 3을 만드는 경우의 수 = 1만 사용 &amp; 1,2 함께 사용   // bag[4] = 2  =&gt; 4를 만드는 경우의 수 = 1만 사용 &amp; 1,2 함께 사용   // bag[5] = 4  =&gt; 5를 만드는 경우의 수 = 1*5 , 1*3 + 2, 1 + 2*2, 5*1   // 0 을 만들 수 있는 경우는 아무것도 선택하지 않으면 되기 때문에 bag[0] = 1 로 초기값 설정   let bag = [1];    // 인덱스 no# = 만드려는 금액 이기 때문에   // bag 을 target 금액만큼의 길이를 가진 배열을 만들어 주고,   // 경우의 수를 저장하기 위해 초기값은 모두 0으로 만들어 준다   for(let i = 1; i &lt;= target; i++)     bag[i] = 0;   // 돈의 종류가 담겨있는 배열을 순차적으로 탐색      for(let i = 0; i &lt; type.length; i++) {   // target 금액까지 순차적으로 1씩 증가하면서         for(let j = 1; j &lt;= target; j++)   // bag의 인덱스가 type[i] 보다 큰 구간만   // (작은 구간은 type[i]로 만들 수 없는 금액이기 때문에 탐색할 필요가 없다)           if(type[i] &lt;= j)   // 기존 경우의 수에 type[i]를 뺀 금액을 만들 수 있는 경우의 수를 더해준다                bag[j] += bag[j-type[i]];   }   // bag 의 target 인덱스에 target 금액을 훔칠 수 있는 경우의 수가 쌓이므로   // 해당 값을 리턴해 준다    return bag[target]; }   느낀 점   Reference Code를 보아도 이해 할 수 없어서, 계속 디버깅을 돌려보며 이해하려 노력해보았다.   디버깅을 돌려가니 눈으로 로직이 보이긴한다.. 결론만 말하자면 bag 배열의 인덱스에는 target 금액을 훔칠 수 있는 경우의 수가 쌓이는 구조이다. (Dynamic Programmin)   다시 풀으라해도 솔직히 풀어낼 자신이 없는 문제다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.09.algorithm4/",
        "teaser": null
      },{
        "title": "[Algorithm] 가위바위보 (중복순열)",
        "excerpt":"  가위바위보 (중복순열)  문제   가위바위보 게임은 2인 이상의 사람이 동시에 ‘가위, 바위, 보’를 외치고 동시에 가위, 바위 또는 보 중에서 한 가지를 의미하는 손 모양을 내밀어 승부를 결정짓는 게임입니다. 세 판의 가위바위보 게임을 할 경우, 한 사람은 세 번의 선택(예. 가위, 가위, 보)을 할 수 있습니다. 세 번의 선택으로 가능한 모든 경우의 수를 구하는 함수를 작성합니다.   입력      없음   출력      2차원 배열(arr[i])을 리턴해야 합니다.   arr[i]는 전체 경우의 수 중 한 가지 경우(총 세 번의 선택)를 의미하는 배열입니다.   arr[i]는 'rock', 'paper', 'scissors' 중 한 가지 이상을 요소로 갖는 배열입니다.   arr[i].length는 3   주의사항      최종적으로 리턴되는 배열의 순서는 가중치 적용 정렬(Weighted Sort)을 따릅니다.   중요도는 'rock', 'paper', 'scissors' 순으로 높습니다.   쉽게 생각해 올림픽 순위 결정 방식을 참고하면 됩니다.   금메달('rock')이 은메달('paper')보다 우선하고, 은메달('paper')이 동메달('scissors')보다 우선합니다.   입출력 예시   let output = rockPaperScissors();  console.log(output); /*     [       [\"rock\", \"rock\", \"rock\"],       [\"rock\", \"rock\", \"paper\"],       [\"rock\", \"rock\", \"scissors\"],       [\"rock\", \"paper\", \"rock\"],       // ...etc ...     ]   */   Advanced      가위바위보 게임의 수를 나타내는 양의 정수 rounds가 주어질 경우, 해당 rounds 동안 선택할 수 있는 모든 경우의 수를 리턴하도록 함수를 작성해 보세요.   let output = rockPaperScissors(5);  console.log(output); /*     [       [\"rock\", \"rock\", \"rock\", \"rock\", \"rock\"],       [\"rock\", \"rock\", , \"rock\", \"rock\", \"paper\"],       [\"rock\", \"rock\", , \"rock\", \"rock\", \"scissors\"],       [\"rock\", \"rock\", \"rock\", \"paper\", \"rock\"],       [\"rock\", \"rock\", \"rock\", \"paper\", \"paper\"],       [\"rock\", \"rock\", \"rock\", \"paper\", \"scissors\"],       [\"rock\", \"rock\", \"rock\", \"scissors\", \"rock\"],       // ...etc ...     ]   */   Solution  수도코드    우선 Bare Minimum 문제는 어렵지 않게 해결할 수 있었다.   for문을 3번 중첩하여 경우의 수를 도출해내면 된다.  각 자리에 3가지('rock', 'paper', 'scissors')의 경우의 수가 올 수 있다. 그리고 라운드는 3으로 고정되어 있기에 3^3의 경우의 수, 즉 27가지의 경우의 수를 배열로 반환하면 된다.   다만, Advanced 경우에는 라운드 수가 고정이 아니므로 몇번 for문을 중첩해야 할 지.. 미리 알 수 없기 때문에, 재귀 함수(Rounds를 인자로 받는)를 통하여 구현을 해야만 했다.    문제풀이    Bare Minimum  function rockPaperScissors () {   const items = ['rock', 'paper', 'scissors'];  // 가중치를 둔 배열 생성   let result = [];        for(let i=0; i&lt;items.length; i++){  // 각 자리수 마다 3개의 경우의 수 존재     for(let j=0; j&lt;items.length; j++){       for(let k=0; k&lt;items.length; k++){         let temp = [items[i], items[j], items[k]];         result.push(temp);        }     }   }      return result; }   Advanced  function rockPaperScissors (rounds) {   rounds = rounds || 3;   const items = ['rock', 'paper', 'scissors'];   let result = [];        const recursive = ( round, temp ) =&gt; {     if( round === 0 ){         result.push(temp);       return;     } else {       for(let item of items){         recursive( round-1, temp.concat(item) )       }     }   }    recursive(rounds, []);   return result; }    Reference Code  // Advanced가 포함된 레퍼런스 코드입니다. const rockPaperScissors = function (rounds) {    // rounds 매개변수를 임의로 넣습니다.   // rounds 변수가 있을 경우 그대로 사용하고, 없다면 3(기본)을 사용합니다.   rounds = rounds || 3;   const rps = ['rock', 'paper', 'scissors'];    // 결과를 담을 배열 선언   const outcomes = [];    // 재귀를 사용할 함수 선언   // rounds를 넣을 변수 roundsToGo, 일회용 배열인 playedSoFar 변수를 선언합니다.    // 재귀를 사용하는 이유는, 배열의 모든 요소의 경우의 수를 훑기 위한 적절한 방법이기 때문입니다.   // 간단히 말하자면, 이 함수는 rounds 숫자를 기준으로, 일회용 배열에 rps 요소를 rounds 숫자만큼 넣게 됩니다.   // 이 로직을 잘 이해할 수 있을 때까지 하단의 함수 로직을 연구해야 합니다.   let permutate = function (roundsToGo, playedSoFar) {      // rounds가 0일 경우 outcones 배열에 삽입하고, 재귀에서 빠져나옵니다.     if (roundsToGo === 0) {       outcomes.push(playedSoFar);       return;     }      // rps 배열을 한 번씩 순회합니다.     for (let i = 0; i &lt; rps.length; i++) {       // rps의 i번째 요소를 변수에 담아서       let currentPlay = rps[i];       // permutate(본인)에 기존 rounds에서 하나 뺀 숫자와, 일회용 배열 playedSoFar에 currentPlay를 삽입하여 재귀를 실행합니다.       // rounds에서 하나를 빼는 이유는, 일회용 배열의 크기를 rounds만큼 맞춰주기 위함입니다. [rock, rock, rock]        // Q. playedSoFar.push(currentPlay)로 할 수 있을 텐데, 왜 concat을 사용할까요?       permutate(roundsToGo - 1, playedSoFar.concat(currentPlay));       /**        * 이 재귀의 로직은 이렇습니다. 처음 실행된 반복문은 rps를 전부 순회해야 끝이 납니다.        * 그러나 한 번 반복할 때마다 permutate 함수가 실행되고, rounds의 숫자는 짧아지며, playedSoFar에 요소가 계속 쌓일 것입니다.        * 결국, roundsToGo가 0이 될 때까지 이 반복문은 rps[i]가 0일 것이며, playedSoFar에는 [rock, rock, rock]이 되어 outcones에 Push하고, 종료하게 됩니다.        * return이 되었으니, 한 번의 재귀 호출이 끝났습니다. 마지막 호출 바로 전으로 돌아가,        * for문은 i = 1을 가리키게 될 것이고, [rock, rock, paper]을 삽입한 뒤 호출을 하게 됩니다.        * roundsToGo가 0이 되어, 해당 배열은 outcomes 배열에 삽입됩니다.        * 이런 식으로 모든 호출의 반복문이 끝날 때까지 반복하며 outcomes에 경우의 수 요소들이 담기게 됩니다.        */     }   };    // 함수를 실행합니다.   permutate(rounds, []);    // outcomes를 반환합니다.   return outcomes; };   느낀 점   Reference Code와 재귀부분은 비슷하게 구현된듯하다. .push() 메소드는 기존 배열에 원소를 추가하며 배열의 총 길이를 리턴하는 메소드 이며, .concat() 메소드는 기존 배열을 복사한 후 원소를 추가하여 새 배열을 리턴하는 차이가 있다.   .push() 메소드는 위 로직에 쓰일 땐 조심히 쓰여야 한다…  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.10.algorithm1/",
        "teaser": null
      },{
        "title": "[Algorithm] 새로운 치킨 소스 레시피 (순열)",
        "excerpt":"  새로운 치킨 소스 레시피  문제   개업 이래로 항상 승승장구하는 ‘승승장구 치킨집’의 비결은 소스에 있다. 수많은 타사 브랜드 치킨집들이 승승장구 치킨집의 소스 비결을 알아내려고 했으나 빈번히 포기했다.  그 이유는 5대째 내려오는 ‘비밀의 승승장구 치킨 소스 비율 레시피’는 70억 인구 중 사장님만 알고 있기 때문이다. 최근, 누리꾼 사이에서 이 레시피의 일부분을 발췌했다는 소문을 듣게 되었다.  그 소문은 다음과 같다.       N 가지의 재료 중에 단 M 가지만을 사용하여 조합한 모든 경우의 수 중 하나이다.   재료는 0과 1로만 이루어진 숫자로 암호화가 되어 있고, 항상 1로 시작하며 복호화를 할 수 없다.            단, 0이 3개 이상인 재료는 상한 재료이기 때문에 제외한다.           재료의 순서에 따라 맛이 달라지기 때문에, 재료를 넣는 순서가 다르다면 다른 레시피이다.   이 소문을 참고하여 ‘비밀의 승승장구 치킨 소스’가 될 수 있는 경우의 수를 모두 반환하는 함수를 작성하세요.   입력   인자 1: stuffArr     Number 타입의 재료를 담은 배열            요소는 0과 1로만 이루어진 숫자이며, 항상 1로 시작합니다.       요소는 중복될 수 없습니다.       요소의 길이는 20 이하입니다.       배열의 길이는 2 이상 10 이하입니다.       ex) [111, 110, 1010, 10, 10110]           인자 2: choiceNum     Number 타입의 1 이상 stuffArr 길이 이하의 자연수   재료를 선택할 수 있는 수를 뜻합니다.   ex) 2   출력      Number 타입을 반환해야 합니다.            stuffArr가 [1, 10, 11000, 1111] 이고, choiceNum은 2라면 사용 가능한 재료는 [1, 10, 1111] 입니다. 조합할 수 있는 경우의 수는 6 가지입니다.           주의사항      만약, 주어진 재료 모두 사용할 수 없다면 빈 배열[]을 반환해야 합니다.   만약, 사용할 수 있는 재료가 choiceNum보다 작다면 빈 배열[] 을 반환해야 합니다.   조합 및 요소는 작은 숫자 -&gt; 큰 숫자로 정렬합니다.            예시로 [1, 10, 11000, 1111]이 요소로 들어왔다면, 0이 세 개인 11000을 제외하고 [1, 10, 1111] 순서가 되어야 하며, [ [1, 10], [1, 1111], [10, 1], [10, 1111], [1111, 1], [1111, 10] ]을 반환해야 합니다.           입출력 예시   const output1 = newChickenRecipe([1, 10, 1100, 1111], 2); console.log(output1); /*   [     [1, 10], [1, 1100], [1, 1111],     [10, 1], [10, 1100], [10, 1111],     [1100, 1], [1100, 10], [1100, 1111],     [1111, 1], [1111, 10], [1111, 1100]   ]; */  const output2 = newChickenRecipe([10000, 10, 1], 3); console.log(output2); // []  const output3 = newChickenRecipe([11, 1, 10, 1111111111, 10000], 4); console.log(output3); /*    [     [1, 10, 11, 1111111111],     [1, 10, 1111111111, 11],     [1, 11, 10, 1111111111],     [1, 11, 1111111111, 10],     [1, 1111111111, 10, 11],     [1, 1111111111, 11, 10],     [10, 1, 11, 1111111111],     [10, 1, 1111111111, 11],     [10, 11, 1, 1111111111],     [10, 11, 1111111111, 1],     [10, 1111111111, 1, 11],     [10, 1111111111, 11, 1],     [11, 1, 10, 1111111111],     [11, 1, 1111111111, 10],     [11, 10, 1, 1111111111],     [11, 10, 1111111111, 1],     [11, 1111111111, 1, 10],     [11, 1111111111, 10, 1],     [1111111111, 1, 10, 11],     [1111111111, 1, 11, 10],     [1111111111, 10, 1, 11],     [1111111111, 10, 11, 1],     [1111111111, 11, 1, 10],     [1111111111, 11, 10, 1],   ] */   Solution  수도코드       상한 재료를 걸러낸다 (0이 3개 이상인 재료)   재료의 순서가 중요하기 때문에 정렬한다 (문제의 조건에서 작은 숫자 -&gt; 큰숫자로 정렬 명시되어 있음)   1~2번을 모두 수행한 다음부터는 가위바위보 문제와 같아진다… 다만 가위바위보 문제는 중복이 허용 되었다 ex) [묵,묵,묵]   다만, 레시피 문제에서는 똑같은 재료를 여러번 넣을수 없기 때문에 중복된 값은 넣어주지 않는 로직을 추가해서 풀어주었다.   문제풀이   function newChickenRecipe(stuffArr, choiceNum) {   let freshArr = [];   let result = [];    const rot = /0/g  // 정규 표현식 (0을 포함한 문자열을 리턴함)   for(let el of stuffArr){     if(String(el).match(rot) === null || String(el).match(rot).length &lt; 3) freshArr.push(el);  // 0이없거나, 0이 3개미만인 재료만 푸쉬   }      freshArr.sort((a,b) =&gt; a-b); // 오름차순 정렬    if(freshArr.length ===0 || freshArr.length &lt; choiceNum) return [];  // 신선한 재료가 없거나, choiceNum이 재료의수 보다 클 경우는 [] 리턴    const recursive = ( choice , temp ) =&gt; {  // 가위바위보 문제 로직과 같다     if( choice === 0 ){       result.push(temp);       return;     } else {       for(let stuff of freshArr){         if(!temp.includes(stuff)) recursive( choice-1, temp.concat(stuff) );  // 중복금지 로직만 추가하였다       }     }   }    recursive(choiceNum, []);   return result; }    Reference Code  function newChickenRecipe(stuffArr, choiceNum) {   // stuffArr에서 0이 3개 이상이라면 전부 필터로 거르기.   let freshArr = [];    for (let i = 0; i &lt; stuffArr.length; i++) {     const element = String(stuffArr[i])       .split('')       .filter((e) =&gt; e === '0');     if (element.length &lt;= 2) {       freshArr.push(stuffArr[i]);     }   }    // 정렬   freshArr.sort((a, b) =&gt; a - b);    // 엣지 케이스 처리   if (freshArr.length === 0 || freshArr.length &lt; choiceNum) return [];    // 레시피 초기화   let result = [];    // freshArr를 상대로 순열 구하기   const permutation = (arr, bucket, n) =&gt; {     if (n === 0) {       result.push(bucket);       return;     }      for (let i = 0; i &lt; arr.length; i++) {       // 하나를 초이스함       const choice = arr[i];       // 배열을 슬라이스함       const sliceArr = arr.slice();       // 초이스만 뺀다       sliceArr.splice(i, 1);       // 재귀       permutation(sliceArr, bucket.concat(choice), n - 1);     }   };    // 실행   permutation(freshArr, [], choiceNum);      // 순열의 길이 반환   return result; }   느낀 점   Reference Code와 미묘하게 다르게 풀이하였다.   우선 나는 정규표현식을 통해서 상한재료를 필터링하였다. 잘 안써봐서 수많은 구글링 끝에…   그리고 재귀로직을 보면 Reference Code는 배열에서 초이스한 부분을 잘라서 넘겨주는 로직인 반면에, 나는 재귀로 들어가기전에 중복여부를 체크한 후 재귀로직을 들어갔다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.10.algorithm2/",
        "teaser": null
      },{
        "title": "[Algorithm] 블랙잭은 지겨워 (조합)",
        "excerpt":"  블랙잭은 지겨워  문제   평범한 블랙잭 게임에서 수시로 패배하자 흥미가 떨어진 김코딩은 박타짜에게 게임룰을 변형하여 새로운 카드 놀이를 해 볼 것을 제안합니다.  새로운 룰은 다음과 같습니다.           숫자로 이루어진 카드를 여러 장 받습니다.      3장씩 카드를 고르고, 3장에 적힌 숫자들의 합이 소수인지 확인합니다.      받아든 카드로 만들 수 있는 소수의 개수가 많은 사람이 이기게 됩니다.      예로, [1, 2, 3, 4]라는 카드를 받았을 때 만들 수 있는 숫자는 6, 7, 8, 9이고, 소수는 7 하나이기 때문에 가지고 있는 소수의 개수는 1개입니다.  [2, 3, 4, 8, 13]라는 카드를 받았을 때 만들 수 있는 숫자는 9, 13, 18, 14, 19, 23, 15, 20, 24, 25이고, 소수는 13, 19, 23 총 3개이기 때문에 가지고 있는 소수의 개수는 3개입니다.   게임을 진행하기 전에 소수에 대해 아무런 지식이 없는 박타짜는 게임을 며칠 미룬 뒤, 게임의 룰을 따르는 함수를 만들기로 했습니다.  소수에 약한 박타짜를 도와 여러 장의 카드 중 세 장씩 조합해 소수가 되는 경우의 수를 리턴하는 함수를 완성해 주세요.   입력   인자 1: cards     cards: Array 3개 이상 50개 이하의 카드가 숫자로 들어 있는 배열   출력      Number 타입을 리턴해야 합니다.   주의사항      cards 에는 중복된 숫자의 카드는 들어있지 않습니다.   각 카드에 적힌 수는 1이상 1,000이하의 자연수입니다.   입출력 예시   let output = boringBlackjack([1, 2, 3, 4]); console.log(output); // 1  let output = boringBlackjack([2, 3, 4, 8, 13]); console.log(output); // 3   Solution  수도코드       소수 Check 함수 구현   카드는 3장을 중복없이 뽑는 중첩 for문 작성   뽑은 3장의 카드의 합이 소수인지 Check   카드 3장의 합이 소수라면 count 해주는 변수를 만들고 리턴한다.   어렵지 않게 3중 for문으로 풀 수있다. (반복 횟수가 고정적이므로 for문으로 풀이 가능)   카드는 중복된 카드가 없으므로 for문의 인덱스만 조심히 설계하자.   문제풀이   function boringBlackjack(cards) {    const isPrime = (num) =&gt; {     if(num === 2) return true;  // 2는 소수이다.     for(let i = 2; i &lt;= Math.floor(Math.sqrt(num)); i++){  // 제곱근까지 판별해도 된다       if(num % i === 0){  // 자기자신과 외의 숫자로 나뉘어진다면 소수가 아니다.         return false;        }     }     return true;   }    let result = 0;    for(let i=0; i&lt;cards.length; i++){  // 첫번째 카드     for(let j=i+1; j&lt;cards.length; j++){  // 두번째 카드(카드는 1장씩이니, i+1이 시작 인덱스이다.)       for(let k=j+1; k&lt;cards.length; k++){  // 세번쨰 카드         if(isPrime(cards[i] + cards[j] + cards[k])) result++;       }     }   }    return result; }     Reference Code  function boringBlackjack(cards) {   let count = 0;      // 1. cards 에서 카드 3장 뽑기     let length = cards.length;     // 카드 뽑는 방식은 첫 카드를 cards 의 0번 index 부터 고정해 놓고 1씩 뒤로 옮겨간다     for (let i = 0; i &lt; length; i++) {     // 두 번째 카드의 인덱스는 첫 카드 + 1에서 시작해야 하고       for (let j = i + 1; j &lt; length; j++) {     // 세 번째 카드의 인덱스는 두 번째 카드 + 1에서 시작해야 한다          for (let k = j + 1; k &lt; length; k++) {           const number = cards[i] + cards[j] + cards[k];           // 세 카드의 합이 소수이면 경우의 수 + 1           if (isPrime(number)) count++;         }       }     }        //2. 소수 판별     function isPrime(number) {     // 2부터 비교하기 시작해서 나누어 떨어지는 수가 있으면 소수가 아니다     // for 문 조건을 number/2 로 해도 되는 이유는 i &gt; number/2 가 되면 몫이 절대 0이 될수 없기 때문에     // number/2 까지만 비교해 보아도 소수 판별이 가능하다       for (let i = 2; i &lt; number/2; i++) {         if (number % i === 0) return false;       }       return true;     }        return count; }   느낀 점   Reference Code와 크게 다르지 않다. 어렵지 않게 풀 수 있는 문제이다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.10.algorithm3/",
        "teaser": null
      },{
        "title": "[Algorithm] 빼빼로 데이 (GCD)",
        "excerpt":"  빼빼로 데이  문제   오늘은 빼빼로 데이입니다. 한 회사의 팀장은 출근길에 아몬드 빼빼로 M개와 누드 빼빼로 N개를 구매하여 아침 일찍 출근길에 나섰습니다.   팀장은 자신보다 먼저 출근해 있는 직원들에게 구매한 빼빼로를 전부 나누어 주려고 합니다.  단, 서로 질투하는 경우를 만들지 않기 위해 모든 직원들에게 공평하게 빼빼로를 나누어 주려고 합니다.  직원들은 각각의 빼빼로를 똑같은 개수만큼 받아야 합니다. 빼빼로를 쪼개서 줄 수는 없습니다.   하지만 회사에 도착하기 전이라 몇 명의 직원들이 있는지 모르는 상황입니다.  팀장이 아몬드 빼빼로를 4개, 누드 빼빼로를 8개를 구매 했다면, 다음과 같이 세 가지 방법으로 나누어 줄 수 있습니다.      출근한 직원이 1명이라면 아몬드 빼빼로 4개와 누드 빼빼로 8개를 줄 수 있습니다.   출근한 직원이 2명이라면 아몬드 빼빼로 2개와 누드 빼빼로 4개를 각각 줄 수 있습니다.   출근한 직원이 3명이라면 빼빼로를 남기지 않고 공평하게 주는 방법은 없습니다.   출근한 직원이 4명이라면 아몬드 빼빼로 1개와 누드 빼빼로 2개를 각각 줄 수 있습니다.   팀장은 출근한 직원 수에 따라 어떻게 빼빼로를 나누어 줄지 고민하고 있습니다.  여러분이 직원 수에 따라 빼빼로를 나누어 주는 방법을 구하는 솔루션을 제공해 주세요.   입력   인자 1: M     Number 타입의 양의 정수 (1 ≤ M ≤ 1,000,000,000)   인자 2: N     Number 타입의 양의 정수 (1 ≤ M ≤ 1,000,000,000)   출력      2차원 배열 output을 리턴해야 합니다.   output[i]은 다음과 같은 순서를 가진 길이 3의 배열입니다.            [빼빼로를 받게 되는 직원의 수, 나누어 주는 아몬드 빼빼로의 수, 나누어 주는 누드 빼빼로의 수]           output은 output[i][0], 즉 ‘빼빼로를 받게 되는 직원의 수’를 기준으로 오름차순으로 정렬합니다.   입출력 예시   let M = 4; let N = 8; let output = divideChocolateStick(M, N); console.log(output); // [[1, 4, 8], [2, 2, 4], [4, 1, 2]]   Solution  수도코드       공약수들을 구해서 배열에 담는다.   공약수 배열을 순회 하며 [인원수, 아몬드 빼뺴로/인원수, 누드 빼뺴로/인원수] 배열을 결과값 배열에 담아 리턴한다.   공약수는 M과 N을 각각 나누어서 나머지가 0인 수들이므로, 둘중 작은 숫자를 1부터 나눠보며 찾을 수 있다.   문제풀이   function divideChocolateStick(M, N) {   let result = [];   let divisor = [];    for(let i=1; i&lt;=Math.min(M,N); i++) {  // 공약수는 둘중 작은 숫자를 찾아     if(M%i === 0 &amp;&amp; N%i === 0){  // 둘다 나머지가 0으로 나눠떨어지는 숫자들이다       divisor.push(i);  // 공약수 배열에 담는다.     }   }    for(let div of divisor){  // 공약수 배열을 순회하며     result.push([div, M/div, N/div]);  // 양식에 맞게 결과값 배열에 넣어준다   }    return result; }    Reference Code  // 최대 공약수(유클리드 호제법: Euclidean algorithm) function gcd(m, n) {   if (m % n === 0) return n;   return gcd(n, m % n); }  function divideChocolateStick(M, N) {   const result = [];   // 최대공약수를 구한다.   // M, N의 순서는 상관없다.   const GCD = gcd(M, N);   let temp = 0; //    // 약수는 대칭적이므로 제곱근까지만 반복해도 된다.   // 예) 36의 약수는 1, 2, 3, 4, 6, 9, 12, 18, 36이다.   // 제곱근을 기준으로 양쪽의 값 하나씩 곱했을 때 36이 되기 때문에   // 제곱근 보다 큰 약수는 제곱근보다 작은 약수에서 구할 수 있다.   const sqrt = Math.floor(Math.sqrt(GCD));   for (let left = 1; left &lt;= sqrt; left++) {     if (GCD % left === 0) {       // 최대공약수의 약수인 경우 중 제곱근 보다 작은 약수의 경우       result.push([left, M / left, N / left]);       if (left * left &lt; GCD) {         // 제곱근이 아닌 경우(제곱근 보다 작은)         right = GCD / left; // 최대 공약수를 제곱근이 아닌 수로 나누면 제곱근 보다 큰 약수를 구할 수 있다.         result.push([right, M / right, N / right]);       }     }   }    // '빼빼로를 받게 되는 직원의 수'를 기준으로 오름차순으로 정렬   result.sort((op1, op2) =&gt; op1[0] - op2[0]);    return result; }   느낀 점   시간복잡도 문제인지 TEST CASE 1개를 통과하지 못하였다.   Reference Code를 참조해보니 모든 약수를 체크하지 않고 제곱근까지 접근하는 로직으로 구현한걸 보았다. 귀찮아서 내 코드를 고치진 않았다…   최대 공약수를 구하는 알고리즘이 인상 깊었다. 자주 쓰이진 않겠지만 이렇게 구현이 된다는 것 자체가 신기하다…   // 최대공약수(유클리드 호제법: Euclidean algorithm) function gcd(m, n) {   if (m % n === 0) return n;   return gcd(n, m % n); }  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.10.algorithm4/",
        "teaser": null
      },{
        "title": "[Algorithm] 집밥이 그리워 (멱집합)",
        "excerpt":"  집밥이 그리워  문제   김코딩은 몇 년의 해외 출장 끝에 본가에 내려왔습니다. 오랜만에 보는 김코딩의 얼굴에 반가웠던 부모님은 상다리가 부러질 정도로 음식을 만들었습니다. 감동의 재회도 잠시, 의자에 앉아 식사를 하려던 김코딩은 무엇부터 먹어야 될지 깊은 생각에 빠졌습니다. 정성스럽게 차려 주신 만큼, 최대한 많은 방법으로 다양하게 먹고 싶었기 때문입니다.   밥은 한 가지이며 반찬은 다수일 때, 밥과 함께 먹을 수 있는 반찬의 모든 경우의 수를 배열에 담아 리턴하세요.   입력   인자 1: sideDishes     String 타입의 영문으로 된 반찬이 나열되어 있는 배열   출력      Array 타입을 리턴해야 합니다.   밥과 함께 먹을 수 있는 반찬의 모든 경우의 수가 담긴 배열   출력      반찬은 영문으로 작성이 되어 있습니다.   반찬은 중복되지 않습니다.   반찬을 먹지 않는 것도 포함됩니다. (출력되는 2차원 배열은 빈 배열을 포함합니다.)   반찬은 3개 이상 99개 이하입니다.   출력되는 배열은 전부 사전식 순서(lexical order)로 정렬되어야 합니다.   입출력 예시   let output = missHouseMeal([\"eggroll\", \"kimchi\", \"fishSoup\"]); console.log(output); /* [ [],    [ 'eggroll' ],    [ 'eggroll', 'fishSoup' ],    [ 'eggroll', 'fishSoup', 'kimchi' ],    [ 'eggroll', 'kimchi' ],    [ 'fishSoup' ],    [ 'fishSoup', 'kimchi' ],    [ 'kimchi' ] ]  */   Solution  수도코드    TOY 11. powerSet  문제의 로직과 똑같다.   DFS 방식으로 재귀를 구현하는 방식이다.. 사실 다시 떠올라서 풀진 못하였고, 이전에 정리한 내용을 보며 다시 풀어보았다.   문제풀이   function missHouseMeal(sideDishes) {   sideDishes.sort();   let result = [];    const recursive = (idx, subset) =&gt; {     if (idx === sideDishes.length) { // 마지막 문자까지 검토한 경우       result.push(subset);       return;     }      // recursive case     // idx번째 문자가 포함되지 않는 경우     recursive(idx + 1, subset);      // idx번째 문자가 포함되는 경우     recursive(idx + 1, subset.concat(sideDishes[idx]));   };    recursive(0, []);    return result.sort(); }    Reference Code  function missHouseMeal(sideDishes) {    // 결과를 담을 배열을 선언합니다.   let result = [];   // sideDishes를 사전식 순서로 정렬합니다.   sideDishes.sort();    // 모든 조합을 검사하는 재귀 함수를 작성합니다.   const sidePowerSet = (idx, sideDish) =&gt; {      // 재귀 함수이기 때문에 탈출 조건을 만듭니다.     if (idx === sideDishes.length) {       // 만약, idx와 sideDishes의 길이가 같다면(마지막까지 검토한 경우) result에 sideDish를 삽입하고 push합니다.       result.push(sideDish);       return;     }      // idx번째 요소가 포함되지 않는 경우     sidePowerSet(idx + 1, sideDish);      // idx번째 요소가 포함되는 경우     sidePowerSet(idx + 1, [...sideDish, sideDishes[idx]]);   };    // 0 번째 인덱스와 빈 배열을 인자로 받는 재귀 함수를 실행합니다.   sidePowerSet(0, []);    // 결과를 사전식 순서로 정렬합니다.   return result.sort(); }   느낀 점   Reference Code와 크게 다르지 않다.   역시 다시 풀어보아도 어려운 문제이다… 일단은 자주 보고 자주 풀어보는게 정답인듯하다. 문제를 보자마자 “어!? 풀어본 문제인데?” 생각은 들었다…물론 스스로 구현은 아직 무리다..  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/algorithm/21.11.10.algorithm5/",
        "teaser": null
      },{
        "title": "[Blog] Minimal mistakes Utterances",
        "excerpt":"   Minimal mistakes Utterances   Utterances VS Disqus            현재 블로그 (21.11.17 기준)는 Minimal mistakes jekyll theme 에 댓글 창은 Disqus를 사용하고 있었다.              다만 조금..난잡하다? 라는 생각이 들던 중 어짜피 댓글도 안달리는데… GitHub Issue 기반으로 Comment를 작성하는 Utterances를 알게 되어서 변경해 보았다.            블로그 성격이 개발 블로그이기 때문에, 기존에 쓰던 Disqus 보다는 Github 계정으로 댓글을 작성할 수 있기 때문에 사용성이 조금 더 용이하다 생각이 들었다.        Utterances 적용하기     Github setting    간단하게 사용이 가능하다.   우선 utterances Github App 을 install 해준다.    utterances setting    Github App을 설치하였다면 https://utteranc.es/ 사이트에 들어간다.      utterances 설정에 앞서 owner/repo를 입력하라 나온다.        이러한 형식으로 알맞게 입력해준다.   그 뒤, Blog Post ↔️ Issue Mapping 옵션 선택창이 나온다.      다른 옵션은 모르겠고… default 값인 Issue title contains page pathname는 포스트 게시물의 .md 파일의 이름으로 연결된다. 게시물의 .md 파일명을 수정하게 되면 댓글또한 날아간다…   owner/repo와 Blog Post ↔️ Issue Mapping을 모두 선택하면 다음과 같은 script가 나온다.      해당 script 중 issue-term, theme을 기억해서 config.yml에 넣어주면 완료된다.   config.yml setting    repository               : \"JH8459/JH8459.github.io\" # GitHub username/repo-name    # 댓글 관련 부분 comments:   provider               : \"utterances\" # false (default), \"disqus\", \"discourse\", \"facebook\", \"staticman\", \"staticman_v2\", \"utterances\", \"custom\"   utterances:     theme                : \"github-light\" # \"github-light\" (default), \"github-dark\"     issue_term           : \"pathname\" # \"pathname\" (default)  완료    모두 설정이 완료된 후 commit 후 push 해 주면 다음과 같은 결과를 볼 수 있다.     ","categories": ["Blog"],
        "tags": [],
        "url": "/blog/21.11.17.Blog/",
        "teaser": null
      },{
        "title": "[Retrospect] 코드스테이츠 Section3 재수강",
        "excerpt":"   Retrospect   재수강을 하면서 같은 Section을 다시 진행하면서 간만에 새글을 쓰는 거 같다.   새로운 pair와 같은 Section을 다시 진행을 하는데…어렵다!! 여전히 어렵다 어렵다 느꼈던 부분은 다시봐도 어렵다 느꼈다..   물론 조금 나아진 점은 물론 있고, 머릿속에 남아 있는 잔재들로 해결을 해내곤 하지만, 여전히 부족한 부분에서 튀어나오는 구글링 포인트는 바뀌질 않았다.. 아직 “여전히 부족하구나, 갈길이 멀구나” 를 온전히 느끼고 있다.   오늘 했던 Sprint - Short.ly MVC 도 다시 풀어보니 백엔드 로직이 새삼 HA3와 비슷하구나..를 다시 풀며 느꼈다.   아무튼 부족한점이 너무 많았기에, 이번 기수이동이 오히려 잘 되었다 느끼고 있다.  말과 다르게 요즘 블로그 새 글이 뜸한데, 예전에 썼던 TIL들 중 부족한 부분들이 있다면 채워서 수정하고 있기 때문이다.   재수강 후 첫째 주는 솔직히 손에 잡히는게 없어서 루틴도 모두 깨졌는데, 이번 주 부터는 다시 돌아가고 있다. TOY는 다시 풀기 너무 싫어요…  ","categories": ["Retrospect"],
        "tags": [],
        "url": "/retrospect/21.11.17.retrospect/",
        "teaser": null
      },{
        "title": "[TIL] 1. 무료 도메인 주소를 이용한 AWS HTTPS 인증",
        "excerpt":"  Today I Learnd   기존에 EC2, S3, RDS를 통해 배포한 웹 애플리케이션(21.10.29 TIL 참조)을 무료 도메인(Freenom)으로 배포하는 Advanced한 삽질 과정을 백엔드/프론트엔드 영역을 나누어 포스팅 해보려 한다.    주의! CloudFront에서 AWS 인증서 검증은 us-east-1(버지니아 북부) 인증서만 검증이 된다.    s3와 CloudFront는 글로벌 지역으로 배포가 되고 ec2와 ELB는 지역 리전으로 나뉘어진다.   클라이언트는 글로벌 리전에서 작동하므로 리전에 영향을 받진 않을 듯 하고, 서버가 탑재될 ELB 서울리전으로 두고(CloudPing.info를 통한 속도 검증 결과 리전마다 속도차이가 명확히 있다.) 개발환경을 구성하는게 서버의 응답속도 때문에 이점이 있을 듯 한데 인증서 문제 때문에 골머리가 아팠다…   이를 간단히 해결하기 위해서 배포된 https://cmarket.cf 는 us-east-1 리전에서 웹서버가 작동하게 하여(CloudFront(클라이언트)와 ELB(서버) 인증서가 모두 us-east-1 동일한 인증서 1개로 해결가능)간단히 해결하였다.   1. 무료 도메인 HTTPS AWS 배포 - 백엔드   1-1. 도메인 발급      도메인 주소를 이용하여 HTTPS 인증방식을 사용하려면 우선 도메인을 발급받아야 한다.        AWS에서도 Route 53을 통한 도메인 구매가 가능하지만.. 비용부담이 발생하기도 하고 실제 상업사이트나 프로젝트/포트폴리오 목적이 아닌 학업 목적이기 때문에 무료 도메인 사이트인 Freenom에서 도메인 발급 후, 해당 도메인을 이용하였다.              무료 도메인은 예고없이 사라지거나 로그인이 안되는(?)등 종잡을 수 없는 문제가 발생 할 수 있으므로..이런 부분은 감안하고 학습목적 정도로만 사용하도록 하는게 알맞은 사용방향이라 생각한다.            cmarket.cf 주소로 도메인을 발급 받았으며 최초 발급 후 도메인에 접속하면 DNS 설정도 안된 빈 도메인이기 때문에 아래와 같은 에러코드를 받을 수 있다.              1-2. ELB 생성   ELB란?           AWS에서 설명하는 ELB는 다음과 같다.              단순한 로드 밸런서* 역할 외에도 인증서 관리등 HTTPS 인증방식 지원까지 겸하고 있는 만능 서비스이다.              로드 밸런서란?         하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도저하 등을 고려하여 적절히 분산처리하여 해결해주는 서비스.                      ELB 서비스가 왜 필요한지 개념을 알았으니, AWS EC2 메뉴중 로드밸런서로 들어가 보자.                   로드밸런서를 생성하려보니 여러 유형을 선택 할 수 있는 선택창이 나온다.              우리는 HTTPS 인증 방식을 이용할 예정이니 1번을 선택하자.            로드 밸런서 이름을 정한 뒤,              네트워크 맵핑에서는 가용 영역을 모두 체크해주자.              그리고 리스너* 를 추가해 주어야 한다.              리스너란?         짧게 말해 리스너란, 구성한 프로토콜 및 포트를 사용해서 연결 요청을 확인하는 프로세스이다.            리스너의 구성된 프로토콜/포트로 요청이 왔을때 대상그룹으로 연결(?)해주는 프로세스 같다. (확실하지 않다…)              리스너가 추가되면 각 리스너에 타겟 그룹을 설정해줘야 한다.            현재 배포하려는 웹 애플리케이션은 클라이언트와 서버가 토큰을 로컬스토리지에 담아 HTTP프로토콜로 데이터를 주고받고 있다.              그렇기 때문에 클라이언트 ⮕ 로드밸런서로 HTTPS 요청이 와도 인스턴스(웹서버)에는 HTTP 프로토콜로 전달해 주어야 서버에서 클라이언트의 요청에 알맞는 응답 결과를 반환 할 수 있다.            그러므로 HTTP/HTTPS 두 리스너는 모두 HTTP 80포트로 인스턴스 연결이 이뤄지게끔 타겟 대상을 설정 해주자.              그리고 상태검사에서는 성공코드를 201번으로 변경하여 대상타겟을 생성해주자.                   이제 로드밸런서가 외부 클라이언트로부터 HTTP/HTTPS 요청이 왔을 때 인스턴스로 이동하는 과정은 모두 완성하였다. 이제 인증서를 등록해 주어야 한다.              HTTPS 프로토콜을 이용하려면 신뢰할 수 있는 기관에서 발급받은 인증서로 통해 통신이 이뤄진다. AWS에서는 ACM(AWS에서 제공하는 인증서)를 권장하고 있으며, 기존 사용하던 인증서가 있다면 해당 인증서를 import 해주어서 로드밸런서에 인증서를 등록해줄수도 있다.       AWS에서도 무료로 인증서 발급을 해주기도하고, 권장하는 방법이기 때문에 새로 발급해서 사용하기로 하였다.       1-3. ACM을 통한 인증서 발급           AWS에서 발급 가능한 인증서를 만들기 위해 우선 새 인증서 요청 버튼으로 진입 후 요청을 눌러준다.              퍼블릭 인증서 요청을 선택한 뒤 다음 버튼을 누르면, 도메인 이름과 검증 방식을 설정해 준다.              도메인 이름에 다른이름을 추가한 이유는 서버/클라이언트 각각 다른 도메인으로 배포하기 위함이다. (서버는 server.cmarket.cf 로 배포하였다.)  Freenom에서 발급 받은 도메인 앞에 와일드카드(*)를 입력하여 도메인이름을 설정하였다.       그리고 검증방식은 DNS 방식을 선택해주자. (이게 간편하다고 하더라..)            조금 기다린 뒤 인증서 ID를 눌러보면 CNAME 값이 생성된 것을 볼 수 있다.              그 뒤 Manage Freenom DNS 로 이동해 준다.                     AWS Route 53에서 발급받은 도메인이라면 레코드 추가하기로 간편하게 Route 53에서 DNS 검증이 가능하지만, 무료 도메인을 발급 받은 상황이기때문에 Freenom DNS로 가서 설정을 변경해줘야 한다.            TYPE을 CNAME 으로 변경해 준 뒤, AWS에서 확인한 CNAME 이름과 값을 넣어주고 저장해준다. 그 후 ACM으로 와서 검증이 끝날 때 까지(5~10분정도 소요되었다.) 기다려주면 아래와 같은 인증서 발급 완료 안내를 확인 할 수 있다.                   생성 중이던 로드밸런서에 발급받은 인증서를 넣고 생성을 완료한다.       1-4. Freenom ⬌ Route 53 연결   Route 53란?           우선 Route 53은 AWS에서 제공하는 DNS(Domain Name Service)이다.       그 외에도 도메인과 관련된 여러가지 서비스를 제공한다. 간략히 DNS 개념만 언급하자면 IP로 도메인을 기억하기는 힘들기때문에 사람이 기억하기 이름 형태로 변환해주는 시스템이다.                이제 Freenom DNS 검증은 완료되었다, AWS에서 해당 도메인을 사용하기 위해서 Freenom Nameservers 설정을 변경해 주자.              위 사진 영역에 Route 53에서 호스팅 영역을 생성 후 NS 에 해당하는 라우팅 대상을 맵핑해서 넣어주면 된다.                   이제 Freenom에서 발급 받은 무료 도메인(cmarket.cf)은 AWS Certificate Manager을 받기 위한 DNS 검증도 끝났으며, Route 53 호스팅 영역에도 연결이 되었다.       1-5. Route 53 ⬌ ELB 연결           Route 53도 도메인과 연결되어 있으며 ELB도 인스턴스에 연결되어 있는 상태이다. 이 둘을 연결만 해주면 도메인에서도 인스턴스 접근이 가능하다.  Route 53 메뉴로 가서 레코드 한줄만 써주도록 하자.       서버를 도메인에 등록할텐데, 인증서 발급시 와일드카드(*)로 주었기 때문에 서버의 도메인은 원하는 이름을 주어도 가능하다. 아래 사진과 같이 레코드를 생성해주었다.              1-6. 연결 확인           이제 server.cmarket.cf 도메인을 브라우저 검색창에 검색한다면, AWS의 Route 53의 DNS서비스를 통하여 ELB에 접근하게된다.       ELB에서는 트래픽을 자동으로 분산 시켜서 HTTPS/HTTP 을 요청을 리스너를 통하여 HTTP/80번 포트로 EC2 인스턴스 접근을 허용시킨다.            EC2에 서버가 켜져있다면 endpoint / 로 접근이 될것이므로,         app.get('/', (req, res) =&gt; {       res.status(201).send('Hello World');   });           따라서 https://server.cmarket.cf 도메인 검색시 아래와 같은 결과가 확인된다.              해당 도메인에 AWS에서 발급받은 인증서가 유효하게 작동하는 HTTPS 서버 도메인이 완성되었다.       2. 무료 도메인 HTTPS AWS 배포 - 프론트엔드    2-1. S3 버킷 엔드포인트 수정           기존 버킷에 등록된 빌드 파일은 HTTP로 서버와 클라이언트간 통신이 이뤄지고 있었다.              ACM을 이용한 HTTPS 인증방식이 이뤄질 수 있도록 클라이언트의 .env 파일을 수정하여 엔드포인트를 https://server.cmarket.cf 로 변경해 준 뒤 다시 빌드하여 버킷에 다시 업로드 해주었다.      2-2. CloudFront 배포 생성 (S3 ⬌ CloudFront 연결)            버킷으로는 인증서를 이용한 HTTPS 인증방식이 불가능하기 때문에, S3를 CloudFront에 연결해 주어야 한다.        우선 CloudFront 생성하기로 진입 후 원본 도메인에서 기존 S3 버킷을 선택해 준다.                   기본 캐시동작에서 뷰어 프로토콜 정책은 Redirect HTTP to HTTPS 로 선택해 준다                   그 다음 설정에서 CNAME은 도메인으로 쓸 cmarket.cf를 입력 해 준뒤, 미리 생성해 둔 인증서(us-east-1)를 등록해준다.              인증서는 반드시 미국 동부(버지니아 북부) 리전(us-east-1)에 있어야 합니다.  이 문구 때문에 사실 서울 리전을 한번 갈아 엎고 미국 동부 리전에서 다시 시작하였다…  장난..??       그리고 계속하여 설정에서 기본값 루트 객체를 index.html으로 수정해준 뒤 배포 생성을 완료해준다.                   그 뒤 배포 상태가 활성화 됨으로 확인되면, 배포 아이디 클릭 후 오류 페이지로 접근 하여 사용자 정의 오류 응답을 작성해 준다.              에러코드 403번과 404번 모두 오류 응답 200번 코드로 응답 페이지는 /index.html 으로 설정 해준다.              이제 클라이언트도 유효한 인증서를 기반으로 HTTPS 인증방식으로 서버와 통신할 수 있게 배포가 되었다.       2-3. Route 53 ⬌ CloudFront 연결           사실 Cloudfront 배포가 성공하였다면, AWS에서 제공하는 유효한 도메인이 발급이 된다.              다만..(이쁘지 않다..) 애써 발급받은 도메인을 놀리기엔 아깝지 않은가? ELB를 도메인과 연결시켰듯이 클라이언트가 담긴 Cloudfront 또한 Route 53에서 별칭 레코드를 생성해주자.            Route 53의 호스팅 영역으로 간뒤, 레코드 생성을 아래와 같이 해준다.              cmarket.cf 도메인 주소를 클라이언트가 보여지는 영역으로 쓸 것이므로 이름값은 따로 주지 않았다.       2-4. 연결 확인           이제 클라이언트/서버가 모두 HTTPS 인증방식으로 내가 원하는 도메인으로 발급이 모두 완료되었다.              리스너를 HTTP/HTTPS 방식 모두 지원하기 때문에 도메인에 배포한 HTTPS 방식의 통신도 지원하며, S3 버킷에서 HTTP 환경으로 클라이언트를 구동시켜도 모두 서버와 원활히 통신이 가능하다.            오늘 느낀 점     AWS…너무 어렵다.  단순히 인스턴스 올리고 버킷에 객체 업로드 하고 RDS로 DB 생성 후 연동하는건 정말 걸음마 단계였던거 같다.   원래 해당 스프린트는 Advanced 과정으로 코드스테이츠에는 Route 53에서 도메인을 구매 후 진행하라 일러준다.    학습과정에서 적게는 9$ 이상씩 지불하기가 아깝기도 하고.. AWS에서 지원하지 않는 외부 도메인을 사용해서 Route 53에서 등록하는 과정까지 학습과정에서는 모두 좋은 경험이라 생각든다.        마음에 안드는 부분은 CloudFront 배포가 무조건 us-east-1 리전에서만 가능하기때문에 EC2 인스턴스도 억지로 서울 리전을 버리고 us-east-1 리전으로 강제 이주하였다..       서두에 말했듯이, 미국지역 리전의 응답속도와 서울 리전의 응답속도는 하늘과 땅차이 였다.              위와 같이 엄청난 속도차이가 있다.(역시 인터넷 속도는 한국) 서울 리전에 서버를 두고 다시 배포해보는 과정을 생각해봐야 겠다. (이렇게 되면 클라이언트/서버 각각 인증서가 리전이 다른데 유효할지 의문이 든다..)       찜찜하지만.. 우선 초기에 목표로 둔 내가 원하는 도메인에 HTTPS 인증방식으로 배포하는게 성공해서 잠은 푹 잘 수 있을듯 하다.            ","categories": ["TIL"],
        "tags": [],
        "url": "/til/21.11.26.til/",
        "teaser": null
      },{
        "title": "[Retrospect] 코드스테이츠 Section3 후기",
        "excerpt":"   Retrospect   18시까지 Hiring Assessments 과제형을 마친 뒤 저녁식사 후 HA를 통과했다는 메일을 받았다.   그동안 Section을 통과할때마다 블로그 후기글을 설문으로 제출하는 링크를 보아도 별 감흥이 없었지만, Section3를 겪으며 백엔드 포지션으로 진로를 정하기도 하였고 모든 HA를 끝낸 해방감(?)에 한번 후기를 남겨보려 한다.   Section3 어려웠나요?      우선 나는 33기로 코드스테이츠로 지원을 하였고 33기 Section3 HA에서 기수이동의 고배를 마셨다.   Section1 &amp; Section2가 HA가 쉬웠다..는 아니지만 Section3 HA에서는 엄격히 합격 여부를 선정하는거 같다.   그리고 팀단위로 2주, 4주 노력을 갈아넣는 프로젝트 진행 직전 최소한의 준비단계를 거친뒤 진행하라는 의미로 생각하면, 이러한 엄격한 선정방식은 당연하다 생각을 한다.    Section3는 백엔드&amp;컴퓨터공학과 애플리케이션을 웹으로 배포과정을 중심적으로 학습하는 섹션이다. 우선 단어만 들어봐도 썩 유쾌하지 않다. (공학…)   확실히 눈으로 보이며 즉각적인 피드백이 오는 클라이언트 설계를 학습해오다 백엔드 서버 중심의 설계를 배우다 보니 몇가지 어려운점이 있었다.   우선 가장 큰 문제점은 “눈으로 직접 보기가 어렵다” 였다.   [인증/보안] 기초 가 이 부분에서 정점을 찍는다. (진짜 어렵습니다.. 😂)      HTTPS 통신 위해 발급한 인증서는 어디서 보이지?   쿠키는 도대체 어디서 볼 수 있는거지?.. 로컬 저장소가 어디야…, 쿠키에 담긴 토큰은 어떻게 생겨먹었지?..   아니 Headers엔 뭐가 담긴것이고 왜 토큰을 잘라서 가져오지…등등   이는 Postman API 플랫폼이나 Chrome의 네트워크 탭등을 통해 확인하는 방법을 스프린트에서 학습하고 배우지만, 솔직히 앞서 말한 스프린트 내용만으로는 온전히 활용하기가 어려웠다.   이 부분은 꼭 추가적인 공부를 하셔서 어떠한 방식으로 클라이언트/서버가 요청과 결과를 주고받는지 눈으로 꼭 확인해보길 권유하고 싶다.  👍    두번째로 “배포”…        위에서 언급한 과정을 겪은 뒤 실제 도메인영역에 웹서비스를 배포하는 과정을 실습한다. (Advanced AWS HTTPS 배포 어렵습니다..😂)   AWS HTTPS 삽질한 배포 과정을 게시물로 남기기도 하였다.   이 두가지는 그래도 꼭 학습하고 넘어가야 백엔드 포지션으로써 “첫 발은 내딘다” 라고 생각한다.    마지막으로 “Hiring Assessments” HA 이다.   사실 불합격 고배를 한번 마신적이 있기 때문에, 애증의 대상이다.   코드스테이츠에서도 해당 시험을 직접적/간접적으로 언급하는걸 꺼려하기에 자세한 내용은 적지 않고 딱 한가지만 적고 넘어가려 한다.      “npm test” 테스트 코드들 누락없이 모두 통과하세요.     그래서 Section3 어렵냐? 결론은 무엇이냐?   어렵습니다.   하지만 이 어려운 과정을 헤쳐나가려 삽질하며 공부하는 과정이 반드시 있어야만 성장하고 드디어 서비스를 배포 할 수 있는 최소한의 자격을 얻는다고 생각한다.   Section3 이후 앞으로는?   이제 실전이다.  Section 을 거듭하며 마음에 맞는 스터디 팀원들이 생겼고 이 팀원들과 기획방향을 이제 맞춰보려 한다.   사실 지금껏 배워온 프레임워크라던지 기술 스택들은 지금 이 프로젝트 과정을 위해 모두 배운것 아닌가? 이제 모두 쏟아내어 결과물을 보고싶다. (많은 밤샘이 있을까 걱정중이다..😇)   앞으로 6주가 가장 중요하다 생각된다.   실질적 이 프로젝트들은 수료 후 취업과정에서 나를 가장 잘 보여줄 수 있는 수단이 될 것이라 생각된다. 솔직한 감정으로는 열심히..도 좋지만, 그보다는 잘 해내고 싶다.    여담으로 이 글을 본다면 나보다는 아래 기수이지 않을까? 생각이 든다.  그리고 준비된 사람이라 생각이 든다.   Section3의 난이도와 HA에 대한 막연한 불안감..,  곧 나에게 다가올 미래이기도 할테니 여러 다양한 사람에게 정보를 구하자 할 노력을 하고 계시다 생각이 든다.   나 또한 지금 선배기수들의 프로젝트 결과물과 진행과정들을 열심히 찾아 보며 불안감을 달래는 중이다. 😅   원하는 진로로 취업하는 그날까지 파이팅이다. 👍  ","categories": ["Retrospect"],
        "tags": [],
        "url": "/retrospect/21.12.08.retrospect/",
        "teaser": null
      },{
        "title": "[Retrospect] 코드스테이츠 Project 시작",
        "excerpt":"   Retrospect   우선 프로젝트가 아직 완성된게 아니라 회고는 아니고 시작 전 다짐 및 마음가짐을 적어보려 간단히 남긴다.   First Project 팀 선정   우선 Section3 HA 이전에 선배 기수들에게 프로젝트에 관련한 내용을 많이 들었다.   미리미리 준비해야 한다. 팀이 절반이다. 기획부터 시간이 오래 걸리므로 미리미리 준비하고 대비해라.   우선 틀린 말은 아닌거같다. 저번 주 금요일인 12.10 팀 설문조사가 이뤄지고, 미리 프로젝트 진행전 기획을 진행해 오던 팀원들을 적어서 내었고, 해당 팀원으로 구성된 팀이 오늘 부로 결정이 되었다.   그리고 SR 기획서를 오늘 포함하여 이틀안에 제출을 해야하는데, URClass에서 제공되는 SR 기획서에 기입해야할 양이 생각보다 많다.  기획서 및 Wiki 작성을 진심으로 임해야 할 듯 하다.   만약 후배기수가 이 글을 읽는다면, 팀을 미리 꾸리고 (물론 마음에 맞는 팀원 구하기가 어렵습니다..) 기획의 방향정도는 충분한 회의를 통하여 결정 후 팀 선정에 진입하길 권유하고 싶다. 👍   앞으로는?      이제 진짜 프로젝트 결과물을 팀 협업을 통해 만들어 내야 한다.  익숙하지 않는 Git Flow로 협업을 이루고, 작업 분담을 해가며 프로젝트를 진행해내야 한다.   팀 룰을 정하였고 (최소 6주??간 방콕), 웹 페이지를 완성하기 위한 최소한의 TODO 리스트를 작성해두고 1차 프로젝트의 기획의 갈무리는 어느정도 되었다 생각한다.   다만, 아직 익숙하지 않은 툴들과 프레임워크를 통해서 협업을 진행해야 한다는 사실은 막연한 두려움이 반, 그리고 좋은 결과물을 기대하는 기대감이 나머지 절반으로 두근거리고 있다.   당분간은 두개의 프로젝트에 전념하기 위해서 블로그는 당분간 글 작성이 없을거 같다.  두개의 프로젝트가 모두 끝난 후 회고 글을 작성해야겠다.  ","categories": ["Retrospect"],
        "tags": [],
        "url": "/retrospect/21.12.13.retrospect/",
        "teaser": null
      },{
        "title": "[Retrospect] 코드스테이츠 First Project",
        "excerpt":"(작성중)  ","categories": ["Retrospect"],
        "tags": [],
        "url": "/retrospect/21.12.24.Retrospect/",
        "teaser": null
      },{
        "title": "[Project] First Project",
        "excerpt":"(작성중)  ","categories": ["Project"],
        "tags": [],
        "url": "/project/21.12.25.Project/",
        "teaser": null
      },{
        "title": "[Retrospect] 코드스테이츠 Final Project",
        "excerpt":"(작성중)  ","categories": ["Retrospect"],
        "tags": [],
        "url": "/retrospect/22.01.25.Retrospect/",
        "teaser": null
      },{
        "title": "[Project] Final Project",
        "excerpt":"(작성중)  ","categories": ["Project"],
        "tags": [],
        "url": "/project/22.01.26.Final-Project/",
        "teaser": null
      },{
        "title": "[Retrospect] 코드스테이츠 34기 수료",
        "excerpt":"   Retrospect   코드스테이츠 수료 직후 드는 감정을 한 문장으로 정의하자면    고생했고 이제 시작이다.     프로젝트 기간에는 평균 수면 시간 2~3시간.. 그동안 수료를 보며 달려왔던 관성이 있어서, 프로젝트가 끝난 뒤 어영부영 12시쯤 잠에 들려고 눈을 감으면 온갖 생각들로 잠자리가 편하지 않다.   우선 수료하는 오늘 느낀 감정에 대해서 간략히 적어보려한다.   무엇을 배웠나?       웹 개발에 전반적인 흐름과 설계 구조에 대하여 공부하였다.   우선 프로그래밍 언어로는 JavaScript를 집중적으로 배웠으며 네트워크 구조, 자료구조와 알고리즘 등 공학에 관련된 기초 지식을 쌓았다.   기술스택을 말하자면 프론트엔드 기술로는 React를 이용한 Client 개발 기술, Redux를 이용한 상태관리 SASS &amp; Styled Components 등의 CSS 기술 또한 배웠다.   백엔드 기술로는 Node.js와 Express를 이용한 Server 개발을 주축으로 내가 만든 서버와 클라이언트 환경을 AWS 환경을 통하여 배포까지 직접 할 수 있게 되었다. 👍   앞으로는?   이제 주니어 개발자가 되기 위한 험난한 과정의 시작이다.😅  취업에 가장 중요한 시점은 수료후 8~9주 정도라 생각한다.   일단 자소서와 이력서를 다듬을 예정이다.   매일매일 프로그래머스와 백준 알고리즘 문제 풀이를 통해 코딩 테스트를 대비해 볼 예정이다.  백엔드 포지션 기술 면접 또한 대비할 예정이다.   코딩 테스트를 되도록 보는 회사를 찾아서 지원해볼 예정이다.   비전공 출신인 신입 개발자가 눈에 띄는 포트폴리오를 보여주긴 어렵다 생각되므로 알고리즘 풀이에 시간을 쏟아 볼 예정이다.   그리고 팀원들과 함께 파이널 프로젝트 리팩토링 기간을 가져보며 취업 준비를 겸해볼 예정이다.   사실 아직 무슨 회사에서 일해보고 싶은지 생각해 본 적이 없다. 😅  어떤 회사에 지원할지 우선 정하고 난 뒤 구직활동을 시작해 볼 예정이다.   원하는 진로로 취업하는 그날까지 파이팅이다. 👍  ","categories": ["Retrospect"],
        "tags": [],
        "url": "/retrospect/22.01.28.Retrospect/",
        "teaser": null
      },{
        "title": "[Project] Final Project - Refactoring 1일차",
        "excerpt":"  Refactoring   우선 Final Project만 대상이며 리팩토링 기간은 정해두지 않았다.   수료 이후 너무 헤이해지지 않도록 09:00 ~ 18:00 일정으로 팀원들과 다시 모여 프로젝트 결과물을 최소 보름~몇달간 재정비할 계획이다.   리팩토링 우선순위를 정해보았으며 다음과 같다.       1️⃣ 1순위       [클라이언트] useEffect            중복 실행 현상 (콘서트 조회시 조회수가 1회 이상씩 올라가는 현상)       비동기 처리 구현 (ex. Loading 중인 표현)           [클라이언트] TypeScript 문법 체크            어색한 문법및 Type 누락 코드 유지보수 필요           [서버] 서버 보안            JWT 토큰인증 방식 사용시 해싱과정이 없다(특히 비밀번호 변경시 인증코드와 새로운 패스워드가 클라이언트에서 그대로 담겨서 서버로 전달된다).       보안에 중점둔 서버 설계 필요           [배포] browser 호환성            safari 가 안된다?? 도메인 문제인지 Check 필요                 우선 큰 틀은 위과 같다.   이중 [클라이언트] TypeScript 문법 체크 &amp;&amp; [서버] 서버 보안 을 중점으로 Task를 가져갈 예정이다.   TypeScript는 내가 쓴 Client쪽 코드들을 중점적으로 유지보수할 계획이며, 서버는 보안에 중점을 두어서 다시 설계를 해보아야 할 듯 하다. 지금 바로 생각나는건 Bcrypt를 사용한 해싱 알고리즘 정도가 바로 떠오른다. (2~3개의 대중적인 해싱 방법을 찾아본 뒤, 비교 후 서버에 적용해볼 예정이다.)   보름 이내로 0순위 Task를 끝마치는게 1차 계획이다.   2️⃣ 2순위       [클라이언트] 반응형 레이아웃 유지보수**            반응형으로 레이아웃이 바뀔시 작동하는 애니메이션 넣기       전반적인 홈페이지 반응형 레이아웃 점검           [서버] JWT 토큰이 없을시 로그아웃 자동처리            토큰이 없음에도 토큰 검증이 진행되는 현상           [배포] AWS EC2 사용시 보안에 중점을 둔 서버            PM2로 24시간 켜져있는 서버의 보안 고려하기                 0순위 다음으로 시급한 리팩토링 대상은 위와 같다.  이중 [서버] JWT 토큰이 없을시 로그아웃 자동처리를 중점으로 Task를 가져갈 예정이다.   1순위는 우선 0순위 Task가 완료 될시 진행해볼 예정이다.   3️⃣ 3순위       [공통] 안쓰는 모듈 Uninstall   [공통] 문서작업 재정비         마지막으로는 안쓰는 모듈들을 Check해서 배포시 Package.json에 불필요한 모듈이 들어가지 않게 점검 후 프로젝트 문서를 재정비해볼 예정이다.   우선 오늘은 프로젝트 전반적인 리팩토링 대상 우선순위를 점검하였으며, 필요한 부분들을 각자 공부해볼 예정이다. 오늘은 해싱관련 내용을 찾아본 뒤 스스로 정리하는 시간을 가져보려 한다.   본격적인 코드수정 작업은 내일부터 해 볼 예정이다.      ","categories": ["Project"],
        "tags": [],
        "url": "/project/22.02.07.refactoring/",
        "teaser": null
      },{
        "title": "[TIL] 암호화 해싱 (작성중)",
        "excerpt":"  ","categories": ["TIL"],
        "tags": [],
        "url": "/til/22.02.07.til/",
        "teaser": null
      }]
